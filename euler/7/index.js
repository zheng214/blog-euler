const fs = require('fs');
const path = require('path');
const utils = require('../utils');

module.exports = {
  /**
   * Problem 61 Cyclical figurate numbers
   *
   * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
   *
   * Triangle P3,n=n(n+1)/2  1, 3, 6, 10, 15, ...
   *
   * Square P4,n=n²  1, 4, 9, 16, 25, ...
   *
   * Pentagonal P5,n=n(3n−1)/2   1, 5, 12, 22, 35, ...
   *
   * Hexagonal P6,n=n(2n−1)   1, 6, 15, 28, 45, ...
   *
   * Heptagonal P7,n=n(5n−3)/2   1, 7, 18, 34, 55, ...
   *
   * Octagonal P8,n=n(3n−2)   1, 8, 21, 40, 65, ...
   *
   * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
   *
   * 1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
   *
   * 2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
   *
   * 3. This is the only set of 4-digit numbers with this property.
   *
   * @question Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
   * @guide
   * We start by building a few tables:
   * 1. <code>polygonalTables</code>: this array contains the tables of triangles, squares, pentagonal, ..., and octogonal numbers. In each table, the keys are the numbers itself, and the values are truthy placeholders.
   * 2. <code>prefixLookup</code>: This table would look like something like this:
   * {
   *    10: {
   *        3: [triangle numbers starting with 10],
   *        4: [squares starting with 10],
   *        ...,
   *        8: [octogonal numbers starting with 10],
   *    },
   *    11: {
   *        3: [triangle numbers starting with 11],
   *        ...,
   *        8: [octogonal numbers starting with 11],
   *    }
   * }
   * 
   * Then, for each octogonal number, we attempt to build a path.
   * For example, starting with 1045, we find in the prefix table all figurate numbers starting with 45, and recursively attempt to build a path from each of those numbers, while respecting that each number must correspond to a different figure.
   * If we manage to build a path of length 6, and the first 2 digits of first number in the path = the last 2 digits of last number in the path, we are done.
   */
  e61() {
    const polygonalTables = [{}, {}, {}, {}, {}, {}];
    const startingIndexes = [45, 32, 26, 23, 21, 19];
    const polygonGenerators = [
      n => n * (n + 1) / 2,
      n => n * n,
      n => n * (3 * n - 1) / 2,
      n => n * (2 * n - 1),
      n => n * (5 * n - 3) / 2,
      n => n * (3 * n - 2),
    ];

    // table indexed by prefixes
    // constructed such that finding all the polygonals starting with any 2 digits can be done with O(1)
    const prefixLookup = {};

    for (let i = 0; i < startingIndexes.length; i++) {
      const side = i + 3;
      const startingIndex = startingIndexes[i];
      let generatedNumber = 0;
      for (let n = startingIndex; generatedNumber < 10000; n++) {
        generatedNumber = polygonGenerators[i](n);
        const [prefix, suffix] = `${generatedNumber}`.match(/\d{1,2}/g);
        if (suffix.charAt(0) === '0' || generatedNumber > 9999) {
          // third digit is 0, cannot be in a cycle
          continue;
        }
        polygonalTables[i][generatedNumber] = true;

        if (!prefixLookup[prefix]) {
          prefixLookup[prefix] = {};
        }

        if (!prefixLookup[prefix][side]) {
          prefixLookup[prefix][side] = [];
        }

        prefixLookup[prefix][side].push(generatedNumber);
      }
    }

    const octagons = polygonalTables[5];

    // simulate a tree, recursively find a path of length 6
    function findPath(path, acc) {
      // cycle complete
      if (path.length === 6) {
        const first = path[0];
        const last = path[5];
        if (Math.floor(first / 100) === last % 100) { // the first 2 digits of first = the last 2 digits of last
          // FOUND!
          return path;
        }
        return false;
      }
      const last = path[path.length - 1];

      const suffix = last.toString().match(/\d{1,2}/g)[1];

      // all polygonals starting with the current suffix
      const nextPolygons = prefixLookup[suffix];
      if (!nextPolygons) {
        return false;
      }

      // find the next polygon from all sides which are still missing from the cycle
      const missingSides = Object.keys(acc).filter(key => !acc[key]);
      for (let i = 0; i < missingSides.length; i++) {
        const missingSide = missingSides[i];
        const nextMatchingPolygons = nextPolygons[missingSide];
        if (nextMatchingPolygons) {
          for (let j = 0; j < nextMatchingPolygons.length; j++) {
            const nextPolygon = nextMatchingPolygons[j];
            // if a valid path is found, return it, otherwise keep looping
            const findNextPath = findPath([...path, nextPolygon], { ...acc, [missingSide]: nextPolygon });
            if (findNextPath) {
              return findNextPath;
            }
          }
        }
      }

      // if no polygons are found with none of the missing sides, return false
      return false;
    }

    // we start our path from the octagons to minimize loop count
    for (let o = 0; o < Object.keys(octagons).length; o++) {
      const octagon = +Object.keys(octagons)[o];
      const validPath = findPath([octagon], {
        3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: octagon,
      });
      if (validPath) {
        return utils.sumArray(validPath);
      }
    }
  },

  /**
   * Problem 62 Cubic permutations
   *
   * The cube, 41063625 (345^3), can be permuted to produce two other cubes: 56623104 (384^3) and 66430125 (405^3).
   *
   * In fact, 41063625 is the smallest cube which has exactly three permutations of its digits which are also cube.
   *
   * @question Find the smallest cube for which exactly five permutations of its digits are cube.
   * @guide
   * We generate cubes one by one. For each cube, we sort its digit and index it in <code>cubeClasses</code>, we store along it the original cube as well.
   * When an index has 5 cubes in it, we found our result.
   */
  e62() {
    const cubeClasses = {};

    let base = 1;
    let found = false;
    while (!found) {
      const cube = base ** 3;
      const sortedKey = cube.toString().split('').sort().join('');
      if (!cubeClasses[sortedKey]) {
        cubeClasses[sortedKey] = [cube];
      } else {
        cubeClasses[sortedKey].push(cube);
      }

      if (cubeClasses[sortedKey].length > 4) {
        found = true;
        return cubeClasses[sortedKey][0];
      }
      base++;
    }
  },

  /**
   * Problem 63 Powerful digit counts
   *
   * The 5-digit number, 16807=7^5, is also a fifth power. Similarly, the 9-digit number, 134217728=8^9, is a ninth power.
   * @question How many n-digit positive integers exist which are also an nth power?
   * @guide
   * First observe that the base must be strictly smaller than 10, since 10^n will have at least n+1 digits.
   * We then check one by one, as follows:
   * 9¹, 9², 9³, ... and stop when the number of digits in the result is less than the exponent
   * Repeat the same for 8, 7, ..., 1
   * Each time we pass the loop, it means that the number of digits in the result is equal to the exponent, so we increment our answer.
   */
  e63() {
    let answer = 0;
    for (let base = 9; base > 0; base--) {
      let exponent = 1;
      let power = base ** exponent;
      let digitCount = power.toString().length;
      while (digitCount === exponent) {
        answer++;
        exponent++;
        power = base ** exponent;
        digitCount = power.toString().length;
      }
    }
    return answer;
  },

  /**
   * Problem 64 Odd period square roots
   *
   * All square roots are periodic when written as continued fractions and can be written in the form:
   *
   * @math \displaystyle \quad \quad \sqrt{N}=a_0+\frac 1 {a_1+\frac 1 {a_2+ \frac 1 {a3+ \dots}}}
   *
   * For example, let us consider √23:
   *
   * @math \quad \quad \sqrt{23}=4+\sqrt{23}-4=4+\frac 1 {\frac 1 {\sqrt{23}-4}}=4+\frac 1  {1+\frac{\sqrt{23}-3}7}
   *
   * If we continue we would get the following expansion:
   *
   * @math \displaystyle \quad \quad \sqrt{23}=4+\frac 1 {1+\frac 1 {3+ \frac 1 {1+\frac 1 {8+ \dots}}}}
   *
   * The process can be summarized as follows:
   *
   * @math \quad \quad a_0=4, \frac 1 {\sqrt{23}-4}=\frac {\sqrt{23}+4} 7=1+\frac {\sqrt{23}-3} 7
   * @math \quad \quad a_1=1, \frac 7 {\sqrt{23}-3}=\frac {7(\sqrt{23}+3)} {14}=3+\frac {\sqrt{23}-3} 2
   * @math \quad \quad a_2=3, \frac 2 {\sqrt{23}-3}=\frac {2(\sqrt{23}+3)} {14}=1+\frac {\sqrt{23}-4} 7
   * @math \quad \quad a_3=1, \frac 7 {\sqrt{23}-4}=\frac {7(\sqrt{23}+4)} 7=8+\sqrt{23}-4
   * @math \quad \quad a_4=8, \frac 1 {\sqrt{23}-4}=\frac {\sqrt{23}+4} 7=1+\frac {\sqrt{23}-3} 7
   * @math \quad \quad a_5=1, \frac 7 {\sqrt{23}-3}=\frac {7 (\sqrt{23}+3)} {14}=3+\frac {\sqrt{23}-3} 2
   * @math \quad \quad a_6=3, \frac 2 {\sqrt{23}-3}=\frac {2(\sqrt{23}+3)} {14}=1+\frac {\sqrt{23}-4} 7
   * @math \quad \quad a_7=1, \frac 7 {\sqrt{23}-4}=\frac {7(\sqrt{23}+4)} {7}=8+\sqrt{23}-4
   *
   * It can be seen that the sequence is repeating. For conciseness, we use the notation √23=[4;(1,3,1,8)], to indicate that the block (1,3,1,8) repeats indefinitely.
   *
   * The first ten continued fraction representations of (irrational) square roots are:
   *
   * √2 = [1;(2)] , period=1
   *
   * √3 = [1;(1,2)], period=2
   *
   * √5 = [2;(4)], period=1
   *
   * √6 = [2;(2,4)], period=2
   *
   * √7 = [2;(1,1,1,4)], period=4
   *
   * √8 = [2;(1,4)], period=2
   *
   * √10 = [3;(6)], period=1
   *
   * √11 = [3;(3,6)], period=2
   *
   * √12 = [3;(2,6)], period=2
   *
   * √13 = [3;(1,1,1,1,6)], period=5
   *
   * Exactly four continued fractions, for N≤13, have an odd period.
   *
   * @question How many continued fractions for N≤10000 have an odd period?
   * @guide
   * The code "simply" implements the procedure outlined in the question. This was very fun for me.
   */
  e64() {
    const squares = [...Array(100)].reduce((acc, _, i) => {
      acc[i ** 2] = true;
      return acc;
    }, {});

    let answer = 0;

    for (let N = 2; N < 10000; N++) {
      if (squares[N]) {
        continue;
      }

      // we generate the sequence of isolated integers (ie. leading numbers in the continued fraction sequence) by
      // 1. Normalizing our irrational fraction (ie. numerator/(root-offset)) by multiplying by (root+offset)/(root+offset)
      // 2. Isolating the next leading integer by finding the integral part of our normalized fraction
      // 3. flip the fractional part to use for the next iteration
      const root = Math.sqrt(N);
      const floor = Math.floor(root);

      let repetitionFound = false; // if a repetition has been found, we can exit the loop (explained below)

      // the following variables are updated on every iteration
      let period = 0; // period count

      let isolatedInteger = floor; // leading digit of our current iteration
      let normalizedDenominator; // the denominator as a result of normalization

      // the normalized and reduced denominator (by the initial numerator) of the previous iteration
      let initialNumerator = 1;
      // the offset found in the denominator as a result of isolating the leading integer from the previous iteration
      let denominatorOffset = floor;

      while (!repetitionFound) {
        // normalize
        normalizedDenominator = N - (denominatorOffset ** 2);

        // isolate
        isolatedInteger = Math.floor(initialNumerator * (floor + denominatorOffset) / normalizedDenominator);
        period++;
        if (normalizedDenominator === initialNumerator) {
          // the initialNumerator always starts with 1
          // if the above two variables are equal, then the next initialNumerator will be 1,
          // which will cause the cycle to repeat
          repetitionFound = true;
          if (period & 1) {
            answer++;
          }
          break;
        }

        // update for next iteration
        initialNumerator = normalizedDenominator / initialNumerator;
        denominatorOffset = Math.abs(denominatorOffset - initialNumerator * isolatedInteger);
      }
    }
    return answer;
  },

  /**
   * Problem 65 Convergents of e
   *
   * The square root of 2 can be written as an infinite continued fraction.
   *
   * @math \sqrt{2} = 1 + \dfrac{1}{2 + \dfrac{1}{2 + \dfrac{1}{2 + \dfrac{1}{2 + ...}}}}
   *
   * The infinite continued fraction can be written, √2=[1;(2)], (2) indicates that 2 repeats ad infinitum. In a similar way, √23=[4;(1,3,1,8)].
   *
   * It turns out that the sequence of partial values of continued fractions for square roots provide the best rational approximations. Let us consider the convergents for √2.
   *
   * @math 1 + \dfrac{1}{2} = \dfrac{3}{2}
   * @math 1 + \dfrac{1}{2 + \dfrac{1}{2}} = \dfrac{7}{5}
   * @math 1 + \dfrac{1}{2 + \dfrac{1}{2 + \dfrac{1}{2}}} = \dfrac{17}{12}
   * @math 1 + \dfrac{1}{2 + \dfrac{1}{2 + \dfrac{1}{2 + \dfrac{1}{2}}}} = \dfrac{41}{29}
   *
   * Hence the sequence of the first ten convergents for √2 are:
   *
   * @math 1, \dfrac{3}{2}, \dfrac{7}{5}, \dfrac{17}{12}, \dfrac{41}{29}, \dfrac{99}{70}, \dfrac{239}{169}, \dfrac{577}{408}, \dfrac{1393}{985}, \dfrac{3363}{2378}, ...
   *
   * What is most surprising is that the important mathematical constant,
   *
   * @math e = [2; 1, 2, 1, 1, 4, 1, 1, 6, 1, ... , 1, 2k, 1, ...]
   *
   * The first ten terms in the sequence of convergents for e are:
   *
   * @math 2, 3, \dfrac{8}{3}, \dfrac{11}{4}, \dfrac{19}{7}, \dfrac{87}{32}, \dfrac{106}{39}, \dfrac{193}{71}, \dfrac{1264}{465}, \dfrac{1457}{536}, ...
   *
   * The sum of digits in the numerator of the 10th convergent is 1+4+5+7=17.
   *
   * @question Find the sum of digits in the numerator of the 100th convergent of the continued fraction e
   * @guide
   * We start from the 100th leading integer, and work our way down. At each step, we compute the partial fraction result.
   */
  e65() {
    function getNthLeadingInteger(n) {
      if (n < 3) {
        return n;
      }

      if (n % 3 === 2) {
        return 2 * (Math.floor(n / 3) + 1);
      }

      return 1;
    }

    const target = 100;
    let numerator = 1n;
    let denominator = BigInt(getNthLeadingInteger(target - 1));
    for (let i = target - 1; i >= 1; i--) {
      const nextLeadingInteger = BigInt(getNthLeadingInteger(i - 1));
      [numerator, denominator] = [denominator, nextLeadingInteger * denominator + numerator];
    }

    numerator += (denominator * 2n); // add leading constant
    return utils.sumArray(numerator.toString().split(''), n => +n);
  },

  /**
   * Problem 66 Diophantine equation
   *
   * Consider quadratic Diophantine equations of the form: x² - D * y² = 1
   *
   * For example, when D=13, the minimal solution in x is 649² – 13×180² = 1.
   *
   * It can be assumed that there are no solutions in positive integers when D is square.
   *
   * By finding minimal solutions in x for D = {2, 3, 5, 6, 7}, we obtain the following:
   *
   * 3² – 2×2 = 1
   *
   * 2² – 3×1² = 1
   *
   * 9² – 5×4² = 1
   *
   * 5² – 6×2² = 1
   *
   * 8² – 7×3² = 1
   *
   * Hence, by considering minimal solutions in x for D ≤ 7, the largest x is obtained when D=5.
   *
   * @question Find the value of D ≤ 1000 in minimal solutions of x for which the largest value of x is obtained.
   * @guide
   * This methods uses continued fractions to solve for x and y. There is a connection between the continued fraction expansion of sqrt(D) and the solutions x and y. <a target="__blank" href="https://en.wikipedia.org/wiki/Pell's_equation#Fundamental_solution_via_continued_fractions">Wikipedia</a>. 
   */
  e66() {
    // to solve for (x,y) for any D, we need to:
    // 1. find the sequence of leading digits for the continued fractions of sqrt(D)
    // 2. from the list above, expand continued fractions until a solution is found

    let largestSolution = 0n;
    let ANSWER = 0;
    // we combine the previous 2 solutions to achieve the steps above
    for (let D = 2; D <= 1000; D++) {
      // find leading digits
      const sqrt = Math.sqrt(D);
      const floor = Math.floor(sqrt);
      if (sqrt === floor) {
        continue;
      }
      let repetitionFound = false; // if a repetition has been found, we can exit the loop (explained below)

      // Step 1: Sequence of leading digits
      const leadingDigits = [];

      let isolatedInteger = floor; // leading digit of our current iteration
      let normalizedDenominator; // the denominator as a result of normalization

      // the normalized and reduced denominator (by the initial numerator) of the previous iteration
      let initialNumerator = 1;
      // the offset found in the denominator as a result of isolating the leading integer from the previous iteration
      let denominatorOffset = floor;

      while (!repetitionFound) {
        // normalize
        normalizedDenominator = D - (denominatorOffset ** 2);

        // isolate
        isolatedInteger = Math.floor(initialNumerator * (floor + denominatorOffset) / normalizedDenominator);
        leadingDigits.push(isolatedInteger);
        if (normalizedDenominator === initialNumerator) {
          // the initialNumerator always starts with 1
          // if the above two variables are equal, then the next initialNumerator will be 1,
          // which will cause the cycle to repeat
          repetitionFound = true;
          break;
        }

        // update for next iteration
        initialNumerator = normalizedDenominator / initialNumerator;
        denominatorOffset = Math.abs(denominatorOffset - initialNumerator * isolatedInteger);
      }

      // Step 2: search for solution

      // solution verifier
      const isSolution = (x, y) => (((x ** 2n) - (BigInt(D) * (y ** 2n))) === 1n);
      // returns nth leading integer in the continued fraction expansion of sqrt(D)
      const getNthLeadingInteger = n => leadingDigits[(n - 1) % leadingDigits.length];

      // initial values
      let target = 1;
      let numerator = BigInt(1);
      let denominator = BigInt(getNthLeadingInteger(target));

      // loop while a solution is not found
      while (!isSolution(numerator, denominator)) {
        numerator = BigInt(1);
        denominator = BigInt(getNthLeadingInteger(target));
        // find the convergent at the `target` index by using backtracking
        for (let i = target - 1; i >= 1; i--) {
          const nextLeadingInteger = BigInt(getNthLeadingInteger(i));
          [numerator, denominator] = [denominator, nextLeadingInteger * denominator + numerator];
        }
        numerator += (denominator * BigInt(floor));
        target++;
      }

      if (numerator > largestSolution) {
        largestSolution = numerator;
        ANSWER = D;
      }
    }
    return ANSWER;
  },

  /**
   * Problem 67 Maximum Path Sum II
   *
   * By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.
   *
   *     3
   *
   *    7 4
   *
   *   2 4 6
   *
   *  8 5 9 3
   *
   * That is, 3 + 7 + 4 + 9 = 23.
   *
   * @question Find the maximum total from top to bottom in [triangle.txt @asset p067_triangle.txt], a 15K text file containing a triangle with one-hundred rows.
   * @guide
   * This is exactly the same problem and solution as problem 18, but with a larger triangle.
   */
  e67() {
    const rows = fs.readFileSync(path.join(__dirname, './p067_triangle.txt'))
      .toString()
      .split('\n')
      .map(row => row.split(' ').map(Number));

    // keeps track of the maximum score from the top to each number in the previous row
    let previousRowScores = [];

    rows.forEach((row, rowIndex) => {
      const currentRowScores = [];
      row.forEach((number, position) => {
        const isFirst = position === 0;
        const isLast = position === row.length - 1;
        if (rowIndex === 0) {
          // first row: score is just the number
          currentRowScores[0] = number;
        } else if (isFirst) {
          // first number of row: score is the score of the first element of previous row + this number
          currentRowScores[0] = previousRowScores[0] + number;
        } else if (isLast) {
          // last number of row: same as above
          currentRowScores[position] = previousRowScores[position - 1] + number;
        } else {
          const leftParent = previousRowScores[position - 1];
          const rightParent = previousRowScores[position];
          if (leftParent > rightParent) {
            // if the number is in the middle of a row (not first nor last), simply check which 'parent' is larger
            currentRowScores[position] = number + leftParent;
          } else {
            currentRowScores[position] = number + rightParent;
          }
        }
      });
      previousRowScores = currentRowScores;
    });

    return Math.max(...previousRowScores);
  },

  /**
   * Problem 68 Magic 5-gon ring
   *
   * Consider the following "magic" 3-gon ring, filled with the numbers 1 to 6, and each line adding to nine.
   *
   * @image p068_1.png
   *
   * Working clockwise, and starting from the group of three with the numerically lowest external node (4,3,2 in this example), each solution can be described uniquely. For example, the above solution can be described by the set: 4,3,2; 6,2,1; 5,1,3.
   *
   * It is possible to complete the ring with four different totals: 9, 10, 11, and 12. There are eight solutions in total.
   *
   *  Total      Solution Set
   *
   *  9      4,2,3; 5,3,1; 6,1,2
   *
   *  9      4,3,2; 6,2,1; 5,1,3
   *
   *  10     2,5,3; 6,3,1; 4,1,5
   *
   *  11     1,4,6; 3,6,2; 5,2,4
   *
   *  11     1,6,4; 5,4,2; 3,2,6
   *
   *  12     1,5,6; 2,6,4; 3,4,5
   *
   *  12     1,6,5; 3,5,4; 2,4,6
   *
   * By concatenating each group it is possible to form 9-digit strings; the maximum string for a 3-gon ring is 432621513.
   *
   * @image p068_2.png
   *
   * @question Using the numbers 1 to 10, and depending on arrangements, it is possible to form 16- and 17-digit strings. What is the maximum 16-digit string for a "magic" 5-gon ring?
   * @guide
   * The solution works by inputting every single permutation of numbers in the ring, and check if it gives a valid solution. More details are given in comments in the code.
   */
  e68() {
    // The first step consists of generating the list of permutations of digits in the inner and outer ring
    const DIGITS = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    const innerPermutations = [];
    const outerPermutations = [];
    for (let i1 = 1; i1 <= 5; i1++) {
      for (let i2 = i1 + 1; i2 <= 6; i2++) {
        for (let i3 = i2 + 1; i3 <= 7; i3++) {
          for (let i4 = i3 + 1; i4 <= 8; i4++) {
            for (let i5 = i4 + 1; i5 <= 9; i5++) {
              const innerRing = [i1, i2, i3, i4, i5];
              innerPermutations.push(innerRing);
              outerPermutations.push(DIGITS.filter(x => !innerRing.includes(x)));
            }
          }
        }
      }
    }

    let maxSolution = 0;
    // then, for each permutation, we check if it is a legitimate solution with the helper function below
    for (let i = 0; i < innerPermutations.length; i++) {
      const leadingDigit = innerPermutations[i][0];
      const basePermutation = innerPermutations[i].slice(1);
      const outerDigits = outerPermutations[i];
      for (let j = 1; j <= 24; j++) {
        const currentPermutation = utils.getLexicalPermutation(basePermutation, j).map(Number);
        currentPermutation.unshift(leadingDigit);
        const commonSum = findSolution(currentPermutation, outerDigits);
        if (commonSum) {
          // if a soution is found, find maximal string corresponding to that solution
          // first, find the index of the inner ring adjacent to the smallest outer digit
          const innerStartIndex = currentPermutation.findIndex((permDigit, permIndex) => {
            const currentInnerDigit = permDigit;
            const nextInnerDigit = currentPermutation[(permIndex + 1) % 5];
            return currentInnerDigit + nextInnerDigit === commonSum - outerDigits[0];
          });

          // then we go around the inner ring (clockwise) and preppend the corresponding outer digit
          let solutionString = '';
          for (let k = 0; k <= 4; k++) {
            const currentInnerRingDigit = currentPermutation[(innerStartIndex + k) % 5];
            const nextInnerRingDigit = currentPermutation[(innerStartIndex + k + 1) % 5];
            const currentSum = currentInnerRingDigit + nextInnerRingDigit;
            const correspondingOuterDigit = commonSum - currentSum;
            solutionString += `${correspondingOuterDigit}${currentInnerRingDigit}${nextInnerRingDigit}`;
          }
          const solution = +solutionString;
          if (solution > maxSolution) {
            maxSolution = solution;
          }
        }
      }
    }

    return maxSolution;

    // given a sequence of inner ring, return the common sum if a solution exists, false otherwise
    function findSolution(inner, outer) {
      // we go around the inner ring and extract all the sums of adjacent digits
      const sumsToTest = [...inner].reduce(
        (acc, curr, idx, arr) => {
          const nextIndex = idx === 4 ? 0 : idx + 1;
          const sum = curr + inner[nextIndex];
          if (acc[sum]) {
            // if there are duplicate sums in the inner ring,
            // a solution cannot exist as the outer ring numbers are all disinct
            arr.splice(1);
            return null;
          }
          acc[sum] = true;
          return acc;
        },
        {},
      );

      if (!sumsToTest) { // duplicate sums detected
        return false;
      }

      // the digits of the outer ring are sorted from smallest to largest by design
      // therefore we sort the sums of the inner ring from largest to smallest
      const partialSums = Object.keys(sumsToTest).map(Number).sort((a, b) => b - a);
      const SOLUTION_SUM = partialSums[4] + 10; // smallest inner sum + 10

      // we check if adding the corresponding index of the outer ring will result in the solution sum
      for (let i = 0; i <= 3; i++) {
        if (partialSums[i] + outer[i] !== SOLUTION_SUM) {
          return false;
        }
      }

      return SOLUTION_SUM;
    }
  },

  /**
   * Problem 69 Totient Maximum
   *
   * Euler's Totient function, φ(n) [sometimes called the phi function], is used to determine the number of numbers less than n which are relatively prime to n.
   *
   * For example, as 1, 2, 4, 5, 7, and 8, are all less than nine and relatively prime to nine, φ(9)=6.
   *
   * For n ≤ 10, n = 6 produces a maximum n/φ(n).
   *
   * @question Find the value of n ≤ 1,000,000 for which n/φ(n) is a maximum.
   * @guide
   * We use the Euler's formula for the totient function for all n <= 1 million.
   * For each n and for each prime p divisible by n, we multiply by ((p - 1) / p).
   * 
   * The intuition is as follows:
   * Let's take the number 60, which has prime divisors 2, 3, 5.
   * 1. We first extract the numbers NOT divisible by 2: p = 2 => 60 * 1/2 = 30. ie. there are 30 numbers NOT divisible by 2.
   * 2. Of those numbers, we extract numbers NOT divisible by 3: p = 3 => 30 * 2/3 = 20.
   * 3. finally, we extract from the previous result numbers not divisible by 5: 20 * 4/5 = 16.
   * Indeed, the numbers relatively prime to 60 are the numbers which are not divisible by 2, 3, or 5, and there are 16 of them.
   * 
   * We also use a heuristic to cut down a majority of numbers to test:
   * Since we want to maximize n/phi(n), we want to minimize phi(n), we need to find a number which is highly divisible.
   * We do that by MAXIMIZING the number of PRIME divisors, and by MINIMIZING the number n itself.
   * Therefore, we search incrementally with products of prime numbers from smallest to largest, and we stop if the product exceeds 1 million.
   * ie. 2, 2*3, 2*3*5, 2*3*5*7, etc.
   */
  e69() {
    const PRIMES_TABLE = utils.generatePrimesTable(100); // product of primes < 100 is guaranteed to exceed 1 million
    const PRIMES_ARR = Object.keys(PRIMES_TABLE).map(Number);
    let maxTotient = 0;
    let maxTotientNumber = 0;
    for (let i = 0; i < PRIMES_ARR.length; i++) {
      const factors = PRIMES_ARR.slice(0, i + 1);
      const product = factors.reduce((a, c) => a * c, 1);
      if (product > 1000000) {
        break;
      }
      const reverseTotient = factors.reduce((a, c) => a * c / (c - 1), 1); // shortcut to calculate n/phi(n)
      if (reverseTotient > maxTotient) {
        maxTotient = reverseTotient;
        maxTotientNumber = product;
      }
    }
    return maxTotientNumber;
  },

  /**
   * Problem 70 Totient permutation
   * Euler's Totient function, φ(n), is used to determine the number of positive numbers less than or equal to n which are relatively prime to n.
   *
   * For example, as 1, 2, 4, 5, 7, and 8, are all less than nine and relatively prime to nine, φ(9)=6.
   *
   * The number 1 is considered to be relatively prime to every positive number, so φ(1)=1.
   *
   * Interestingly, φ(87109)=79180, and it can be seen that 87109 is a permutation of 79180.
   *
   * @question Find the value of n, 1 < n < 10⁷, for which φ(n) is a permutation of n and the ratio n/φ(n) produces a minimum.
   * @guide
   * To minimize n/phi(n), we need to maximize phi(n), ie. we need to find n which is not highly divisible.
   * n cannot be prime as phi(n) = n - 1, and n and n - 1 cannot have the same digits.
   * 
   * Let p1, p2, ... pm denote the prime factors of n.
   * Therefore n/phi(n) := p1/(p1-1) * p2/(p2-1) * p3/(p3-1) * ... * pm/(pm-1).
   * In order to minimize the equation above, we need to minimize the number of terms (as each term > 1).
   * We also need to minimize each term by maximizing the value of the prime factors.
   */
  e70() {
    const PRIMES_TABLE = utils.generatePrimesTable(10000);
    // the number 10000 is chosen with the confidence that we can find 2 primes such that both are relatively large (4 digits).

    // our choice would fail if ALL solutions we can find consist of a prime larger than 10000 and a prime smaller than 1000.
    // ie. there exists no number n which satisfies the following conditions:
    // 1. n = p1 * p2
    // 2. φ(n) and n have the same digits 
    // 3. p1 and p2 are relatively large.

    const PRIMES_ARR = Object.keys(PRIMES_TABLE).reverse().map(Number);

    let minimalTotientRatio = 1.001; // arbitrarily large number
    let minimalTotientNumber = 0;

    for (let i = 0; i < PRIMES_ARR.length - 1; i++) {
      const p1 = PRIMES_ARR[i];
      const phi1 = p1 / (p1 - 1);
      if (phi1 > minimalTotientRatio) {
        break;
      }
      for (let j = 0; j < PRIMES_ARR.length; j++) {
        const p2 = PRIMES_ARR[j];
        if (p1 * p2 > 10 ** 7) {
          continue;
        }
        const phi2 = p2 / (p2 - 1);
        if (phi2 > minimalTotientRatio) {
          break;
        }
        const result = p1 * p2;
        const phi = (p1 - 1) * (p2 - 1);
        if (utils.haveSameDigits([result, phi])) {
          const totientRatio = result / phi;
          if (totientRatio < minimalTotientRatio) {
            minimalTotientRatio = totientRatio;
            minimalTotientNumber = result;
          }
        }
      }
    }
    return minimalTotientNumber;
  },
};
