## <p align="center"> Project Euler Menu </p>

**This repository contains my solutions to the problems of Project Euler** (<a href="https://projecteuler.net/about" title="https://projecteuler.net/about">Official website</a> / <a href="https://en.wikipedia.org/wiki/Project_Euler" title="https://en.wikipedia.org/wiki/Project_Euler">Wikipedia</a>)

Each numbered folder contains **10** solutions.The solutions are ordered (ie. `1/index.js` solves problems 1-10, `2/index.js` solves problems 11-20, etc.)

All solutions can be run from the **command line** (eg. `node main 51` will execute the solution program for Problem 51)

Click on the **problem title** to go to the **code solution**

Click the **Official Link** to go to the **official problem statement** on the Project Euler website

The **answers** and **time of execution** can be found in the table below (answers are partially blurred with respect to Project Euler's etiquette)

<br/><br/>

## <p align="center"> Problems & Solutions </p>
**Problem** | **Description**| **Result** | **Time** | **Official Link**
 ------------|----------------|------------|----------|---------- 
**1.** [Multiples of 3 and 5](https://github.com/zheng214/euler/blob/master/euler/1/index.js#L2-L15) | module.exports = {<br/>*<br/>    // answer = sum of<br/> (1 + 2 + ... + 333)<br/> (1 + 2 + ... + 199);<br/> (1 + 2 + ... + 66)<br/> (333 * 334) / 2; // 3(1 + 2 + ... + 333)<br/> (199 * 200) / 2; // 5(1 + 2 + ... + 199)<br/> (66 * 67) / 2; // 15(1 + 2 + ... + 66)<br/>    return sum3 + sum5 - sum15;<br/>  },<br/><br/> <strong>Question:</strong> Find the sum of all the multiples of 3 or 5 below 1000. | 233*** | 0.211ms | [:arrow_upper_right:](https://projecteuler.net/problem=1)<br/><br/>
**2.** [Even Fibonacci numbers](https://github.com/zheng214/euler/blob/master/euler/1/index.js#L17-L31) | <br/>*<br/>    let [a, b] = [0, 1];<br/>    let result = 0;<br/>    while (a < 4000000) {<br/>      [a, b] = [b, a + b];<br/>      if (!utils.isOdd(a)) {<br/>        result += a;<br/>      }<br/>    }<br/>    return result;<br/>  },<br/><br/> <strong>Question:</strong> Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million | 461**** | 0.332ms | [:arrow_upper_right:](https://projecteuler.net/problem=2)<br/><br/>
**3.** [Largest prime factor](https://github.com/zheng214/euler/blob/master/euler/1/index.js#L33-L49) | <br/>*<br/>    let currentlyDividing = 600851475143;<br/>    let currentFactor = 2;<br/>    // for each currentFactor, we keep dividing the current number (currentlyDividing) by it until it is incapable of doing so<br/>    while (currentlyDividing > 1) {<br/>      while (currentlyDividing % currentFactor === 0) {<br/>        currentlyDividing /= currentFactor;<br/>      }<br/>      if (currentlyDividing === 1) break;<br/>      currentFactor++;<br/>    }<br/>    return currentFactor;<br/>  },<br/><br/> <strong>Question:</strong> What is the largest prime factor of the number 600851475143 | 68** | 0.538ms | [:arrow_upper_right:](https://projecteuler.net/problem=3)<br/><br/>
**4.** [Largest palindrome product](https://github.com/zheng214/euler/blob/master/euler/1/index.js#L51-L107) | <br/>*<br/> The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.<br/>    // searching 6 digits palindromes<br/>    for (let n = 999; n > 100; n--) {<br/>      const reversedNumString = n.toString().split('').reverse().join('');<br/>      const palindrome = Number(`${n.toString()}${reversedNumString}`);<br/>      if (isPalindromeValid(palindrome)) {<br/>        return palindrome;<br/>      }<br/>    }<br/><br/>    // searching 5 digits palindromes<br/>    for (let m = 99; m > 10; m--) {<br/>      for (let k = 9; k >= 0; k--) {<br/>        const reversedNumString = m.toString().split('').reverse().join('');<br/>        const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);<br/>        if (isPalindromeValid(palindrome)) {<br/>          return palindrome;<br/>        }<br/>      }<br/>    }<br/><br/>    return 'no palindromes found';<br/><br/>    // test whether a palindrome is divisible by a three digit number<br/>    function isPalindromeValid(palindrome) {<br/>      const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;<br/>      const centerQuotient = Math.sqrt(palindrome);<br/>      if (Number.isInteger(centerQuotient)) {<br/>        return true;<br/>      }<br/>      // determine the search direction based on whether the square root is closer to 100 or 999<br/>      let searchDirection;<br/>      if (centerQuotient < 550) {<br/>        searchDirection = 'down';<br/>      } else {<br/>        searchDirection = 'up';<br/>      }<br/><br/>      let currentDivisor = searchDirection === 'up' ? Math.ceil(centerQuotient) : Math.floor(centerQuotient);<br/>      do {<br/>        if (isValidDivisor(palindrome / currentDivisor)) {<br/>          return true;<br/>        }<br/>        if (searchDirection === 'up') {<br/>          currentDivisor++;<br/>        } else {<br/>          currentDivisor--;<br/>        }<br/>      } while (isValidDivisor(currentDivisor));<br/>      return false;<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> Find the largest palindrome made from the product of two 3-digit numbers. | 906*** | 0.962ms | [:arrow_upper_right:](https://projecteuler.net/problem=4)<br/><br/>
**5.** [Smallest multiple](https://github.com/zheng214/euler/blob/master/euler/1/index.js#L109-L136) | <br/>*<br/> 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.<br/>    const totalPrimeFactors = [];<br/>    // for each n, we:<br/>    // (1) compute its prime factorization (see function below)<br/>    // (2) "merge" that factorization into totalPrimeFactors by checking if the computed power is higher than the power already in the array<br/>    // (3) after all merging is done, the totalPrimeFactors will contain the prime factorization of our answer<br/>    for (let n = 2; n <= 20; n++) {<br/>      const primeFactors = utils.listPrimeFactors(n); // (1)<br/>      // we start at 2 since the first two elements are always empty<br/>      for (let factor = 2; factor < primeFactors.length; factor++) {<br/>        const computedPower = primeFactors[factor];<br/>        const existingPower = totalPrimeFactors[factor];<br/>        if (computedPower && (!existingPower \|\| computedPower > existingPower)) { // (2)<br/>          totalPrimeFactors[factor] = primeFactors[factor];<br/>        }<br/>      }<br/>    }<br/><br/>    return totalPrimeFactors.reduce((acc, power, base) => { // (3)<br/>      // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization<br/> (base ** power) : acc;<br/>    }, 1);<br/>  },<br/><br/> <strong>Question:</strong> What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20? | 2327***** | 0.462ms | [:arrow_upper_right:](https://projecteuler.net/problem=5)<br/><br/>
**6.** [Sum square difference](https://github.com/zheng214/euler/blob/master/euler/1/index.js#L138-L154) | <br/>*<br/>    let difference = 0;<br/>    for (let i = 0; i <= 100; i++) {<br/>      // let s_i = 1 + 2 + ... + i-1 + i<br/>      // let S_i = 1^2 + 2^2 + ... + (i-1)^2 + i^2<br/>      // let d_i = s_i^2 - S_i = (s_(i-1) + i)^2 - S_i<br/>s_(i-1) + i^2 - S_(i-1) - i^2<br/>s_(i-1) + i^2 - i^2<br/> i(i-1)/2 = d_(i-1) + i^2(i-1)<br/>* 2) * (i - 1);<br/>    }<br/>    return difference;<br/>  },<br/><br/> <strong>Question:</strong> Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum. | 2516**** | 0.234ms | [:arrow_upper_right:](https://projecteuler.net/problem=6)<br/><br/>
**7.** [10001st prime](https://github.com/zheng214/euler/blob/master/euler/1/index.js#L156-L170) | <br/>*<br/>    let number = 1;<br/>    let nthPrime = 0;<br/>    while (nthPrime < 10001) {<br/>      number++;<br/>      if (utils.isPrime(number)) {<br/>        nthPrime++;<br/>      }<br/>    }<br/>    return number;<br/>  },<br/><br/> <strong>Question:</strong> What is the 10001st prime number? | 104*** | 14.614ms | [:arrow_upper_right:](https://projecteuler.net/problem=7)<br/><br/>
**8.** [Largest product in a series](https://github.com/zheng214/euler/blob/master/euler/1/index.js#L172-L203) | <br/>*<br/>    const data8 = require('./p8_data');<br/>    const formattedNumber = data8.replace(/\r\|\n\|\s/g, '');<br/>    // if 12 digits are wrapped between two 0s, we can trim it<br/>    const slimNumber = formattedNumber.replace(/0\d{0,12}0/g, '0');<br/>    // initial product<br/> Number(curr), 1);<br/>    // initial digit<br/>    let previousDigit = 7;<br/>    let newProduct;<br/>    for (let i = 1; i < slimNumber.length - 13; i++) {<br/>      // if our substring contains an 0, we can skip it<br/>      if (!slimNumber.substr(i, 13).includes('0')) {<br/>        // since each iteration have 12 digits in common with the previous iteration<br/>        // we use our previously computed product, divide the digit that came before it, and multiply the digit that comes after<br/>        if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0<br/> Number(curr), 1);<br/>        } else {<br/> Number(slimNumber[i + 12]);<br/>        }<br/>        previousDigit = Number(slimNumber[i]);<br/>        if (newProduct > largestProduct) {<br/>          largestProduct = newProduct;<br/>        }<br/>      }<br/>    }<br/>    return largestProduct;<br/>  },<br/><br/> <strong>Question:</strong> Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. | 23514****** | 1.821ms | [:arrow_upper_right:](https://projecteuler.net/problem=8)<br/><br/>
**9.** [Special Pythagorean triplet](https://github.com/zheng214/euler/blob/master/euler/1/index.js#L205-L223) | <br/>*<br/>    // given m > n > 0<br/>    // we can generate: a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)<br/>    // a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500;<br/>    let m = Math.floor(Math.sqrt(500));<br/>    while (m > 1) {<br/>      const quotient = 500 / m;<br/>      const n = quotient - m;<br/>      if (Number.isInteger(n) && Number.isInteger(m) && m > n) {<br/>* 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c<br/>      }<br/>      m--;<br/>    }<br/>    return 0;<br/>  },<br/><br/> <strong>Question:</strong> There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc. | 3187**** | 0.547ms | [:arrow_upper_right:](https://projecteuler.net/problem=9)<br/><br/>
**10.** [Summation of primes](https://github.com/zheng214/euler/blob/master/euler/1/index.js#L225-L265) | <br/>*<br/>    // we use the Sieve of Eratosthenes to generate all primes below two million<br/>    // for this purpose we create an array where the indexes represent integers, and the values represent whether the index is prime or not<br/>    // however, to optimize speed, we only sieve by odd multiples, ie. the even numbers are assumed to be non-prime<br/><br/>    // the resulting sieveArr will contain a list of flags indicating whether the odd number corresponding to that index is prime or not<br/>    // e.g. sieveArr[3] = true -> meaning that the 3rd odd number (excluding 1, so 7) is prime<br/>    // e.g. sieveArr[4] = false -> 9 is not prime<br/>    const sieveArr = [];<br/>    // we can stop at root because all the composite numbers above it must have been crossed out<br/>    // this is because all composite numbers above root must have a factor smaller than root<br/>    // because if a composite number have only factors above root, then that composite number must be > 2 million<br/>    const root = Math.sqrt(2000000);<br/>    for (let i = 1; i < root; i++) {<br/>      if (sieveArr[i] !== false) { // if index is not already sieved<br/>        sieveArr[i] = true; // then it must be prime<br/>        // since the indexes represent the odd numbers, we only need to sieve up to a multiple(j) such that:<br/> j < 2000000 => (2*i+1)*j < 2000000 => i * j < 2000000/(2*i+1)<br/> i + 1);<br/>        // sieve all odd multiples of i<br/>        // e.g. let i = 3 -> we must sieve 9, 15, 21, ...<br/>        // therefore we sieve their corresponding indexes -> 4, 7, 10, ...<br/>        for (let j = 3; j <= sieveTo; j += 2) {<br/> i + 1) * j - 1) / 2] = false;<br/>        }<br/>      }<br/>    }<br/>    let sum = 0;<br/>    // after the array is ready, we loop over it adding all flags which are true, keeping in mind that the p is the pth odd integer<br/>    for (let p = 1; p < sieveArr.length; p++) {<br/>      if (sieveArr[p] !== false) {<br/> p + 1);<br/>      }<br/>    }<br/>    // add 2 because 2 is the only even prime!<br/>    return sum + 2;<br/>  },<br/><br/>  <strong>Question:</strong> Find the sum of all the primes below two million. | 142913****** | 27.608ms | [:arrow_upper_right:](https://projecteuler.net/problem=10)<br/><br/>
**11.** [Largest product in a grid](https://github.com/zheng214/euler/blob/master/euler/2/index.js#L2-L30) | module.exports = {<br/>*<br/>    const data11 = require('./p11_data');<br/>    const grid = data11.split(/\n/).map(row => row.trim().split(' '));<br/>    let highestScore = 0;<br/>    for (let row = 0; row < 20; row++) {<br/>      for (let column = 0; column < 20; column++) {<br/>        const horizontalScore = computeProduct(grid[row].slice(column, column + 4));<br/>        const verticalScore = computeProduct(grid.slice(row, row + 4).map(x => x[column]));<br/>        const upDiagScore = computeProduct(grid.slice(row - 3, row + 1).map((x, index) => x[column + 4 - index]));<br/>        const downDiagScore = computeProduct(grid.slice(row, row + 4).map((x, index) => x[column + index]));<br/><br/>        const highestOfCoord = Math.max(horizontalScore, verticalScore, upDiagScore, downDiagScore);<br/>        if (highestOfCoord > highestScore) highestScore = highestOfCoord;<br/>      }<br/>    }<br/><br/>    return highestScore;<br/><br/>    function computeProduct(arr) {<br/>      if (arr.length !== 4 \|\| arr.includes(undefined)) {<br/>        return 0;<br/>      }<br/> acc, 1);<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, diagonal) in the 20×20 grid? | 7060**** | 2.381ms | [:arrow_upper_right:](https://projecteuler.net/problem=11)<br/><br/>
**12.** [Highly divisible triangular number](https://github.com/zheng214/euler/blob/master/euler/2/index.js#L32-L84) | <br/>*<br/> 28 is the 5th triangle number, and it has 6 divisors (1, 2, 4, 7, 14, 28)<br/>    // given triangle number t generated by n(n+1)/2<br/>    // we can compute the number of divisors of t (D(t)) by:<br/> D(n+1) if n is even OR<br/> D((n+1)/2) if n + 1 is even<br/>    // Note: we can reuse D(n+1) (or D((n+1)/2)) at the next iteration of n<br/><br/>    let totalDivisorsCount = 0;<br/>    let n = 2;<br/>    let nEven = true;<br/>    let lastComputedDivisorsCount = 1; // D(1) = 1<br/><br/>    while (totalDivisorsCount <= 500) {<br/> (n + 1) / 2;<br/>      let nextComputedDivisorsCount = 0;<br/>      if (nEven) {<br/>        nextComputedDivisorsCount = computeDivisorsCount(n + 1);<br/>      } else {<br/>        nextComputedDivisorsCount = computeDivisorsCount((n + 1) / 2);<br/>      }<br/> nextComputedDivisorsCount;<br/>      if (totalDivisorsCount > 500) {<br/>        return triangle;<br/>      }<br/>      lastComputedDivisorsCount = nextComputedDivisorsCount;<br/>      nEven = !nEven;<br/>      n++;<br/>    }<br/><br/>    // check all integers up to sqrt(number)<br/>    // we increment the count by 2 for each divisor found, as each divisor has a complementary divisor (except for the square root)<br/>    function computeDivisorsCount(number) {<br/>      const root = Math.sqrt(number);<br/>      let count = 0;<br/>      let divisor = Math.floor(root);<br/>      if (divisor === root) {<br/>        count++;<br/>        divisor--;<br/>      }<br/>      while (divisor > 0) {<br/>        if (!(number % divisor)) {<br/>          count += 2;<br/>        }<br/>        divisor--;<br/>      }<br/>      return count;<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> What is the value of the first triangle number to have over five hundred divisors? | 7657**** | 6.187ms | [:arrow_upper_right:](https://projecteuler.net/problem=12)<br/><br/>
**13.** [Large sum](https://github.com/zheng214/euler/blob/master/euler/2/index.js#L86-L112) | <br/>*<br/>    const data13 = require('./p13_data');<br/>    // filter out the first line which is undefined and remove whitespace (see data.js)<br/>    const numbers = data13.split(/\n/g).filter(x => x).map(x => x.trim());<br/>    let sum = 0;<br/>    for (let position = 0; position < 50; position++) {<br/>      sum += sumNthDigits(position);<br/>      const first10DigitsCurrent = sum.toString(10).substr(0, 10);<br/>      // shift the sum left to prepare for the sum of next 100 digits<br/>= 10;<br/>      // determine if the sum of the next 100 digits can affect the first 10 digits<br/>      // ie. consider all the digits at the next position are 9s<br/>      const maxValueForNextPosition = sum + 900;<br/>      const first10DigitsNext = maxValueForNextPosition.toString(10).substr(0, 10);<br/>      if (first10DigitsCurrent === first10DigitsNext) {<br/>        return +(first10DigitsCurrent);<br/>      }<br/>    }<br/><br/>    function sumNthDigits(n) {<br/>      return numbers.map(num => +(num[n])).reduce((acc, curr) => acc + curr, 0);<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> Work out the first ten digits of the sum of the following one-hundred 50-digit numbers. | 55373***** | 1.844ms | [:arrow_upper_right:](https://projecteuler.net/problem=13)<br/><br/>
**14.** [Longest Collatz sequence](https://github.com/zheng214/euler/blob/master/euler/2/index.js#L114-L170) | <br/>*<br/> The following iterative sequence is defined for the set of positive integers:<br/>  n → n/2 (n is even)<br/>  n → 3n + 1 (n is odd)<br/>  Using the rule above and starting with 13, we generate the following sequence (Collatz):<br/>  13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1<br/><br/>    // we use 2 variables to keep track of the highest chain count and the starting number associated with it<br/>    let longestChainNumber = 0;<br/>    let longestChain = 0;<br/>    // we use an array to keep track of the length of each starting number, where the index correspond to the starting number<br/>    const chainLengthArr = [];<br/> 2<br/>    for (let i = 500001; i <= 1000000; i += 1) {<br/>      computeChainLength(i, 0);<br/>    }<br/>    function computeChainLength(n, accumulatedLength) {<br/>      // as mentionned above, we do not need to consider numbers below 500001<br/>      if (n < 500001) {<br/>        return accumulatedLength;<br/>      }<br/>      if (chainLengthArr[n]) {<br/>        const totalChainLength = chainLengthArr[n] + accumulatedLength;<br/>        return totalChainLength;<br/>      }<br/>      let result;<br/>      if (utils.isOdd(n)) {<br/>        // if n is odd then 3n + 1 is even, we can skip a step by passing (3n+1)/2 as an argument<br/> n + 1) / 2, accumulatedLength + 2);<br/>      } else {<br/>        result = computeChainLength(n / 2, accumulatedLength + 1);<br/>      }<br/>      // when the result returns, we need to update the chain length number of each number in the chain<br/>      // we do so by substracting the accumulator associated with that number from the result (back propagation)<br/>      // eg: 5 -> 16 -> 8 -> 4 -> 2 -> 1<br/>      // stack trace:<br/>      // computeChainLength(5, 0) -> result - 0 = 5<br/>      // computeChainLength(16, 1) -> result - 1 = 4<br/>      // computeChainLength(8, 2) -> result - 2 = 3<br/>      // computeChainLength(4, 3) -> result - 3 = 2<br/>      // computeChainLength(2, 4) -> result - 4 = 1<br/>      // computeChainLength(1, 5) -> result - 5 = 0<br/>      // result = 5<br/>      // the memoized array will then be updated will the correct values (5 with 5, 16 with 4, etc.)<br/>      chainLengthArr[n] = result - accumulatedLength;<br/>      if (chainLengthArr[n] > longestChain) {<br/>        longestChain = chainLengthArr[n];<br/>        longestChainNumber = n;<br/>      }<br/>      return result;<br/>    }<br/>    return longestChainNumber;<br/>  },<br/><br/> <strong>Question:</strong> Which starting number, under one million, produces the longest chain? | 837*** | 302.849ms | [:arrow_upper_right:](https://projecteuler.net/problem=14)<br/><br/>
**15.** [Lattice paths](https://github.com/zheng214/euler/blob/master/euler/2/index.js#L173-L186) | <br/><br/>*<br/> Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down,<br/> there are exactly 6 routes to the bottom right corner.<br/>    // this problem is equivalent to:<br/>    // given 20 characters "r" (right) and 20 characters "d" (down)<br/>    // how many ways are there to write a string using exactly those 40 characters<br/>    // the answer is just 40 choose 20<br/>    // as it is equivalent of choosing the locations of the 20 "r" inside our string<br/> utils.fact(20));<br/>  },<br/><br/> <strong>Question:</strong> How many such routes are there through a 20×20 grid? | 137846****** | 0.260ms | [:arrow_upper_right:](https://projecteuler.net/problem=15)<br/><br/>
**16.** [Power digit sum](https://github.com/zheng214/euler/blob/master/euler/2/index.js#L188-L234) | <br/>*<br/> 2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.<br/>    // we iteratively multiply our result by 2 and we:<br/>    // 1. store each digit inside an array (the array is "reversed": 1024 is stored as [4,2,0,1])<br/>    // 2. increment the total sum of digits by the correct amount<br/>    let resultArr = [2];<br/>    let sumOfDigits = 2;<br/>    for (let exponent = 2; exponent <= 1000; exponent++) {<br/>      let carry = false;<br/>      // iterate over each digit inside the array and multiply each digit by 2, if digit > 5, we set carry to true<br/>      resultArr = resultArr.reduce(<br/>        (acc, digit, index) => {<br/>          if (digit >= 5) {<br/> 2 = 12 -> 2, the 1 will be carried over)<br/> digit - 10;<br/>            // we compute the update rule for sumOfDigits by:<br/>            // net amount = (digit at current iteration) - (digit at previous iteration) + 1(carry)<br/> digit - 10) - digit + 1<br/>            // = digit - 9<br/>            sumOfDigits += (digit - 9);<br/>          } else {<br/>            // if digit < 5, it is much simpler, just multiply the digit by 2<br/> digit;<br/>            // net amount = (digit at current iteration) - (digit at previous iteration)<br/> digit) - digit<br/>            // = digit<br/>            sumOfDigits += digit;<br/>          }<br/>          // increment current digit by 1 if carry is true<br/>          if (carry) acc[index]++;<br/>          // set carry for next iteration<br/>          carry = (digit > 4);<br/>          return acc;<br/>        },<br/>        resultArr,<br/>      );<br/>      // if we exited the reduce with a carry left over, need to add(append) 1 to the array<br/>      if (carry) {<br/>        resultArr.push(1);<br/>      }<br/>    }<br/>    return sumOfDigits;<br/>  },<br/><br/> <strong>Question:</strong> What is the sum of the digits of the number 2^1000? | 13** | 3.958ms | [:arrow_upper_right:](https://projecteuler.net/problem=16)<br/><br/>
**17.** [Number letter counts](https://github.com/zheng214/euler/blob/master/euler/2/index.js#L236-L264) | <br/>*<br/> If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters<br/> used in total.<br/>    const oneToNine = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];<br/>    const elevenToNineteen = ['eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen'];<br/>    const twentyToNinetyBy10 = ['twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety'];<br/><br/>    // to get count of 1 - 99, we sum the following components:<br/> 9 -> [<1-9>, 2<1-9>, 3<1-9>, ..., 9<1-9>]<br/>    // 2. <11-19><br/> 10 -> [<2-9>0, <0-9>1, <2-9>2. ..., <2-9>9]<br/>    // 4. <10><br/> 9 + countLetters(elevenToNineteen) + countLetters(twentyToNinetyBy10) * 10 + 3;<br/> 10 + oneToNine.reduce((acc, x) => {<br/> 99 + "<x> hundred"<br/> 99 + (x.length + 7);<br/>    }, 0);<br/><br/>    // <1000><br/>    return oneTo999 + 11;<br/><br/>    function countLetters(arr) {<br/>      return arr.join('').length;<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used? | 21*** | 0.526ms | [:arrow_upper_right:](https://projecteuler.net/problem=17)<br/><br/>
**18.** [Maximum path sum I](https://github.com/zheng214/euler/blob/master/euler/2/index.js#L266-L329) | <br/>*<br/> By starting at the top of the triangle below and moving to adjacent numbers on the row below,<br/> the maximum total from top to bottom is 23.<br/><br/>    3<br/>   7 4<br/>  2 4 6<br/> 8 5 9 3<br/><br/> That is, 3 + 7 + 4 + 9 = 23.<br/><br/>    const data18 = require('./p18_data');<br/>    // parse the triangle into a 2D array<br/>    // 1. transform it into an array where each element is a row eg. ['75', '95 64', ...]<br/>    const formattedRows = data18.split('\n').map(x => x.trimStart());<br/>    // 2. transform each row into an array of numbers eg. [[75], [95, 64], ...]<br/>    const dataArray = formattedRows.map(<br/>      x => x.split(' ').map( // split the string by space<br/>        y => +(y), // for each element splitted, transform it into a Number<br/>      ),<br/>    ).slice(1); // remove the first element (there is a newline character at the start of the string in data.js)<br/><br/>    // we iterate through each row, and for each number in each row, we keep track of the maximum total from the top to that number<br/><br/>    // keeps track of the maximum score from the top to each number in the previous/current row<br/>    let scoresOfPreviousRow = [];<br/>    // keeps track of the path from the top to each number corresponding to the scores computed above (not required for the problem)<br/>    let optimalpathsToPreviousRow = [];<br/><br/>    dataArray.forEach((row, rowIndex) => {<br/>      const tempScores = [];<br/>      const tempPaths = [];<br/>      row.forEach((number, position) => {<br/>        const isFirst = position === 0;<br/>        const isLast = position === row.length - 1;<br/>        if (rowIndex === 0) {<br/>          tempScores[0] = number;<br/>          tempPaths[0] = '0';<br/>        } else if (isFirst) {<br/>          tempScores[0] = scoresOfPreviousRow[0] + number;<br/>          tempPaths[0] = `${optimalpathsToPreviousRow[0]}0`;<br/>        } else if (isLast) {<br/>          tempScores[position] = scoresOfPreviousRow[position - 1] + number;<br/>          tempPaths[position] = `${optimalpathsToPreviousRow[position - 1]}${position}`;<br/>        // is middle<br/>        // right parent is bigger<br/>        } else if (scoresOfPreviousRow[position] > scoresOfPreviousRow[position - 1]) {<br/>          tempScores[position] = scoresOfPreviousRow[position] + number;<br/>          tempPaths[position] = `${optimalpathsToPreviousRow[position]}${position}`;<br/>        // left parent is bigger<br/>        } else {<br/>          tempScores[position] = scoresOfPreviousRow[position - 1] + number;<br/>          tempPaths[position] = `${optimalpathsToPreviousRow[position - 1]}${position}`;<br/>        }<br/>      });<br/>      scoresOfPreviousRow = tempScores;<br/>      optimalpathsToPreviousRow = tempPaths;<br/>    });<br/>    return Math.max(...scoresOfPreviousRow);<br/>  },<br/><br/> <strong>Question:</strong> Find the maximum total from top to bottom of the triangle below: | 10** | 1.468ms | [:arrow_upper_right:](https://projecteuler.net/problem=18)<br/><br/>
**19.** [Counting Sundays](https://github.com/zheng214/euler/blob/master/euler/2/index.js#L331-L363) | <br/>*<br/> 1 Jan 1900 was a Monday.<br/> A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.<br/>    // we just loop through each month of each year, and calculate that day's distance to 1 Jan 1900<br/>    // from that distance we can tell if the day is a sunday or not<br/>    let currentDistance = 365; // 1 jan 1901 - 1 jan 1900<br/>    let sundays = 0;<br/>    const oddMonths = [1, 3, 5, 7, 8, 10, 12]; // 31 days<br/>    const evenMonths = [4, 6, 9, 11]; // 30 days<br/>    for (let year = 1901; year <= 2000; year++) {<br/>      const isLeapYear = (year % 4 === 0);<br/>      for (let month = 1; month <= 12; month++) {<br/>        if (currentDistance % 7 === 6) {<br/>          sundays++;<br/>        }<br/><br/>        if (oddMonths.includes(month)) {<br/>          currentDistance += 31;<br/>        } else if (evenMonths.includes(month)) {<br/>          currentDistance += 30;<br/>        } else if (isLeapYear) {<br/>          currentDistance += 29;<br/>        } else {<br/>          currentDistance += 28;<br/>        }<br/>      }<br/>    }<br/>    return sundays;<br/>  },<br/><br/> <strong>Question:</strong> How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)? | 1** | 0.335ms | [:arrow_upper_right:](https://projecteuler.net/problem=19)<br/><br/>
**20.** [Factorial digit sum](https://github.com/zheng214/euler/blob/master/euler/2/index.js#L365-L399) | <br/>*<br/>    // we use the same procedure as in problem 16<br/>    // ie. manually multiply each digit<br/>    let resultArr = [1];<br/>    for (let i = 1; i < 101; i++) {<br/>      const multiplier = i % 10 === 0 ? i / 10 : i; // multiplying by 90 has the same effect as multiplying by 9<br/> multiplier);<br/>      resultArr = consolidate(productArr);<br/>    }<br/><br/>    return utils.sumArray(resultArr);<br/><br/>    // "flatten" an array of products<br/> 25 => [5, 2] * 25 => [125, 50](input) => [5, 2 + 0, 1 + 5] => [5, 2, 6](output) => 625<br/>    function consolidate(productArr) {<br/>      let output = productArr.reduce(<br/>        (acc, product, index) => {<br/>          const productDigits = product.toString().split('').reverse().map(x => +(x)); // 125 => [5, 2, 1]<br/>          productDigits.forEach((digit, i) => {<br/>            acc[index + i] = acc[index + i] ? acc[index + i] + digit : digit;<br/>          });<br/>          return acc;<br/>        },<br/>        [],<br/>      );<br/>      if (output.find(x => x >= 10)) {<br/>        output = consolidate(output);<br/>      }<br/>      return output;<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> Find the sum of the digits in the number 100! | 6** | 10.679ms | [:arrow_upper_right:](https://projecteuler.net/problem=20)<br/><br/>
**21.** [Amicable numbers](https://github.com/zheng214/euler/blob/master/euler/3/index.js#L2-L30) | module.exports = {<br/>*<br/> If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair and each of a and b are called amicable numbers.<br/> Evaluate the sum of all the amicable numbers under 10000.<br/> The proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284<br/> The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.<br/>    const primesUnder10000 = utils.generatePrimeTable(10000);<br/>    const amicableNumbers = [];<br/>    for (let i = 0; i < 10000; i++) {<br/>      if (!primesUnder10000[i] && !amicableNumbers.includes(i)) {<br/>        // d(i)<br/>        const sumOfDivisors = utils.computeSumOfDivisors(i);<br/>        // ensure i is not a perfect number (d(i) = i) which does not qualify as an amicable number by definition<br/>        if (sumOfDivisors !== i) {<br/>          // now check if d(d(i)) === i<br/>          const sumOfDivisors2 = utils.computeSumOfDivisors(sumOfDivisors);<br/>          if (sumOfDivisors2 === i) {<br/>            amicableNumbers.push(i);<br/>            amicableNumbers.push(sumOfDivisors);<br/>          }<br/>        }<br/>      }<br/>    }<br/><br/>    return utils.sumArray(amicableNumbers);<br/>  },<br/><br/> <strong>Question:</strong> Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n). | 31*** | 9.767ms | [:arrow_upper_right:](https://projecteuler.net/problem=21)<br/><br/>
**22.** [Names scores](https://github.com/zheng214/euler/blob/master/euler/3/index.js#L32-L59) | <br/>*<br/><br/> Using [p22_names.txt](https://github.com/zheng214/euler/blob/master/euler/3/p22_names.txt), a 46K text file containing over five-thousand first names<br/> begin by sorting it into alphabetical order. Then working out the alphabetical value for each name,multiply this value by its<br/> alphabetical position in the list to obtain a name score.<br/><br/><br/> when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53,<br/> is the 938th name in the list. So, COLIN would obtain a score of 938 × 53 = 49714.<br/>    const stringNames = fs.readFileSync(path.join(__dirname, 'p22_names.txt')).toString();<br/>    const arrayNames = stringNames.split(',');<br/>    const sortedNames = arrayNames.sort();<br/>    return sortedNames.reduce(<br/>      (totalScore, name, index) => {<br/>        const i = index + 1;<br/> utils.sumArray(<br/>          name.split(''), // 'AARON' => ['A', 'A', 'R', 'O', 'N']<br/>          n => n.charCodeAt() - 64, // a -> 1, r -> 18, etc.<br/>        );<br/>        return totalScore + scoreOfName;<br/>      },<br/>      0,<br/>    );<br/>  },<br/><br/> <strong>Question:</strong> What is the total of all the name scores in the file? | 8711***** | 9.942ms | [:arrow_upper_right:](https://projecteuler.net/problem=22)<br/><br/>
**23.** [Non-abundant sums](https://github.com/zheng214/euler/blob/master/euler/3/index.js#L61-L98) | <br/>*<br/> By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers.<br/> However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be<br/> expressed as the sum of two abundant numbers is less than this limit.<br/><br/> Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.<br/><br/> As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two<br/> abundant numbers is 24.<br/>    const abundantNumbers = {};<br/>    let result = 0;<br/>    for (let i = 1; i <= 28123; i++) {<br/>      if (utils.computeSumOfDivisors(i) > i) {<br/>        abundantNumbers[i] = true;<br/>      }<br/>      // check if number can be written as sum of two abundant numbers<br/>      let canBeSummed = false;<br/>      const abundantNumbersArray = Object.keys(abundantNumbers);<br/>      for (let j = 0; j < abundantNumbersArray.length; j++) {<br/>        if (abundantNumbersArray[j] > i / 2) {<br/>          break; // we don't need to check for numbers above i / 2<br/>        }<br/>        if (abundantNumbers[i - abundantNumbersArray[j]]) {<br/>          canBeSummed = true;<br/>          break;<br/>        }<br/>      }<br/>      if (!canBeSummed) {<br/>        result += i;<br/>      }<br/>    }<br/><br/>    return result;<br/>  },<br/><br/> <strong>Question:</strong> A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n. | 417**** | 2748.125ms | [:arrow_upper_right:](https://projecteuler.net/problem=23)<br/><br/>
**24.** [Lexicographic permutations](https://github.com/zheng214/euler/blob/master/euler/3/index.js#L100-L147) | <br/>*<br/> A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4.<br/> If all of the permutations are listed numerically or alphabetically, we call it lexicographic order.<br/> The lexicographic permutations of 0, 1 and 2 are:<br/> 012   021   102   120   201   210<br/><br/>    // we convert 1000000 into its factorial number system representation<br/>    // eg.<br/>    // decimal -> factorial<br/>    // 0 -> 00(fact)<br/> 1! -> 01 (fact)<br/> 2! + 0 * 1! -> 10(fact)<br/> 2! + 1 * 1! -> 11(fact)<br/> 2! -> 20(fact)<br/> 2! + 1 * 1! -> 21(fact)<br/>    //<br/>    // then we iteratively write our permuation, with the following rule:<br/>    // each digit in the factorial representation decides the index from which we grab our next digit from the remaining digits<br/>    //<br/>    // for example, if we want the 5th permutation of 0123456789<br/>    // we get the factorial representation of 4, since we start at 0<br/>    // we obtain 000000020(fact)<br/>    // the first 7 digits are fixed (ie. 0123456)<br/>    // then we grab the second(2) index from the remaining digits 789[2] = 9<br/>    // now the permutation is at 01234569<br/>    // then we grab the 0th(0) index from the remaining digits 78[0] = 7<br/>    // the permutation becomes 012345697<br/>    // there is only the digit 8 left, we append it: 0123456978<br/>    // so the 5th permutation of 0123456789 is 0123456978<br/><br/>    const ONE_MILLION = 1000000;<br/>    const factorialRepr = utils.convertToFactorialBase(ONE_MILLION - 1);<br/>    let remainingDigits = '0123456789';<br/>    let result = '';<br/><br/>    for (let k = 0; k < factorialRepr.length; k++) {<br/>      const indexToGrab = factorialRepr.charAt(k);<br/>      result += remainingDigits[indexToGrab];<br/>      remainingDigits = remainingDigits.replace(`${remainingDigits[indexToGrab]}`, '');<br/>    }<br/><br/>    // add last digit remaining<br/>    return +(result + remainingDigits);<br/>  },<br/><br/> <strong>Question:</strong> What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9? | 27839***** | 0.563ms | [:arrow_upper_right:](https://projecteuler.net/problem=24)<br/><br/>
**25.** [1000-digit Fibonacci number](https://github.com/zheng214/euler/blob/master/euler/3/index.js#L149-L191) | <br/>*<br/> F1 = 1<br/> F2 = 1<br/> F3 = 2<br/> F4 = 3<br/>    let [a, b] = [[1], [1]];<br/>    let index = 2;<br/>    while (b.length < 1000) {<br/>      index++;<br/>      [a, b] = [b, manualSum(a, b)];<br/>    }<br/><br/>    return index;<br/><br/>    // since javascript numbers only handles up to ~ 1.7976931348623157e+308<br/>    // we have to add each digit manually and store them inside an array<br/>    // e.g. [2, 4] + [3, 8] => [6, 2]<br/>    // e.g. [1, 4, 5] + [8, 5, 5] => [1, 0, 0, 0]<br/>    function manualSum(arr1, arr2) {<br/>      const a1 = arr1.length >= arr2.length ? [...arr1].reverse() : [...arr2].reverse(); // longer array<br/>      const a2 = arr1.length >= arr2.length ? [...arr2].reverse() : [...arr1].reverse(); // shorter array<br/>      const result = [];<br/>      let carry = 0;<br/>      for (let i = 0; i < a1.length; i++) {<br/>        const partialResult = a1[i] + (a2[i] \|\| 0) + carry;<br/>        if (partialResult >= 10) {<br/>          carry = 1;<br/>          result[i] = partialResult - 10;<br/>        } else {<br/>          carry = 0;<br/>          result[i] = partialResult;<br/>        }<br/>      }<br/>      if (carry) {<br/>        result.push(1);<br/>      }<br/>      return result.reverse();<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> What is the index of the first term in the Fibonacci sequence to contain 1000 digits? | 47** | 48.369ms | [:arrow_upper_right:](https://projecteuler.net/problem=25)<br/><br/>
**26.** [Reciprocal cycles](https://github.com/zheng214/euler/blob/master/euler/3/index.js#L193-L235) | <br/>*<br/> The decimal representation of the unit fractions with denominators 2 to 10 are given:<br/> 1/2 = 0.5<br/> 1/3 = 0.(3)<br/> 1/4 = 0.25<br/> 1/5 = 0.2<br/> 1/6 = 0.1(6)<br/> 1/7 = 0.(142857)<br/> 1/8 = 0.125<br/> 1/9 = 0.(1)<br/> 1/10 = 0.1<br/> Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.<br/><br/>    let longestRecurringCycle = 0;<br/>    let longestRecurringCycleValue = 0;<br/>    for (let i = 1; i < 1000; i++) {<br/>      // we can skip numbers that are divisible by 2, 3 or 5, as they are either terminating (2, 5) or have only 1 repeating digit (3)<br/>      if (i % 2 && i % 3 && i % 5) {<br/>        // we manually divide 1/i, and keep track of the remainders, if a remainder is in the list of seen remainders,<br/>        // then the length of the seen remainders is the length recurrent cycle<br/>        // the length of the recurrent cycle cannot be greater or equal than i, as the number of unique remainders obtained by<br/>        // dividing by i are between (0 and i - 1)<br/>        const remainders = [];<br/>        let remainder = 1;<br/>        for (let j = 1; j <= i; j++) {<br/> 10) % i;<br/>          if (remainders.includes(remainder)) {<br/>            if (remainders.length > longestRecurringCycle) {<br/>              longestRecurringCycle = remainders.length;<br/>              longestRecurringCycleValue = i;<br/>            }<br/>            break;<br/>          }<br/>          remainders.push(remainder);<br/>        }<br/>      }<br/>    }<br/>    return longestRecurringCycleValue;<br/>  },<br/><br/> <strong>Question:</strong> Find the value of d < 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part. | 9** | 14.776ms | [:arrow_upper_right:](https://projecteuler.net/problem=26)<br/><br/>
**27.** [Quadratic primes](https://github.com/zheng214/euler/blob/master/euler/3/index.js#L238-L287) | <br/><br/>*<br/> Euler discovered the remarkable quadratic formula:<br/> n^2+n+41<br/> It turns out that the formula will produce 40 primes for the consecutive integer values 0≤n≤39.<br/> However, when n=40,402+40+41=40(40+1)+41 is divisible by 41, and certainly when n=41,412+41+41 is clearly divisible by 41.<br/><br/> The incredible formula n2−79n+1601 was discovered, which produces 80 primes for the consecutive values 0≤n≤79.<br/> The product of the coefficients, −79 and 1601, is −126479.<br/><br/> Considering quadratics of the form:<br/><br/> n^2+an+b, where \|a\|<1000 and \|b\|≤1000<br/><br/> primes for consecutive values of n, starting with n=0.<br/>    // let Q be a prime generating quadratic polynomial<br/>    // for Q to be valid, b must be a prime number (as Q(0) = b)<br/>    const primesArray = Object.keys(utils.generatePrimeTable(1000)).map(x => +(x));<br/>    let longestConsecutivePrimes = 40;<br/>    let productOfLongest = 0;<br/>    for (let i = 0; i < primesArray.length; i++) {<br/>      // since each prime generated must be >= 2, we can constrain the values of a<br/>      // ie. when n = 1<br/>      // Q(1) > 1<br/>      // 1 + a + b > 1<br/>      // a > -b<br/>      const b = primesArray[i];<br/>      for (let a = -b + 1; a < 2; a++) {<br/>        const consecutivePrimesLength = computeConsecutivePrimesLength(a, b);<br/>        if (consecutivePrimesLength > longestConsecutivePrimes) {<br/>          longestConsecutivePrimes = consecutivePrimesLength;<br/> b;<br/>        }<br/>      }<br/>    }<br/>    return productOfLongest;<br/><br/>    function computeConsecutivePrimesLength(a, b) {<br/>      let n = 1;<br/>      let Q = 1 + a + b;<br/>      while (utils.isPrime(Q)) {<br/>        n++;<br/>* 2) + a * n + b;<br/>      }<br/>      return n;<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of | -59*** | 6.174ms | [:arrow_upper_right:](https://projecteuler.net/problem=27)<br/><br/>
**28.** [Number spiral diagonals](https://github.com/zheng214/euler/blob/master/euler/3/index.js#L289-L315) | <br/>*<br/> Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:<br/><br/> [21]  22   23   24  [25]<br/>  20  [07]  08  [09]  10<br/>  19   06  [01]  02   11<br/>  18  [05]  4   [03]  12<br/> [17]  16   15   14  [13]<br/><br/> It can be verified that the sum of the numbers on the diagonals (enclosed by [brackets]) is 101.<br/><br/>    // by convenience we will say that [01] is on the 0th square<br/> n<br/>    // we can also observe that the last encountered diagonal number (top-left corner) is (2n-1)^2<br/>    // then the sum of diagonals of the nth square is (2n-1)^2 + 2n + (2n-1)^2 + 4n + (2n-1)^2 + 6n + (2n-1)^2 + 8n<br/>    // = 4(2n-1)^2 + 20n = 16n^2 + 4n + 4<br/>    // if we have a 1001 by 1001 square then the result is sum of diagonals of 500 squares + 1<br/>    let sum = 1;<br/>    for (let i = 1; i <= 500; i++) {<br/> (i ** 2) + (4 * i) + 4);<br/>    }<br/>    return sum;<br/>  },<br/><br/> <strong>Question:</strong> What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way? | 6691***** | 0.302ms | [:arrow_upper_right:](https://projecteuler.net/problem=28)<br/><br/>
**29.** [Distinct powers](https://github.com/zheng214/euler/blob/master/euler/3/index.js#L317-L352) | <br/>*<br/> Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:<br/> If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:<br/> 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125<br/><br/><br/>    // we just need to find the number of collisions (ie. 2^4 = 4^2), and substract that from 99^2<br/>    // collisions only occur for a <= 10, s.t. a != b^c for some b, c between 2 and 10<br/>    // ie. collisions happens only when a = 2, 3, 5, 6, 7, 10<br/>    // for 5,6,7, and 10 there are 49 collisions each, ie. even powers (5^4 collides with 25^2, ..., 5^100 collides with 25^50)<br/>    // we get 196 collisions for those 4 bases<br/>    // next we compute the collisions for powers of 2 (ie. 2, 4, 8, 16, 32, 64)<br/>    // and the collisions for powers of 3 (ie. 3, 9, 27, 81)<br/><br/> n) where 1 <= m <= 6 and 1 <= n <= 100 by only looking at the exponent part<br/> n) is also unique<br/>    const uniquePowersOf2 = new Set();<br/>    const uniquePowersOf3 = new Set();<br/>    for (let i = 2; i <= 100; i++) {<br/>      for (let m = 1; m <= 6; m++) {<br/>        // if number is already in the set, ie. we seen that equivalent power before, the following operation will do nothing<br/> m);<br/>        if (m <= 4) {<br/> m);<br/>        }<br/>      }<br/>    }<br/> 99 - uniquePowersOf2.size;<br/> 99 - uniquePowersOf3.size;<br/>    const totalCollisions = collisionsOf2 + collisionsOf3 + 196;<br/> 99 - totalCollisions;<br/>  },<br/><br/> <strong>Question:</strong> How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100? | 91** | 0.362ms | [:arrow_upper_right:](https://projecteuler.net/problem=29)<br/><br/>
**30.** [Digit fifth powers](https://github.com/zheng214/euler/blob/master/euler/3/index.js#L354-L418) | <br/>*<br/> Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:<br/> 1634 = 1^4 + 6^4 + 3^4 + 4^4<br/> 8208 = 8^4 + 2^4 + 0^4 + 8^4<br/> 9474 = 9^4 + 4^4 + 7^4 + 4^4<br/> As 1 = 1^4 is not a sum it is not included.<br/> The sum of these numbers is 1634 + 8208 + 9474 = 19316.<br/><br/>    // let N be a number that can be written as the sum of fifth powers of their digits.<br/> 9^5 < 10^x<br/>    // N obviously cannot have 1 digit<br/>    // If N has 2 digits, then the only valid values of N are 0, 1, 2, since 3^5 > 99<br/>    // by quickly checking we can also see that N cannot have 2 digits<br/>    // so we need to verify numbers between 3 and 6 digits;<br/><br/>    const fifthPowerDigits = []; // list of N's defined above<br/><br/>    // table that stores the max allowed digit for a given number length<br/>    // e.g for numbers with 3 digits, the valid numbers that form N are 0 to 3, as 4^5 > 999<br/>    const maxAllowedDigits = {};<br/>    let needPruning = true; // if max allowed digit is 9, we don't need to go through the trouble of skipping/pruning<br/><br/>    for (let i = 100; i < 999999; i++) {<br/>      const digits = i.toString().split('');<br/>      let maxExceeded = false;<br/>      if (needPruning) {<br/>        const numberOfDigits = digits.length;<br/>        let maxAllowedDigit;<br/>        if (maxAllowedDigits[numberOfDigits]) {<br/>          // if max allowed digit is already in table, we grab it<br/>          maxAllowedDigit = maxAllowedDigits[numberOfDigits];<br/>        } else {<br/>          // otherwise, we compute the max allowed digits for a given digits length<br/>          maxAllowedDigit = 0;<br/>* 5 < 10 ** numberOfDigits) {<br/>            maxAllowedDigit++;<br/>          }<br/>          maxAllowedDigits[numberOfDigits] = maxAllowedDigit;<br/>        }<br/>        if (maxAllowedDigit === 9) {<br/>          needPruning = false;<br/>        }<br/>        // we check if a digit exceed the max, if so we check the next number<br/> 10^1, or (10 - 4) * 10 ^ (3 - 2))<br/>        digits.forEach((digit, position) => {<br/>          if (+(digit) > maxAllowedDigit) {<br/> (10 ** (numberOfDigits - position - 1)) - 2;<br/>            maxExceeded = true;<br/>          }<br/>        });<br/>      }<br/>      if (!maxExceeded) {<br/>* 5);<br/>        if (sumOfFifthPowers === i) {<br/>          fifthPowerDigits.push(i);<br/>        }<br/>      }<br/>    }<br/><br/>    return utils.sumArray(fifthPowerDigits);<br/>  },<br/><br/> <strong>Question:</strong> Find the sum of all the numbers that can be written as the sum of fifth powers of their digits. | 443*** | 201.357ms | [:arrow_upper_right:](https://projecteuler.net/problem=30)<br/><br/>
**31.** [Coin sums](https://github.com/zheng214/euler/blob/master/euler/4/index.js#L2-L60) | module.exports = {<br/>*<br/> In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:<br/> 1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).<br/> It is possible to make £2 in the following way:<br/> 1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p<br/><br/>    const CHANGES = [1, 2, 5, 10, 20, 50, 100, 200];<br/>    // our final result<br/>    let changes = 0;<br/><br/>    // our algorithm works by traversing down a 'tree'<br/>    // we start with the top level: 200<br/>    // [tree level: 200] we create 2 branches: left (using 200) and right (not using 200)<br/>    // from each branch we find the amount of combinations of the next coin<br/>    // [tree level: 100] left branch used 200, has 0 left, return 1 (1 way to make 200 using 200p coins)<br/>    // [tree level: 100] right branch did not use 200, has 200 left, now we can either:<br/>    // [tree level: 100] use 2 100p coins, 1 100p coins, or 0 100p coins, now we create 3 branches into the next level<br/>    // the tree looks like this:<br/>    // [root]            200<br/>    //                  /   \<br/>    // [level: 200]    0    200<br/>    //                     / \| \<br/>    // [level: 100]       0 100 200<br/>    //                       \|   \<br/>    // [level: 50]          ...  ...<br/>    //<br/>    // when we reach level 2, we can stop and return Math.floor(amountLeft / 2) + 1<br/>    // which is equal to the number of ways we can make amountLeft using only 2p and 1p<br/><br/>    function makeChange(amountLeft, levelIndex = CHANGES.length - 1) {<br/>      if (amountLeft < 0) {<br/>        // dead branch<br/>        return 0;<br/>      }<br/>      if (levelIndex === 1) {<br/>        // reached leaf<br/>        return Math.floor(amountLeft / 2) + 1;<br/>      }<br/>      if (amountLeft === 1 \|\| amountLeft === 0) {<br/>        // there is only 1 way to make 1p<br/>        // also if amountLeft is 0, it means we called makeChange on amountLeft with a coin equal to it<br/>        // eg. using 200p coin to make 200p, there is only 1 way<br/>        return 1;<br/>      }<br/>      for (let i = 0; i <= Math.floor(amountLeft / CHANGES[levelIndex]); i++) {<br/>        // 'generate' branches according to amountLeft/level<br/> CHANGES[levelIndex], levelIndex - 1);<br/>        changes += changesAtLevel;<br/>      }<br/>      return 0;<br/>    }<br/><br/>    makeChange(200);<br/>    return changes;<br/>  },<br/><br/> <strong>Question:</strong> How many different ways can £2 be made using any number of coins? | 73*** | 0.773ms | [:arrow_upper_right:](https://projecteuler.net/problem=31)<br/><br/>
**32.** [Pandigital products](https://github.com/zheng214/euler/blob/master/euler/4/index.js#L62-L138) | <br/>*<br/> The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier,<br/> and product is 1 through 9 pandigital.<br/><br/> HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.<br/>    const DIGITS = [1, 2, 3, 4, 5, 6, 7, 8, 9];<br/>    const pandigitalProducts = [];<br/> b = c (for convenience, assume a < b), we know that c must have 4 digits because if<br/> b < c and if digits(c) < 4, a * b > c<br/>    // we just need to check values of c from 1234 to 9876, and find 1 < a <= 98 st. our condition is satisfied<br/>    for (let i = 1111; i <= 9876; i++) {<br/>      const selectionIndexes = i.toString().split('');<br/>      // we only check if the selection is valid<br/>      if (+(selectionIndexes[1]) < 9 && +(selectionIndexes[2]) < 8 && +(selectionIndexes[3]) < 7 && !selectionIndexes.some(x => x === '0')) {<br/>        let c = '';<br/>        let remainingDigits = [...DIGITS];<br/>        selectionIndexes.forEach(<br/>          (selectionIndex) => {<br/>            const selected = remainingDigits[selectionIndex - 1].toString();<br/>            c += selected;<br/>            remainingDigits = remainingDigits.filter(x => x !== remainingDigits[selectionIndex - 1]);<br/>          },<br/>        );<br/><br/>        c = +(c);<br/>        const root = Math.sqrt(c);<br/><br/>        // now assume that a has only 1 digit, check for pandigital equations<br/>        let a;<br/>        let isPandigital = false;<br/>        for (a = 0; a < remainingDigits.length; a++) {<br/>          const dividend = remainingDigits[a];<br/>          const b = c / dividend;<br/>          if (Number.isInteger(b)) {<br/>            if (b.toString().split('').sort().join('') === remainingDigits.filter(x => x !== dividend).join('')) {<br/>              pandigitalProducts.push(c);<br/>              isPandigital = true;<br/>              break;<br/>            }<br/>          }<br/>        }<br/>        if (!isPandigital) {<br/>          // now assume a has 2 digits, check for pandigital equations<br/>          for (let j = 11; j <= 54; j++) {<br/>            // we select 2 digits from the remaining pool of 5<br/>            const selectionIndexes2 = j.toString().split('');<br/>            if (selectionIndexes2[0] < 6 && selectionIndexes2[1] < 5 && !selectionIndexes2.some(x => x === '0')) {<br/>              let a2 = '';<br/>              let remainingDigits2 = [...remainingDigits]; // remaining digits after a second round of selection<br/>              selectionIndexes2.forEach(<br/>                (selectionIndex2) => {<br/>                  const selected = remainingDigits2[selectionIndex2 - 1].toString();<br/>                  a2 += selected;<br/>                  remainingDigits2 = remainingDigits2.filter(x => x !== remainingDigits2[selectionIndex2 - 1]);<br/>                },<br/>              );<br/>              a2 = +(a2);<br/>              if (a2 < root) {<br/>                const b = c / a2;<br/>                if (Number.isInteger(b)) {<br/>                  if (b.toString().split('').sort().join('') === remainingDigits2.join('')) {<br/>                    pandigitalProducts.push(c);<br/>                    break;<br/>                  }<br/>                }<br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>    return utils.sumArray(pandigitalProducts);<br/>  },<br/><br/> <strong>Question:</strong> Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital. | 45*** | 82.351ms | [:arrow_upper_right:](https://projecteuler.net/problem=32)<br/><br/>
**33.** [Digit cancelling fractions](https://github.com/zheng214/euler/blob/master/euler/4/index.js#L140-L184) | <br/>*<br/> The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify<br/> it may incorrectly believe that 49/98 = 4/8, which is correct, is obtained by cancelling the 9s.<br/> We shall consider fractions like, 30/50 = 3/5, to be trivial examples.<br/> There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two<br/> digits in the numerator and denominator.<br/><br/>    // we first check all fractions of the form mx/xn, where<br/>    // a. 1 <= m, n <= 9<br/>    // b. m < x <= 9<br/>    // c. m != n<br/>    const curiousFractions = [];<br/>    for (let m = 1; m <= 9; m++) {<br/>      for (let n = 1; n <= 9; n++) {<br/>        if (m !== n) {<br/>          for (let x = m; x <= 9; x++) {<br/> m) + x;<br/> 10) + n;<br/>            const fraction = numerator / denominator;<br/>            if (fraction === m / n) {<br/>              curiousFractions.push({ numerator, denominator });<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/><br/>    const productFraction = curiousFractions.reduce(<br/>      (acc, curr) => {<br/>= curr.numerator;<br/>= curr.denominator;<br/>        return acc;<br/>      },<br/>      {<br/>        numerator: 1,<br/>        denominator: 1,<br/>      },<br/>    );<br/><br/>    return utils.reduceLCT(productFraction.numerator, productFraction.denominator)[1];<br/>  },<br/><br/> <strong>Question:</strong> If the product of these four fractions is given in its lowest common terms, find the value of the denominator. | 1** | 0.506ms | [:arrow_upper_right:](https://projecteuler.net/problem=33)<br/><br/>
**34.** [Digit factorials](https://github.com/zheng214/euler/blob/master/euler/4/index.js#L186-L282) | <br/>*<br/> 145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.<br/> Note: as 1! = 1 and 2! = 2 are not sums they are not included.<br/>    const FACTORIALS = utils.generateFactTable(9);<br/>    const curiousNumbers = [];<br/><br/> 9! < 10^8<br/>    // and we can quickly manually verify that numbers with 2 digits cannot be curious<br/><br/>    // for each digit count we use a heuristic to prune some numbers<br/>    for (let d = 3; d <= 7; d++) {<br/>      // for 3-digit numbers, we notice that<br/>      // 1. the number cannot contain a digit > 6, since 6! = 720, and 7! (in 720) > 999<br/> 4! < 100<br/>      // 3. the max number following condition 1 is 555, but 5! + 5! + 5! = 360, so our number cannot have three 5's<br/>      // 4. we can quickly verify that our number cannot contain two 5's either, as none of them satisfies our condition<br/>      // therefore our number must contain exactly one 5,<br/>      // for the rest of digits below, we use the same logic applied here<br/>      if (d === 3) {<br/>        for (let i = 125; i <= 145; i++) {<br/>          if (isEligible(i, 5) && isCurious(i)) curiousNumbers.push(i);<br/>        }<br/>      }<br/><br/>      // for 4-digit numbers, we have two main options, either use one 7, or no 7<br/> 6! = 7200 maximize-> 7166 -> factSum(7166) = 6481 maximize-> 6476<br/> 4 = 2880 maximize-> 2666, since the first digit <= 2<br/> 3 = 2162<br/>      // since we need to use at least 2 6's, our lower bound becomes 1266<br/>      if (d === 4) {<br/>        for (let i = 1266; i < 2162; i++) {<br/>          if (isEligible(i, 6) && isCurious(i)) curiousNumbers.push(i);<br/>        }<br/>        for (let i = 5040; i < 6476; i++) {<br/>          if (isEligible(i, 7) && isCurious(i)) curiousNumbers.push(i);<br/>        }<br/>      }<br/><br/>      // for 5-digit numbers, the options are to use 2 8's, 1 8, or no 8<br/>      if (d === 5) {<br/>        // using two 8's<br/>        for (let i = 80640; i < 88777; i++) {<br/>          if (isEligible(i, 8) && isCurious(i)) curiousNumbers.push(i);<br/>        }<br/><br/>        // using one 8<br/>        for (let i = 40320; i < 57778; i++) {<br/>          if (isEligible(i, 8) && isCurious(i)) curiousNumbers.push(i);<br/>        }<br/><br/>        // no 8<br/>        for (let i = 10077; i < 17777; i++) {<br/>          if (isEligible(i, 7) && isCurious(i)) curiousNumbers.push(i);<br/>        }<br/>      }<br/><br/>      // for 6-digit numbers, the options are to use 2 9's, 1 9, or no 9<br/>      if (d === 6) {<br/>        // 2 9's<br/>        for (let i = 725799; i < 886998; i++) {<br/>          if (isCurious(i)) curiousNumbers.push(i);<br/>        }<br/><br/>        // 1 9<br/>        for (let i = 362889; i < 488889; i++) {<br/>          if (isCurious(i)) curiousNumbers.push(i);<br/>        }<br/><br/>        // no 9<br/>        for (let i = 100088; i < 158888; i++) {<br/>          if (isCurious(i)) curiousNumbers.push(i);<br/>        }<br/>      }<br/><br/>      // for 7 digit numbers, we must use 4 9's<br/>      if (d === 7) {<br/>        // 4 9's<br/>        for (let i = 1459999; i < 1489999; i++) {<br/>          if (isCurious(i)) curiousNumbers.push(i);<br/>        }<br/>      }<br/>    }<br/><br/>    function isCurious(n) {<br/>      return utils.sumArray(n.toString().split(''), x => FACTORIALS[x]) === n;<br/>    }<br/><br/>    function isEligible(n, d) {<br/>      return !n.toString().split('').some(x => +(x) > d);<br/>    }<br/><br/>    return utils.sumArray(curiousNumbers);<br/>  },<br/><br/> <strong>Question:</strong> Find the sum of all numbers which are equal to the sum of the factorial of their digits. | 40*** | 88.960ms | [:arrow_upper_right:](https://projecteuler.net/problem=34)<br/><br/>
**35.** [Circular primes](https://github.com/zheng214/euler/blob/master/euler/4/index.js#L284-L332) | <br/>*<br/> The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.<br/> There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.<br/><br/>    // const primeTable = utils.generatePrimeTable(1000000);<br/>    const testedNumbers = {}; // table containing numbers we have tested to avoid duplicate testing<br/>    const validDigits = [1, 3, 7, 9]; // any number containing a digit outside of this list will have a composite rotation<br/>    const primeRotations = []; // result containing all rotation primes<br/><br/>    // we check all numbers within 3 to 6 digits<br/>    for (let digits = 3; digits <= 6; digits++) {<br/>* digits;<br/>      for (let permutation = 0; permutation < permutationsCount; permutation++) {<br/>        // map permutation into an array of indexes specifying the digit to include at that index<br/>        // eg. 0 -> [0, 0, 0] -> 111, 1 -> [0, 0, 1] -> 113, 5 -> [1, 0, 1] -> 313, etc.<br/>        const permSpec = permutation.toString(4).padStart(digits, '0').split('');<br/>        const numberToTest = permSpec.map(perm => validDigits[perm]).join('');<br/>        if (!testedNumbers[numberToTest]) {<br/>          let rotationIndex = 0;<br/>          const rotations = new Set(); // we use set as rotations may be counted twice, eg. 1111<br/>          let isRotationPrime = true;<br/>          while (rotationIndex < digits) {<br/>            const left = numberToTest.slice(rotationIndex, numberToTest.length);<br/>            const right = numberToTest.slice(0, rotationIndex);<br/>            const rotatedNumber = +(`${left}${right}`);<br/>            rotations.add(rotatedNumber);<br/>            if (!utils.isPrime(rotatedNumber)) {<br/>              isRotationPrime = false;<br/>            }<br/>            testedNumbers[rotatedNumber] = true;<br/>            rotationIndex++;<br/>            if (numberToTest.split('').every(x => x === numberToTest.charAt(0))) {<br/>              // test if all digits in number are equal. If true, no need to continue rotations<br/>              break;<br/>            }<br/>          }<br/>          if (isRotationPrime) {<br/>            primeRotations.push(...Array.from(rotations));<br/>          }<br/>        }<br/>      }<br/>    }<br/><br/>    return primeRotations.length + 13; // there are 13 rotations under 13 (given)<br/>  },<br/><br/> <strong>Question:</strong> How many circular primes are there below one million? | 5* | 24.929ms | [:arrow_upper_right:](https://projecteuler.net/problem=35)<br/><br/>
**36.** [Double-base palindromes](https://github.com/zheng214/euler/blob/master/euler/4/index.js#L334-L365) | <br/>*<br/> The decimal number, 585 = 1001001001 (binary), is palindromic in both bases.<br/>    const doublePalindromes = [];<br/>    // we loop through each decimal palindrome and check whether its binary representation is also palindromic<br/>    // note that even numbers cannot be palindromic in its binary representation<br/>    for (let i = 1; i <= 999; i++) {<br/>      // we can skip the numbers whose leading digit is even<br/>      if (i.toString().charAt(0) & 1) {<br/>        // we generate a list of palindromes based on current index<br/>        // ie. i = 57 -> 5775, 57075, 57175, ..., 57975<br/>        const evenDigitPalindrome = +(`${i.toString()}${i.toString().split('').reverse().join('')}`);<br/>        let oddDigitPalindromes = [];<br/>        if (i < 100) { // we don't want to generate 7 digit palindromes<br/>          oddDigitPalindromes = [...Array(10)].map((x, idx) => +(`${i.toString()}${idx}${i.toString().split('').reverse().join('')}`));<br/>        }<br/>        const decimalPalindromes = [evenDigitPalindrome, ...oddDigitPalindromes];<br/>        decimalPalindromes.forEach((dp) => {<br/>          const bin = dp.toString(2);<br/>          if (bin === bin.split('').reverse().join('')) {<br/>            doublePalindromes.push(dp);<br/>          }<br/>        });<br/>      }<br/>    }<br/>    // we did not yet take into account the numbers under 10 (which are palindromes by default)<br/>    // 1,3,5,7,9 are all binary palindromes, their sum is 25<br/>    return utils.sumArray(doublePalindromes) + 25;<br/>  },<br/><br/> <strong>Question:</strong> Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2. | 872*** | 5.089ms | [:arrow_upper_right:](https://projecteuler.net/problem=36)<br/><br/>
**37.** [Truncatable primes](https://github.com/zheng214/euler/blob/master/euler/4/index.js#L367-L439) | <br/>*<br/> The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right,<br/> and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.<br/><br/> NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.<br/>    const truncatedPrimes = [];<br/><br/>    // we can see that the only valid digit in a truncated prime are 1,3,7,9<br/>    const validDigitsA = [1, 3, 7, 9];<br/><br/>    // 2 and 5 are valid digit for preppending, however, they are only valid as the leading digit in a number<br/>    const validDigitsP = [1, 2, 3, 5, 7, 9];<br/><br/>    // we use BFS on a tree, where the root is a starting digit<br/>    // for each number in root, we create 2 trees, one for only appending numbers (TA), and the other preppending (TP)<br/>    // everytime we traverse down, we can prune a number if it is not prime<br/><br/>    // a number is a valid truncated prime if it is seen once in TA and once in TP<br/>    const seen = { };<br/><br/>    // 1, 9 cannot be a root as it is not prime<br/>    const queueA = [2, 3, 5, 7]; // queue for append<br/>    const queueP = [3, 7]; // queue for preppend (preppending to a 2 or 5 will automatically make a number composite)<br/><br/>    while (queueA.length \|\| queueP.length) {<br/>      if (queueA.length) {<br/>        const nodeA = queueA.shift();<br/>        if (seen[nodeA] && nodeA.toString().length > 1) {<br/>          truncatedPrimes.push(nodeA);<br/>          validDigitsA.forEach((vd) => {<br/>            queueA.push(+(`${nodeA}${vd}`));<br/>          });<br/>        } else if (utils.isPrime(nodeA)) {<br/>          seen[nodeA] = true;<br/>          validDigitsA.forEach((vd) => {<br/>            queueA.push(+(`${nodeA}${vd}`));<br/>          });<br/>        }<br/>      }<br/>      if (queueP.length) {<br/>        const nodeP = queueP.shift();<br/>        const firstDigitOfNode = +(nodeP.toString().charAt(0));<br/><br/>        // preppending to 2, 5 will result in a composite right truncation<br/>        const stopPreppend = firstDigitOfNode === 2 \|\| firstDigitOfNode === 5;<br/><br/>        // preppending the same digit to the leading digit eg. 357 -> 3357 will result in the first 2 leading digit to be divisible by 11<br/>        // except when the leading digit is 1, then preppending by 1 is still fine as 11 is prime<br/>        const validDigits = validDigitsP.filter(x => x === 1 \|\| x !== firstDigitOfNode);<br/>        if (seen[nodeP] && nodeP.toString().length > 1) {<br/>          truncatedPrimes.push(nodeP);<br/>          if (!stopPreppend) {<br/>            validDigits.forEach((vd) => {<br/>              queueP.push(+(`${vd}${nodeP}`));<br/>            });<br/>          }<br/>        } else if (utils.isPrime(nodeP)) {<br/>          seen[nodeP] = true;<br/>          if (!stopPreppend) {<br/>            validDigits.forEach((vd) => {<br/>              queueP.push(+(`${vd}${nodeP}`));<br/>            });<br/>          }<br/>        }<br/>      }<br/>    }<br/><br/>    return utils.sumArray(truncatedPrimes);<br/>  },<br/><br/> <strong>Question:</strong> Find the sum of the only eleven primes that are both truncatable from left to right and right to left. | 748*** | 3.902ms | [:arrow_upper_right:](https://projecteuler.net/problem=37)<br/><br/>
**38.** [Pandigital multiples](https://github.com/zheng214/euler/blob/master/euler/4/index.js#L441-L481) | <br/>*<br/> Take the number 192 and multiply it by each of 1, 2, and 3:<br/><br/> 192 × 1 = 192<br/> 192 × 2 = 384<br/> 192 × 3 = 576<br/><br/> By concatenating each product we get the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated product of 192 and (1,2,3)<br/><br/> The same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5, giving the pandigital, 918273645, which is the<br/> concatenated product of 9 and (1,2,3,4,5)<br/><br/> (1,2, ... , n) where n > 1?<br/>    // we are given that the answer is >= 918273645<br/>    // given that our multiplicand (m) has 2 digits, then it must be >= 91<br/>    // successive multiplication by 1, 2, 3, 4 will yield products of 2 digits, 3 digits, 3 digits, 3 digits = 11 digits > 9 digits<br/>    // we can apply the same logic to 3 digit multiplicands: 3 + 4 + 4 > 9<br/>    // for 5 digits and above, the result of mulitpliying by 1 and 2 will result in a >5 and >6 digit multiplicand > 9 digits<br/> 1 has 4 digits and m * 2 has 5 digits, 4 + 5 = 9<br/>    // we dont have to check numbers > 9500 as multipliying by 2 will yield 19...<br/>    let largestPandigitalProduct = 918273645;<br/>    for (let m = 9182; m <= 9487; m++) {<br/>      const multiplicandArr = m.toString().split('');<br/>      const mHasDuplicate = multiplicandArr.length !== (new Set(multiplicandArr)).size;<br/>      if (!mHasDuplicate) {<br/> 100000 + 2 * m; // eg. 9182 -> 918200000 + 18364 -> 918218364<br/><br/>        // check if product is pandigital<br/>        const productArr = product.toString().split('');<br/>        const hasDuplicate = productArr.length !== (new Set(productArr)).size;<br/>        if (!hasDuplicate && !productArr.includes('0')) {<br/>          largestPandigitalProduct = +(`${product}`);<br/>        }<br/>      }<br/>    }<br/>    return largestPandigitalProduct;<br/>  },<br/><br/> <strong>Question:</strong> What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with | 9327***** | 0.634ms | [:arrow_upper_right:](https://projecteuler.net/problem=38)<br/><br/>
**39.** [Integer right triangles](https://github.com/zheng214/euler/blob/master/euler/4/index.js#L483-L526) | <br/>*<br/> If p is the perimeter of a right angle triangle with integral length sides, {a,b,c}, there are exactly three solutions for p = 120.<br/> {20,48,52}, {24,45,51}, {30,40,50}<br/>    // we can generate all unique primitive pythagorean triples given a pair of integers m, n:<br/>    // a = m^2 - n^2, b = 2mn, c = m^2 + n^2, where:<br/>    // 1. m > n > 0<br/>    // 2. m and n must not both be odd<br/>    // 3. m and n must be coprime:<br/><br/>    // so we have perimeter = a+b+c = 2m^2 + 2mn = 2m(m+n)<br/><br/>    // we just generate each m, n pair and increment the value associated with p<br/>    // then we also increment each multiple of the generated perimeter<br/>    const perimeters = {};<br/><br/>    let maximizedPerimeter = 12;<br/>    let maximizedPerimeterSolutionsCount = 0;<br/><br/>    // we can quickly check that in order to satisfy p <= 1000, m <= 23<br/>    for (let m = 2; m <= 23; m++) {<br/>      for (let n = 1; n < m; n++) {<br/>        if ((utils.isEven(m) \|\| utils.isEven(n)) && utils.isCoprime(m, n)) {<br/> m * (m + n);<br/>          let multiple = 1;<br/> multiple;<br/>          while (multipliedPerimeter <= 1000) {<br/>            perimeters[multipliedPerimeter] = (perimeters[multipliedPerimeter] \|\| 0) + 1;<br/>            const perimeterSolutionsCount = perimeters[multipliedPerimeter];<br/>            if (perimeterSolutionsCount > maximizedPerimeterSolutionsCount) {<br/>              maximizedPerimeterSolutionsCount = perimeterSolutionsCount;<br/>              maximizedPerimeter = multipliedPerimeter;<br/>            }<br/>            multiple++;<br/> multiple;<br/>          }<br/>        }<br/>      }<br/>    }<br/>    return maximizedPerimeter;<br/>  },<br/><br/> <strong>Question:</strong> For which value of p ≤ 1000, is the number of solutions maximised? | 8** | 1.068ms | [:arrow_upper_right:](https://projecteuler.net/problem=39)<br/><br/>
**40.** [Champernowne's constant](https://github.com/zheng214/euler/blob/master/euler/4/index.js#L528-L582) | <br/>*<br/> An irrational decimal fraction is created by concatenating the positive integers:<br/> 0.12345678910[1]112131415161718192021...<br/> It can be seen that the 12th digit of the fractional part is 1 (enclosed in square brackets []).<br/>    // we split the fractional part into sections, where the first section contains the numbers with one digit (1,2,3,...,9),<br/>    // the second section contains the 2-digits numbers (11,12,...,99), etc.<br/> 10^(i-1) digits total<br/>    const searchIndexes = [1, 10, 100, 1000, 10000, 100000, 1000000];<br/>    const foundDigits = [];<br/><br/>    let section = 1;<br/><br/>    let currentIndex = 0; // d_n<br/><br/>    while (searchIndexes.length) {<br/>      // we find the last index of the current section<br/> section * (10 ** (section - 1));<br/>      // we find all the d_i where i < last index of current section<br/>      while (searchIndexes[0] < lastIndexOfSection) {<br/>        const indexToFind = searchIndexes.shift();<br/>        // find the matching number corresponding to an index<br/>        // e.g. for section 2: {10,11 -> 10}, {12,13 -> 11}, {14,15 -> 12}, etc<br/>        // e.g. for section 3: {190, 190, 192 -> 100}, {193, 194, 195 -> 101}, etc.<br/>* (section - 1)) - 1 + Math.ceil((indexToFind - currentIndex) / section);<br/><br/>        // find the corresponding digit in the matched number<br/>        // e.g. for section 2: {10 -> 1, 11 -> 0}, {12 -> 1, 13 -> 1}, {14 -> 1, 15 -> 2}, etc.<br/>        // e.g. for section 3: {190 -> 1, 191 -> 0, 192 -> 0}, {193 -> 1, 194 -> 0, 195 -> 1}, etc.<br/>        const matchedDigitIndex = ((indexToFind - currentIndex) % section);<br/><br/>        // we adjust the matched index based on the modulus<br/>        // e.g. if the matched number has 3 digits (section 3), then we must modify the index like so:<br/>        // 1 -> 0, 2 -> 1, 0 -> 2<br/>        // ie. we convert index of the format<br/>        // {1,2,0} (obtained by {1/3, 2/3, 3/3}) to<br/>        // {0,1,2} (accurate representation of the index we want)<br/>        const adjustedDigitIndex = matchedDigitIndex<br/>          ? matchedDigitIndex - 1<br/>          : matchedNumber.toString().length - 1;<br/>        const matchedDigit = +(matchedNumber.toString().charAt(adjustedDigitIndex));<br/>        foundDigits.push(matchedDigit);<br/>      }<br/>      // go to next index<br/>      section++;<br/>      // set the start index as the end of last section<br/>      currentIndex = lastIndexOfSection;<br/>    }<br/><br/> c, 1);<br/>  },<br/><br/> <strong>Question:</strong> If d_n represents the nth digit of the fractional part, find the value of the following expression.<br/>  d_1 × d_10 × d_100 × d_1000 × d_10000 × d_100000 × d_1000000 | 2** | 0.599ms | [:arrow_upper_right:](https://projecteuler.net/problem=40)<br/><br/>
**41.** [Pandigital prime](https://github.com/zheng214/euler/blob/master/euler/5/index.js#L2-L31) | module.exports = {<br/>*<br/> We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once.<br/> For example, 2143 is a 4-digit pandigital and is also prime.<br/>    // n cannot be 9, as the digits sum up to 45, and therefore divisible by 3<br/>    // by the same logic, n cannot be 8 either<br/>    const digits = [7, 6, 5, 4, 3, 2, 1];<br/><br/>    // we don't need to check if the number is prime if the finalDigit is 2, 4, 5, or 6<br/>    const validFinalDigits = [1, 3, 7];<br/><br/>    // we search from n = 7 to n = 4 (given in problem statement)<br/>    for (let n = 7; n >= 4; n--) {<br/>      const validDigits = digits.slice(7 - n);<br/>      // here i represents the ith lexicographic permutation<br/>      for (let i = 1; i <= utils.fact(n); i++) {<br/>        const pandigitalArray = utils.getLexicographicPermutation(validDigits, i);<br/>        const finalDigit = pandigitalArray[pandigitalArray.length - 1];<br/>        if (validFinalDigits.includes(+(finalDigit))) {<br/>          const pandigitalNumber = +(pandigitalArray.join(''));<br/>          if (utils.isPrime(pandigitalNumber)) {<br/>            return pandigitalNumber;<br/>          }<br/>        }<br/>      }<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> What is the largest n-digit pandigital prime that exists? | 765**** | 1.370ms | [:arrow_upper_right:](https://projecteuler.net/problem=41)<br/><br/>
**42.** [Coded Triangle numbers](https://github.com/zheng214/euler/blob/master/euler/5/index.js#L33-L57) | <br/>*<br/> The nth term of the sequence of triangle numbers is given by, tn = ½n(n+1); so the first ten triangle numbers are:<br/> 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...<br/> By converting each letter in a word to a number corresponding to its alphabetical position and adding these values<br/> we form a word value. For example, the word value for SKY is 19 + 11 + 25 = 55 = t10. If the word value is a triangle<br/> number then we shall call the word a triangle word.<br/><br/>    // we can assume that a word cannot exceed the word value of 500 (almost 20 consecutive 'z')<br/>    // we generate a table of triangle numbers up to 500<br/>    let triangleWords = 0;<br/>    const triangleTable = utils.generateTriangleNumbersTable(500);<br/>    const words = fs.readFileSync(path.join(__dirname, 'p042_words.txt')).toString().replace(/"/g, '').split(',');<br/>    words.forEach((word) => {<br/>      const wordValue = utils.sumArray(word.split(''), char => char.charCodeAt(0) - 64);<br/>      if (triangleTable[wordValue]) {<br/>        triangleWords++;<br/>      }<br/>    });<br/>    return triangleWords;<br/>  },<br/><br/> <strong>Question:</strong> Using [p042_words.txt](https://github.com/zheng214/euler/blob/master/euler/5/p042_words.txt), a 16K text file<br/>  containing nearly two-thousand common English words, how many are triangle words? | 1** | 2.712ms | [:arrow_upper_right:](https://projecteuler.net/problem=42)<br/><br/>
**43.** [Sub-string divisibility](https://github.com/zheng214/euler/blob/master/euler/5/index.js#L59-L113) | <br/>*<br/> The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order,<br/> but it also has a rather interesting sub-string divisibility property.<br/> Let d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note the following:<br/> d2d3d4=406 is divisible by 2<br/> d3d4d5=063 is divisible by 3<br/> d4d5d6=635 is divisible by 5<br/> d5d6d7=357 is divisible by 7<br/> d6d7d8=572 is divisible by 11<br/> d7d8d9=728 is divisible by 13<br/> d8d9d10=289 is divisible by 17<br/><br/>    const subdivisibleNumbers = [];<br/>    // we describe our recursion as the following:<br/>    // 1. start by picking the last 3 digits s.t. it is divisible by 17, ie. 017, 034, ...<br/>    // 2. we then pick d7 s.t. d7d8d9 is divisible by 13, if such d7 does not exist, we go to the next iteration<br/>    // 3. if it does exist, we pick d6 s.t. d6d7d8 is divisible by 11, etc.<br/>    const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];<br/> 17 = 986, largest 3-digit number which is divisible by 17<br/>    for (let i = 1; i <= 58; i++) {<br/> 17).toString().padStart(3, '0'); // 1 -> '017', 2 -> '034, etc<br/>      if (!utils.containsDuplicate(last3)) {<br/>        buildNumber(<br/>          last3,<br/>          digits.filter(x => !last3.includes(x)),<br/>          [2, 3, 5, 7, 11, 13],<br/>        );<br/>      }<br/>    }<br/><br/>    // recursively build a number digit by digit, ensuring divisibility at each step<br/>    function buildNumber(acc, remainingDigits, remainingDividers) {<br/>      if (!remainingDividers.length) {<br/>        return subdivisibleNumbers.push(`${remainingDigits[0]}${acc}`);<br/>      }<br/>      const divider = remainingDividers.pop();<br/>      for (let j = 0; j < remainingDigits.length; j++) {<br/>        const leadingDigit = remainingDigits[j];<br/>        const trailingDigits = +acc.slice(0, 2);<br/> 100 + trailingDigits;<br/>        if (numToCheck % divider === 0) {<br/>          buildNumber(<br/>            `${leadingDigit}${acc}`,<br/>            [...remainingDigits].filter(x => x !== leadingDigit),<br/>            [...remainingDividers],<br/>          );<br/>        }<br/>      }<br/>    }<br/>    return utils.sumArray(subdivisibleNumbers, x => +x);<br/>  },<br/><br/> <strong>Question:</strong> Find the sum of all 0 to 9 pandigital numbers with this property. | 16695****** | 1.153ms | [:arrow_upper_right:](https://projecteuler.net/problem=43)<br/><br/>
**44.** [Pentagon numbers](https://github.com/zheng214/euler/blob/master/euler/5/index.js#L115-L140) | <br/>*<br/> Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:<br/> 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...<br/> It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.<br/><br/> and D = \|Pk − Pj\| is minimised; what is the value of D?<br/>    // we loop through each pentagonal number Pk, and for each Pk loop through each Pj smaller than Pk<br/>    // we check whether Pk - Pj AND Pk + Pj is pentagonal, if so return the difference<br/>    let k = 2;<br/>    while (true) {<br/>      const Pk = utils.toPolygonal(k, 5);<br/>      let j = k;<br/>      while (j >= 1) {<br/>        const Pj = utils.toPolygonal(j, 5);<br/>        if (utils.isPentagonal(Pk - Pj) && utils.isPentagonal(Pk + Pj)) {<br/>          return Pk - Pj;<br/>        }<br/>        j--;<br/>      }<br/>      k++;<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal | 548**** | 25.070ms | [:arrow_upper_right:](https://projecteuler.net/problem=44)<br/><br/>
**45.** [Triangular, pentagonal, and hexagonal](https://github.com/zheng214/euler/blob/master/euler/5/index.js#L142-L161) | <br/>*<br/> Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:<br/> Triangle Tn=n(n+1)/2: 1, 3, 6, 10, 15, ...<br/> Pentagonal Pn=n(3n−1)/2: 1, 5, 12, 22, 35, ...<br/> Hexagonal Hn=n(2n−1): 1, 6, 15, 28, 45, ...<br/> It can be verified that T285 = P165 = H143 = 40755.<br/><br/>    let h = 144;<br/>    while (true) {<br/>      const hexagonal = utils.toPolygonal(h, 6);<br/>      if (utils.isPentagonal(hexagonal) && utils.isTriangular(hexagonal)) {<br/>        return hexagonal;<br/>      }<br/>      h++;<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> Find the next triangle number that is also pentagonal and hexagonal. | 15337***** | 2.914ms | [:arrow_upper_right:](https://projecteuler.net/problem=45)<br/><br/>
**46.** [Goldbach's other conjecture](https://github.com/zheng214/euler/blob/master/euler/5/index.js#L163-L199) | <br/>*<br/> It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.<br/> 9 = 7 + 2×1^2<br/> 15 = 7 + 2×2^2<br/> 21 = 3 + 2×3^2<br/> 25 = 7 + 2×3^2<br/> 27 = 19 + 2×2^2<br/> 33 = 31 + 2×1^2<br/> It turns out that the conjecture was false.<br/><br/>    // check each odd number for primality; if it is composite, check for conjecture validity<br/>    let num = 9;<br/>    while (true) {<br/>      if (!utils.isPrime(num)) {<br/>        if (!conjValid(num)) {<br/>          return num;<br/>        }<br/>      }<br/>      num += 2;<br/>    }<br/><br/>    // determines whether a number is valid for Goldbach's conjecture<br/>    function conjValid(n) {<br/>      const rootUB = Math.sqrt((n - 2) / 2);<br/>      for (let i = 1; i <= rootUB; i++) {<br/>* 2) * 2;<br/>        if (utils.isPrime(n - twiceSquare)) {<br/>          return true;<br/>        }<br/>      }<br/>      return false;<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> What is the smallest odd composite that cannot be written as the sum of a prime and twice a square? | 57** | 3.653ms | [:arrow_upper_right:](https://projecteuler.net/problem=46)<br/><br/>
**47.** [Distinct primes factors](https://github.com/zheng214/euler/blob/master/euler/5/index.js#L201-L259) | <br/>*<br/> The first two consecutive numbers to have two distinct prime factors are:<br/> 14 = 2 × 7<br/> 15 = 3 × 5<br/><br/> The first three consecutive numbers to have three distinct prime factors are:<br/> 644 = 2² × 7 × 23<br/> 645 = 3 × 5 × 43<br/> 646 = 2 × 17 × 19.<br/><br/>    const first1000Primes = Object.keys(utils.generatePrimeTable(1000)); // assume for now that we don't need prime factors over 1000<br/> 3 * 5 * 7;<br/>    while (first < 1000000) {<br/>      const second = first + 1;<br/>      const third = first + 2;<br/>      const fourth = first + 3;<br/>      if (isDPFValid(first)) {<br/>        if (isDPFValid(second)) {<br/>          if (isDPFValid(third)) {<br/>            if (isDPFValid(fourth)) {<br/>              return first;<br/>            } // if the fourth number is not valid, skip over the next four numbers<br/>            first += 4;<br/>          } else { // if the third number is not valid, skip over the next 3 numbers, etc.<br/>            first += 3;<br/>          }<br/>        } else {<br/>          first += 2;<br/>        }<br/>      } else {<br/>        first++;<br/>      }<br/>    }<br/><br/>    // we implement a tailored function which returns true iff n has exactly 4 distinct prime factors<br/>    function isDPFValid(n) {<br/>      let quotient = n;<br/>      let DPFCount = 0;<br/>      for (let primeIndex = 0; primeIndex < first1000Primes.length; primeIndex++) {<br/>        const primeFactor = first1000Primes[primeIndex];<br/>        if (primeFactor > quotient) {<br/>          return DPFCount === 4;<br/>        }<br/>        if (quotient % primeFactor === 0) {<br/>          DPFCount++;<br/>        }<br/>        while (quotient % primeFactor === 0) {<br/>          if (DPFCount > 4) {<br/>            return false;<br/>          }<br/>          quotient /= primeFactor;<br/>        }<br/>      }<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> Find the first four consecutive integers to have four distinct prime factors each. What is the first of these numbers? | 134*** | 240.930ms | [:arrow_upper_right:](https://projecteuler.net/problem=47)<br/><br/>
**48.** [Self powers](https://github.com/zheng214/euler/blob/master/euler/5/index.js#L261-L287) | <br/>*<br/> The series, 1¹ + 2² + 3³ + ... + 10¹⁰ = 10405071317.<br/><br/>    let result = 0;<br/>    for (let i = 1; i <= 1000; i++) {<br/>      result = getLast10Digits(result) + getSelfPower(i);<br/>    }<br/>    return result;<br/><br/>    function getSelfPower(n) {<br/>      // returns the last 10 digits of n^n<br/>      if (n % 10 === 0) {<br/> k, then n^n = (k*10)^(k*10) = (k*10)^k * 10^(k*10) = C * 10^(k*10) => last 10 digits will be 0s<br/>        return 0;<br/>      }<br/> n, n);<br/>    }<br/><br/>    function getLast10Digits(n) {<br/>      // returns the last 10 digits of a number<br/>      return +n.toString().slice(-10);<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> Find the last ten digits of the series, 1¹ + 2² + 3³ + ... + 1000¹⁰⁰⁰. | 91108***** | 137.187ms | [:arrow_upper_right:](https://projecteuler.net/problem=48)<br/><br/>
**49.** [Prime permutations](https://github.com/zheng214/euler/blob/master/euler/5/index.js#L289-L335) | <br/>*<br/> The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, is unusual in two ways:<br/> (i) each of the three terms are prime, and,<br/> (ii) each of the 4-digit numbers are permutations of one another.<br/><br/>    // we generate all primes under 10000, for each prime generated we sort their digits from lower to higher, and classify them in a table<br/><br/>    // Equivalence Class table, the key represents the equivalence class number (e.g 1478)<br/>    // And the value will be the list of primes in that equivalence class<br/>    // e.g. for 1478, the value will be [ '1487', '1847', '4817', '4871', '7481', '7841', '8147', '8741' ]<br/>    const permutationClassTable = {};<br/>    const fourDigitPrimes = Object.keys(utils.generatePrimeTable(10000)).filter(x => x >= 1000);<br/>    for (let i = 0; i < fourDigitPrimes.length; i++) {<br/>      const sortedDigits = fourDigitPrimes[i].toString().split('').sort().join('');<br/>      const permutations = permutationClassTable[sortedDigits];<br/>      if (permutations) {<br/>        permutationClassTable[sortedDigits].push(fourDigitPrimes[i]);<br/>      } else {<br/>        permutationClassTable[sortedDigits] = [fourDigitPrimes[i]];<br/>      }<br/>    }<br/><br/>    // now that we have our equivalence class table, we loop over the keys and for each key, we check the list of corresponding primes<br/>    // for whether or not one number is the average of 2 other numbers<br/>    const keys = Object.keys(permutationClassTable);<br/>    for (let i = 0; i < keys.length; i++) {<br/>      const key = keys[i];<br/>      if (key !== '1478') { // this answer is given in problem statement<br/>        const primes = permutationClassTable[key];<br/>        if (primes.length >= 3) {<br/>          for (let j = 0; j < primes.length - 2; j++) {<br/>            for (let k = j + 2; k < primes.length; k++) {<br/>              const avg = (+primes[j] + +primes[k]) / 2;<br/>              if (primes.includes(avg.toString())) {<br/>                return `${primes[j]}${avg}${primes[k]}`;<br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, exhibiting this property, but there is<br/>  one other 4-digit increasing sequence. What 12-digit number do you form by concatenating the three terms in this sequence? | 296962****** | 4.382ms | [:arrow_upper_right:](https://projecteuler.net/problem=49)<br/><br/>
**50.** [Consecutive prime sum](https://github.com/zheng214/euler/blob/master/euler/5/index.js#L337-L381) | <br/>*<br/> The prime 41, can be written as the sum of six consecutive primes:<br/> 41 = 2 + 3 + 5 + 7 + 11 + 13<br/> This is the longest sum of consecutive primes that adds to a prime below one-hundred.<br/> The longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, and is equal to 953.<br/>    // we begin by generating the list of primes under 1 million<br/>    const primesTable = utils.generatePrimeTable(1000000);<br/>    const primesList = Object.keys(primesTable).map(x => +x);<br/>    // next we determine the upper bound for the number of consecutive primes s.t. their sum does not exceed one million<br/>    const upperConsec = [...primesList].reduce(<br/>      (sum, curr, i, arr) => {<br/>        if (sum >= 1000000) {<br/>          // if sum exceeds one million, returns the number of terms and exit from the reducer<br/>          arr.splice(1);<br/>          return i;<br/>        }<br/>        return sum + curr;<br/>      },<br/>    ); // spoiler: the upper bound is 547<br/><br/>    let largestSum = 0;<br/><br/>    // t := number of terms in the sum<br/>    // for each t, we sum t consecutive primes and check if their sum is also prime<br/>    // if it is we store that number and continue checking for the current t<br/>    // once we are done we just return the largest sum obtained at the current t<br/>    for (let t = upperConsec; t >= 21; t--) {<br/>      let j = 0;<br/>      let sum = utils.sumArray(primesList.slice(j, j + t));<br/>      while (sum < 1000000) {<br/>        if (primesTable[sum] && sum > largestSum) {<br/>          largestSum = sum;<br/>        }<br/>        j++;<br/>        sum = utils.sumArray(primesList.slice(j, j + t));<br/>      }<br/>      if (largestSum > 0) {<br/>        return largestSum;<br/>      }<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> Which prime, below one-million, can be written as the sum of the most consecutive primes? | 997*** | 68.931ms | [:arrow_upper_right:](https://projecteuler.net/problem=50)<br/><br/>
**51.** [Prime digit replacements](https://github.com/zheng214/euler/blob/master/euler/6/index.js#L2-L47) | module.exports = {<br/>*<br/> By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values:<br/> 13, 23, 43, 53, 73, and 83, are all prime.<br/><br/> By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit number is the first example<br/> having seven primes among the ten generated numbers, yielding the family:<br/> 56003, 56113, 56333, 56443, 56663, 56773, and 56993. Consequently 56003, being the first member of this family,<br/> is the smallest prime with this property.<br/><br/> as the "variable" part, and the rest of digits as the "fixed" part<br/> must be a multiple of 3, as otherwise there will be at least 3 numbers in each family which will be divisble by 3<br/>    // because the sum of their digits will be a multiple of 3.<br/>    // we first try with 3 variable digits and 3 fixed digits or less;<br/>    const candidates = [];<br/>    for (let fixedDigits = 1; fixedDigits <= 999; fixedDigits++) {<br/>'s<br/>**');<br/>      for (let i = 0; i < binomialCombinations.length; i++) {<br/>        const family = [];<br/>        let composites = 0;<br/>        for (let repl = 0; repl <= 9; repl++) { // replacement<br/>') { // leading 0's aren't valid<br/>            if (utils.isPrime(familyMember)) {<br/>              family.push(familyMember);<br/>              if (family.length >= 8) {<br/>                candidates.push(family);<br/>              }<br/>            } else {<br/>              composites++;<br/>              if (composites >= 3) {<br/>                break;<br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>    // from the list of candidates, return the family with the smallest member<br/>    return Math.min(candidates.map(x => x[0]));<br/>  },<br/><br/> <strong>Question:</strong> Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit,<br/>  is part of an eight prime value family. | 121*** | 118.931ms | [:arrow_upper_right:](https://projecteuler.net/problem=51)<br/><br/>
**52.** [Permuted multiples](https://github.com/zheng214/euler/blob/master/euler/6/index.js#L49-L121) | <br/>*<br/> It can be seen that the number, 125874, and its double, 251748, contain exactly the same digits, but in a different order.<br/>    // let d denote the number of digits of a number,<br/>    // for each d = 2, 3, 4, 5, 6, 7, ...<br/>    // we only need to check up to 10^d/6 as number greater than this will overflow an extra digit<br/>    // optimizations:<br/>    // 1. we can skip numbers which ends with a 0, since if such a number is qualified,<br/>    // we would already have found a qualified number by dividing this number by 10<br/>    // 2. we can skip even numbers which do not contain 0, as multiplying by 5 will produce a 0 in the result<br/>    // and we can skip odd numbers which do not contain a 5<br/>    // 3. we can skip numbers which do not contain any digit greater than 5, as multiplying by 2 will double the digit sum of the result<br/>    // return console.log(containSameDigits(142857, 285714, 5))<br/><br/>    // search between 2 to 8 digits<br/>    for (let d = 1; d <= 7; d++) {<br/>      // define search range for a particular d<br/>* d;<br/>* (d + 1)) / 6);<br/>      let even = false;<br/>      for (let n = min; n <= max; n++) {<br/>        even = !even; // we flip the parity flag instead of checking for parity each time<br/>        if (!canSkip(n, d, even)) { // skip numbers which fulfill the criteria above<br/>          let failed = false;<br/>          for (let m = 2; m <= 6; m++) {<br/> n;<br/>            if (!containSameDigits(product, n, d)) {<br/>              failed = true;<br/>              break;<br/>            }<br/>          }<br/>          if (!failed) {<br/>            return n;<br/>          }<br/>          // if all tests pass, return result<br/>        }<br/>      }<br/>    }<br/><br/>    // return true if a contains the same digits of b, where d := number of digits - 1<br/>    function containSameDigits(a, b, d) {<br/>      const balanceArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];<br/>      // index of this arr represents the digit found in a and b<br/>      // content of an index i represents the number of occurrences of digit i in a minus the number of occurrences of digit i in b<br/>      // a and b contain the same digits if, at the end, this array contains all 0s<br/>      for (let i = 0; i <= d; i++) {<br/>        balanceArr[+a.toString().charAt(i)]++;<br/>        balanceArr[+b.toString().charAt(i)]--;<br/>      }<br/>      return balanceArr.every(x => x === 0);<br/>    }<br/><br/>    // evaluates if a number is skippable<br/>    function canSkip(number, digits, even) {<br/>      const stringNumber = number.toString();<br/>      if (stringNumber.charAt(digits) === '0') {<br/>        return true;<br/>      }<br/>      if (even && !stringNumber.includes('0')) {<br/>        return true;<br/>      }<br/>      if (!even && !stringNumber.includes('5')) {<br/>        return true;<br/>      }<br/>      if (stringNumber.split('').every(x => +x < 5)) {<br/>        return true;<br/>      }<br/>      return false;<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits. | 142*** | 27.143ms | [:arrow_upper_right:](https://projecteuler.net/problem=52)<br/><br/>
**53.** [Combinatorics selections](https://github.com/zheng214/euler/blob/master/euler/6/index.js#L123-L161) | <br/>*<br/> There are exactly ten ways of selecting three from five, 12345:<br/> 123, 124, 125, 134, 135, 145, 234, 235, 245, and 345<br/> In combinatorics, we use the notation, C(5, 3) = 10<br/> In general, C(n, r) = n!/(r!(n−r)!), where r ≤ n<br/> It is not until n=23, that a value exceeds one-million: C(23, 10)=1144066.<br/>    // we generate the table of 100 x 100 where each cell, row i, column j holds the result C(i, j)<br/>    // instead of calculating each combination using the formula, we can use basic algebra for the follow update rules:<br/> N where N = (n+1)/(n-r+1)<br/> R where R = (n-r)/(r+1) => C(n, r - 1) = C(n, r) * r/(n-r+1)<br/>    // we also know that C(n, r) is greater than one million for all n >= 23 and r = 10, so we don't need to check for r > 10<br/>    let totalCount = 4; // for n = 23, obvious from problem statement<br/>    const combinationTable = new Array(101); // for convenience, n = 0 ... 100<br/>    for (let i = 23; i <= 100; i++) {<br/>      combinationTable[i] = new Array(11); // r = 0 ... 10<br/>    }<br/>    combinationTable[23][10] = 1144066;<br/>    for (let n = 24; n <= 100; n++) { // we can start at 24 given by problem statement<br/>      for (let r = 10; r > 0; r--) {<br/>        if (r === 10 && n !== 23) {<br/> n / (n - r);<br/>        } else {<br/> (r + 1) / (n - r);<br/>        }<br/>        if (combinationTable[n][r] < 1000000) {<br/>          const increment = utils.isEven(n)<br/> (n / 2 - r - 1)<br/> ((n + 1) / 2 - r - 1);<br/>          totalCount += increment;<br/>          break;<br/>        }<br/>      }<br/>    }<br/>    return totalCount;<br/>  },<br/><br/> <strong>Question:</strong> How many, not necessarily distinct, values of C(n, r) for 1 ≤ n ≤ 100, are greater than one-million? | 40** | 0.748ms | [:arrow_upper_right:](https://projecteuler.net/problem=53)<br/><br/>
**54.** [Poker hands](https://github.com/zheng214/euler/blob/master/euler/6/index.js#L163-L335) | <br/>*<br/><br/> In the card game poker, a hand consists of five cards and are ranked, from lowest to highest, in the following way:<br/><br/> High Card: Highest value card.<br/> One Pair: Two cards of the same value.<br/> Two Pairs: Two different pairs.<br/> Three of a Kind: Three cards of the same value.<br/> Straight: All cards are consecutive values.<br/> Flush: All cards of the same suit.<br/> Full House: Three of a kind and a pair.<br/> Four of a Kind: Four cards of the same value.<br/> Straight Flush: All cards are consecutive values of same suit.<br/> Royal Flush: Ten, Jack, Queen, King, Ace, in same suit.<br/><br/> The cards are valued in the order:<br/> 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace.<br/><br/> If two players have the same ranked hands then the rank made up of the highest value wins;<br/> for example, a pair of eights beats a pair of fives (see example 1 below). But if two ranks tie<br/> for example, both players have a pair of queens, then highest cards in each hand are compared;<br/> if the highest cards tie then the next highest cards are compared, and so on.<br/><br/> The file, [poker.txt]((https://github.com/zheng214/euler/blob/master/euler/6/p054_poker.txt)),<br/> contains one-thousand random hands dealt to two players. Each line of the file contains ten cards<br/> (separated by a single space): the first five are Player 1's cards and the last five are Player 2's cards.<br/><br/> You can assume that all hands are valid (no invalid characters or repeated cards), each player's hand is in no specific order,<br/> and in each hand there is a clear winner.<br/><br/>    // list of possible ranks<br/>    const RANKS = [2, 3, 4, 5, 6, 7, 8, 9, 'T', 'J', 'Q', 'K', 'A'];<br/><br/>    // generate the list of combinations of straights and all their combinations<br/>    // the keys of the table are the valid combinations of strings of 5 characters (not necessarily in order) which form a straight, ie. J8TQ9<br/>    // the value of each key is the highest rank of that straight<br/>    // note: this method may not be the fastest solution for this problem, but it is much more scalable (eg. 1 million hands instead of 1000)<br/>    const STRAIGHTS_TABLE = ['A', ...RANKS].reduce( // ace to ace<br/>      (table, curr, index, arr) => {<br/>        if (curr === 'J') {<br/>          arr.splice(1);<br/>        }<br/>        const highest = index + 5;<br/>        const base = arr.slice(index, index + 5);<br/>        for (let i = 0; i <= 120; i++) {<br/>          table[utils.getLexicographicPermutation(base, i).join('')] = highest;<br/>        }<br/>        return table;<br/>      },<br/>      {},<br/>    );<br/><br/>    const GAMES = fs.readFileSync(path.join(__dirname, 'p054_poker.txt')).toString().split('\n');<br/><br/>    return GAMES.reduce((p1Score, currentGame) => {<br/>      const [p1Hand, p2Hand] = [currentGame.substring(0, 14), currentGame.substring(15, 29)];<br/>      if (!p1Hand) { // end of games<br/>        return p1Score;<br/>      }<br/>      const [p1HandValue, p2HandValue] = [evaluateHand(p1Hand), evaluateHand(p2Hand)];<br/>      for (let i = 0; i < p1HandValue.length; i++) {<br/>        if (p1HandValue[i] > p2HandValue[i]) {<br/>          return p1Score + 1;<br/>        }<br/>        if (p1HandValue[i] < p2HandValue[i]) {<br/>          return p1Score;<br/>        }<br/>      }<br/>      return p1Score;<br/>    }, 0);<br/><br/>    // input: string of 5 cards, separated by a space<br/>    // output: score of hand, which is an array of size up to 6<br/>    // first element is the rank of the hand, where 9: straight flush, 8: four of a kind, etc.<br/>    // second element is the value of the first type within that rank, ie. a hand with 4 aces will have value 13, a hand with 4 kings value 12, etc.<br/>    // third element is the value of the second type within that rank, ie. if both players have 2 pair of aces and 3 singles, then we compare the<br/>    // second highest value etc.<br/>    function evaluateHand(hand) {<br/>      const cards = hand.split(' ');<br/>      // FLUSH check<br/>      // check if every card has the same suit as the first card<br/>      const firstSuit = cards[0].charAt(1);<br/>      const isFlush = cards.every(card => card.charAt(1) === firstSuit);<br/><br/>      // STRAIGHT check<br/>      // check the generated table of all possible straights<br/>      const highestStraight = STRAIGHTS_TABLE[cards.map(card => card.charAt(0)).join('')] \|\| false;<br/><br/>      // same of a kind table, keys are the ranks, values are the number of occurences of that rank<br/>      const rankTable = cards.reduce((table, currentCard) => {<br/>        const rank = currentCard.charAt(0);<br/>        table[rank] = table[rank] ? table[rank] + 1 : 1;<br/>        return table;<br/>      }, {});<br/><br/>      // inverted table of above, keys are occurrences and corresponding values are the ranks that fit that occurrence<br/>      const occurencesTable = Object.entries(rankTable).reduce((table, [key, value]) => {<br/>        if (table[value]) {<br/>          table[value].push(key);<br/>        } else {<br/>          table[value] = [key];<br/>        }<br/>        return table;<br/>      }, {});<br/><br/>      // now that we have all the variables we need, we attempt to match a hand with each hand type from strongest to weakest<br/><br/>      // STRAIGHT FLUSH<br/>      if (highestStraight && isFlush) {<br/>        return [9, getRank(highestStraight)];<br/>      }<br/><br/>      // FOUR OF A KIND<br/>      if (occurencesTable['4']) {<br/>        return [8, getRank(occurencesTable['4'][0]), getRank(occurencesTable['1'])];<br/>      }<br/><br/>      // FULL HOUSE<br/>      if (occurencesTable['3'] && occurencesTable['2']) {<br/>        return [7, getRank(occurencesTable['3'][0]), getRank(occurencesTable['2'][0])];<br/>      }<br/><br/>      // FLUSH<br/>      if (isFlush) {<br/>        return [6, ...occurencesTable['1'].map(getRank).sort(sortBiggest)];<br/>      }<br/><br/>      // STRAIGHT<br/>      if (highestStraight) {<br/>        return [5, getRank(highestStraight)];<br/>      }<br/><br/>      // THREE OF A KIND<br/>      if (occurencesTable['3']) {<br/>        return [4, getRank(occurencesTable['3'][0]), ...occurencesTable['1'].map(getRank).sort(sortBiggest)];<br/>      }<br/><br/>      // TWO PAIRS<br/>      if (occurencesTable['2'] && occurencesTable['2'].length === 2) {<br/>        return [3, ...occurencesTable['2'].map(getRank).sort(sortBiggest), getRank(occurencesTable['1'][0])];<br/>      }<br/><br/>      // ONE PAIR<br/>      if (occurencesTable['2']) {<br/>        return [2, getRank(occurencesTable['2'][0]), ...occurencesTable['1'].map(getRank).sort(sortBiggest)];<br/>      }<br/><br/>      // HIGH CARD<br/>      return [1, ...occurencesTable['1'].map(getRank).sort(sortBiggest)];<br/>    }<br/><br/>    function sortBiggest(a, b) {<br/>      return b - a;<br/>    }<br/><br/>    // returns the numerical rank of a card from a character<br/>    function getRank(card) {<br/>      if (+card) {<br/>        return +card;<br/>      }<br/>      return {<br/>        T: 10,<br/>        J: 11,<br/>        Q: 12,<br/>        K: 13,<br/>        A: 14,<br/>      }[card];<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> How many hands does Player 1 win? | 3** | 23.880ms | [:arrow_upper_right:](https://projecteuler.net/problem=54)<br/><br/>
**55.** [Lychrel numbers](https://github.com/zheng214/euler/blob/master/euler/6/index.js#L337-L394) | <br/>*<br/><br/> If we take 47, reverse and add, 47 + 74 = 121, which is palindromic.<br/><br/> Not all numbers produce palindromes so quickly. For example,<br/> 349 + 943 = 1292,<br/> 1292 + 2921 = 4213<br/> 4213 + 3124 = 7337<br/><br/> That is, 349 took three iterations to arrive at a palindrome.<br/><br/> Although no one has proved it yet, it is thought that some numbers, like 196, never produce a palindrome. A number that never forms a palindrome<br/> through the reverse and add process is called a Lychrel number. Due to the theoretical nature of these numbers, and for the purpose of this problem,<br/> we shall assume that a number is Lychrel until proven otherwise. In addition you are given that for every number below ten-thousand, it will either<br/> (i) become a palindrome in less than fifty iterations, or,<br/> (ii) no one, with all the computing power that exists, has managed so far to map it to a palindrome.<br/> 10677 is the first number to be shown to require over fifty iterations before producing a palindrome: 4668731596684224866951378664 (53 iterations, 28-digits).<br/><br/> Surprisingly, there are palindromic numbers that are themselves Lychrel numbers; the first example is 4994.<br/><br/>    const lychrelNumbers = {}; // memoized table for all lychrel numbers (doesnt terminate)<br/>    const nonLychrelNumbers = {}; // numbers which produce a palindrom through reverse add<br/><br/>    for (let n = 1; n <= 10000; n++) {<br/>      testLychrel(n);<br/>    }<br/><br/>    function testLychrel(n) {<br/>      const encounteredNumbers = {};<br/>      let sum = n;<br/>      for (let i = 1; i <= 50; i++) {<br/>        const flipped = utils.flip(sum);<br/>        encounteredNumbers[sum] = true;<br/>        if (sum % 10) {<br/>          encounteredNumbers[flipped] = true;<br/>        }<br/>        if (nonLychrelNumbers[sum]) {<br/>          Object.assign(nonLychrelNumbers, encounteredNumbers);<br/>          break;<br/>        }<br/>        if (lychrelNumbers[sum] \|\| i === 50) {<br/>          Object.assign(lychrelNumbers, encounteredNumbers);<br/>          break;<br/>        }<br/>        sum += flipped;<br/>        if (utils.isPalindrome(sum)) {<br/>          Object.assign(nonLychrelNumbers, encounteredNumbers);<br/>          break;<br/>        }<br/>      }<br/>    }<br/><br/>    return Object.keys(lychrelNumbers).filter(x => x <= 10000).length;<br/>  },<br/><br/> <strong>Question:</strong> How many Lychrel numbers are there below ten-thousand? | 2** | 29.900ms | [:arrow_upper_right:](https://projecteuler.net/problem=55)<br/><br/>
**56.** [Powerful digit sum](https://github.com/zheng214/euler/blob/master/euler/6/index.js#L396-L471) | <br/>*<br/><br/> A googol (10^100) is a massive number: one followed by one-hundred zeros;<br/> 100^100 is almost unimaginably large: one followed by two-hundred zeros.<br/> Despite their size, the sum of the digits in each number is only 1.<br/><br/>    const expTable = [...Array(99)].map((x, i) => [(i + 1).toString()]); // initialize<br/>    let largestDigitSum = 0;<br/><br/>    expTable.forEach((column, colIndex) => {<br/>      const base = colIndex + 1;<br/>      // each column i contains the result of [i ^ 1, i ^ 2, ..., i ^ 99]<br/>      // we will skip numbers < 10 and multiples of 10<br/>      if (base < 10 \|\| base % 10 === 0) {<br/>        return null;<br/>      }<br/>      for (let exp = 1; exp <= 99; exp++) {<br/> BigInt(base);<br/>        // const result = longMultiply(column[exp - 1], base.toString());<br/>        const digitSum = utils.sumArray(result, x => +x);<br/>        if (digitSum > largestDigitSum) {<br/>          largestDigitSum = digitSum;<br/>        }<br/>        column.push(result.reverse().join(''));<br/>      }<br/>    });<br/><br/>    return largestDigitSum;<br/><br/>    // takes 2 strings of numbers as params, returns an array containing the digits of the product of the 2 numbers<br/>    // multiplies the 2 numbers using long multiplication<br/>    // is obsolete when BigInt gets pass stage 3<br/>    function longMultiply(a, b) {<br/>      const mTable = {};<br/>      const [n1, n2] = [a.split('').reverse(), b.split('').reverse()];<br/>      const partialResultsTable = n2.reduce(<br/>        (acc, curr, idx) => {<br/>          if (curr) {<br/>            const power = idx;<br/> curr);<br/>            mTable[curr] = results;<br/>            results.forEach((partialProduct, i) => {<br/>              if (!acc[power + i + 1]) acc[power + i + 1] = [];<br/>              if (partialProduct < 10) {<br/>                acc[power + i].push(partialProduct);<br/>              } else {<br/>                acc[power + i].push(partialProduct.toString().split('')[1]);<br/>                acc[power + i + 1].push(partialProduct.toString().split('')[0]);<br/>              }<br/>            });<br/>          }<br/>          return acc;<br/>        },<br/>        [[]],<br/>      );<br/>      // add the digits with respect to their positions<br/>      return consolidatePartialResults(partialResultsTable);<br/>    }<br/><br/>    function consolidatePartialResults(table) {<br/>      const flatResults = [];<br/>      let carry = 0;<br/>      for (let columnIndex = 0; columnIndex < table.length; columnIndex++) {<br/>        const col = table[columnIndex];<br/>        const sum = (col.reduce((a, c) => +c + a, 0) + +carry).toString();<br/>        const retainedDigit = sum.slice(-1);<br/>        carry = sum.slice(0, sum.length - 1);<br/>        flatResults.push(retainedDigit);<br/>      }<br/>      return flatResults;<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> Considering natural numbers of the form, ab, where a, b < 100, what is the maximum digital sum? | 9** | 188.507ms | [:arrow_upper_right:](https://projecteuler.net/problem=56)<br/><br/>
**57.** [Square root convergents](https://github.com/zheng214/euler/blob/master/euler/6/index.js#L473-L506) | <br/>*<br/> It is possible to show that the square root of two can be expressed as an infinite continued fraction.<br/> sqrt(2) = 1 + 1 / (2 + 1 / (2 + 1 / (2 + ...)))<br/><br/> By expanding for the first three iterations. we get:<br/><br/> 1 + 1 / 2 = 3/2 = 1.5<br/> 1 + 1 / (2 + 1 / 2) = 7/5 = 1.4<br/> 1 + 1 / (2 + 1 / (2 + 1 / 2)) = 17/12 = 1.41666<br/><br/> The next three expansions are 41/29, 99/70, and 239/169, but the 8th expansion, 1393/985, is the first exmaple where the number of digits<br/> in the numerator exceeds the number of digits in the denominator.<br/><br/>    let currentExpansion = [3n, 2n];<br/>    let numeratorDigitExcessCount = 0;<br/><br/>    for (let i = 1; i < 1000; i++) {<br/>      currentExpansion = computeNextCF(currentExpansion);<br/>      if (currentExpansion[0].toString().length > currentExpansion[1].toString().length) {<br/>        numeratorDigitExcessCount++;<br/>      }<br/>    }<br/><br/>    // compute the next continued fraction expansion based on the current expansion<br/>    function computeNextCF([n, d]) {<br/> d + n, d + n];<br/>    }<br/><br/>    return numeratorDigitExcessCount;<br/>  },<br/><br/> <strong>Question:</strong> In the first one-thousand expansions, how many fractions contain a numerator with more digits than the denominator? | 1** | 10.883ms | [:arrow_upper_right:](https://projecteuler.net/problem=57)<br/><br/>
**58.** [Spiral Primes](https://github.com/zheng214/euler/blob/master/euler/6/index.js#L508-L550) | <br/>*<br/> Starting with 1 and spiralling anticlockwise in the following way, a square spiral with side length 7 is formed.<br/><br/> 37 36 35 34 33 32 31<br/> 38 17 16 15 14 13 30<br/> 39 18  5  4  3 12 29<br/> 40 19  6  1  2 11 28<br/> 41 20  7  8  9 10 27<br/> 42 21 22 23 24 25 26<br/> 43 44 45 46 47 48 49<br/> It is interesting to note that the odd squares lie along the bottom right diagonal, but what is more interesting is that<br/> 8 out of the 13 numbers lying along both diagonals are prime; that is, a ratio of 8/13 ≈ 62%.<br/><br/> If one complete new layer is wrapped around the spiral above, a square spiral with side length 9 will be formed.<br/><br/><br/>    // generate a table of 1 million primes<br/>    // const PRIMES = utils.generatePrimeTable(10000000);<br/><br/>    // start from the second layer<br/>    let currentNumber = 9;<br/>    let primes = 3;<br/>    let diagonals = 5;<br/>    let sideLength = 3;<br/><br/>    while (`${primes}0` >= diagonals) {<br/>      sideLength += 2;<br/>      diagonals += 4;<br/>      const incr = sideLength - 1;<br/>      for (let i = 0; i < 4; i++) {<br/>        currentNumber += incr;<br/>        if (utils.isPrime(currentNumber)) {<br/>          primes++;<br/>        }<br/>      }<br/>    }<br/><br/>    return sideLength;<br/>  },<br/><br/> <strong>Question:</strong> If this process is continued, what is the side length of the square spiral for which the ratio of primes along both diagonals first falls below 10%? | 26*** | 391.202ms | [:arrow_upper_right:](https://projecteuler.net/problem=58)<br/><br/>
**59.** [XOR decryption](https://github.com/zheng214/euler/blob/master/euler/6/index.js#L552-L633) | <br/>*<br/><br/> Each character on a computer is assigned a unique code and the preferred standard is ASCII (American Standard Code for Information Interchange).<br/> For example, uppercase A = 65, asterisk (*) = 42, and lowercase k = 107.<br/><br/> A modern encryption method is to take a text file, convert the bytes to ASCII, then XOR each byte with a given value, taken from a secret key.<br/> The advantage with the XOR function is that using the same encryption key on the cipher text, restores the plain text;<br/> for example, 65 XOR 42 = 107, then 107 XOR 42 = 65.<br/><br/> For unbreakable encryption, the key is the same length as the plain text message, and the key is made up of random bytes.<br/> The user would keep the encrypted message and the encryption key in different locations, and without both "halves", it is impossible to decrypt the message.<br/><br/> Unfortunately, this method is impractical for most users, so the modified method is to use a password as a key.<br/> If the password is shorter than the message, which is likely, the key is repeated cyclically throughout the message.<br/> The balance for this method is using a sufficiently long password key for security, but short enough to be memorable.<br/><br/> Your task has been made easy, as the encryption key consists of three lower case characters.<br/>    // we start by compiling a list of valid password characters for each position<br/>    // we check each character of the password one by one, that is, we start with 'a', and we XOR it with the 1st, 4th, 7th, etc. characters of the cyphertext<br/>    // if at any point we xor a resulting character which is not a valid character for english text, ie. a-z, A-Z and punctuations, we discard it<br/>    // we repeat for the second and third character of the password p059_cipher.txt<br/>    const formatted = fs.readFileSync('6/p059_cipher.txt').toString().split(',').map(x => +x);<br/>    const filtered = {<br/>      first: formatted.filter((_, i) => i % 3 === 0), // every third ascii starting from pos 0<br/>      second: formatted.filter((_, i) => i % 3 === 1), // every third ascii starting from pos 1<br/>      third: formatted.filter((_, i) => i % 3 === 2), // every third ascii starting from pos 2<br/>    };<br/><br/>    const validPass = {<br/>      first: [],<br/>      second: [],<br/>      third: [],<br/>    };<br/><br/>    for (let i = 97; i <= 122; i++) {<br/>      if (isPassValid(i, 'first')) {<br/>        validPass.first.push(i);<br/>      }<br/>      if (isPassValid(i, 'second')) {<br/>        validPass.second.push(i);<br/>      }<br/>      if (isPassValid(i, 'third')) {<br/>        validPass.third.push(i);<br/>      }<br/>    }<br/><br/>    function isAsciiValid(ascii) {<br/>      // include all characters that can be typed on a standard english keyboard, except fractions, tab, and the following: \{}\|`~^_<br/>      return (ascii >= 32 && ascii <= 90) \|\| (ascii >= 97 && ascii <= 122) \|\| ascii === 91 \|\| ascii === 93;<br/>    }<br/><br/>    function isPassValid(code, startPosition) {<br/>      const encryptedChars = filtered[startPosition];<br/>      const isValid = encryptedChars.every((x) => {<br/>        return isAsciiValid((x ^ code));<br/>      });<br/>      return isValid;<br/>    }<br/><br/>    // console.log(validPass) // this will yield { first: [101], second: [120], third: [112] }<br/>    const password = [101, 120, 112];<br/><br/>    const plaintext = formatted.map((char, i) => char ^ password[i % 3]);<br/>    // console.log(String.fromCharCode(...plaintext)); // this will yield the following plaintext output<br/><br/>    An extract taken from the introduction of one of Euler's most celebrated papers, "De summis serierum reciprocarum" [On the sums of series of reciprocals]: I have<br/>    recently found, quite unexpectedly, an elegant expression for the entire sum of this series 1 + 1/4 + 1/9 + 1/16 + etc., which depends on the quadrature of the<br/>    circle, so that if the true sum of this series is obtained, from it at once the quadrature of the circle follows. Namely, I have found that the sum of this series<br/>    is a sixth part of the square of the perimeter of the circle whose diameter is 1; or by putting the sum of this series equal to s, it has the ratio sqrt(6) multiplied<br/>    by s to 1 of the perimeter to the diameter. I will soon show that the sum of this series to be approximately 1.644934066842264364; and from multiplying this number<br/>    by six, and then taking the square root, the number 3.141592653589793238 is indeed produced, which expresses the perimeter of a circle whose diameter is 1. Following<br/>    again the same steps by which I had arrived at this sum, I have discovered that the sum of the series 1 + 1/16 + 1/81 + 1/256 + 1/625 + etc. also depends on the<br/>    quadrature of the circle. Namely, the sum of this multiplied by 90 gives the biquadrate (fourth power) of the circumference of the perimeter of a circle whose<br/>    diameter is 1. And by similar reasoning I have likewise been able to determine the sums of the subsequent series in which the exponents are even numbers.<br/>    return utils.sumArray(plaintext);<br/>  },<br/><br/> <strong>Question:</strong> Using [p059_cipher.txt]((https://github.com/zheng214/euler/blob/master/euler/6/p059_cipher.txt)), a file containing the encrypted ASCII codes,<br/>  and the knowledge that the plain text must contain common English words, decrypt the message and find the sum of the ASCII values in the original text. | 129*** | 1.315ms | [:arrow_upper_right:](https://projecteuler.net/problem=59)<br/><br/>
**60.** [Prime pair sets](https://github.com/zheng214/euler/blob/master/euler/6/index.js#L635-L717) | <br/>*<br/><br/> The primes 3, 7, 109, and 673, are quite remarkable. By taking any two primes and concatenating them in any order the result will always be prime.<br/> For example, taking 7 and 109, both 7109 and 1097 are prime. The sum of these four primes, 792, represents the lowest sum for a set of four primes<br/> with this property.<br/><br/>    const PRIMES_TABLE = utils.generatePrimeTable(100000);<br/>    delete PRIMES_TABLE['2'];<br/>    delete PRIMES_TABLE['5'];<br/>    const PRIMES_ARR = Object.keys(PRIMES_TABLE);<br/>    const largestGeneratedPrime = PRIMES_ARR[PRIMES_ARR.length - 1];<br/><br/>    // we build tables which contains matching pairs, matching triples and matching quads<br/>    // we iteratively build them on top of each other<br/>    // for example, if we found a prime which matches with an existing member in the table of matched pairs<br/>    // then we can insert that prime, along with the matched pair, into the table of matched triples<br/>    // so on and so forth until we reach a matched quintuple<br/><br/>    const matchingPairsTable = {}; // prime pairs<br/>    const matchingTriplesTable = {}; // connected prime triples<br/>    const matchingQuadsTable = {}; // connected prime quads<br/>    const matchingQuintsTable = {}; // connected prime quint (answer)<br/><br/>    for (let i = 0; i < PRIMES_ARR.length; i++) {<br/>      const prime = PRIMES_ARR[i];<br/>      const newMatchingPairs = {};<br/>      for (let j = 0; j < i; j++) {<br/>        const smallerPrime = PRIMES_ARR[j];<br/>        if (doesMatch(smallerPrime, prime)) {<br/>          newMatchingPairs[`${smallerPrime}\|${prime}`] = true;<br/>        }<br/>      }<br/><br/>      const newMatchingTriples = {};<br/>      const matchingPairs = Object.keys(matchingPairsTable);<br/>      matchingPairs.forEach((pair) => {<br/>        if (pair.split('\|').every(part => newMatchingPairs[`${part}\|${prime}`])) {<br/>          newMatchingTriples[`${pair}\|${prime}`] = true;<br/>        }<br/>      });<br/><br/>      const newMatchingQuads = {};<br/>      const matchingTriples = Object.keys(matchingTriplesTable);<br/>      matchingTriples.forEach((triple) => {<br/>        if (triple.split('\|').every(part => newMatchingPairs[`${part}\|${prime}`])) {<br/>          newMatchingQuads[`${triple}\|${prime}`] = true;<br/>        }<br/>      });<br/><br/>      const newMatchingQuints = {};<br/>      const matchingQuads = Object.keys(matchingQuadsTable);<br/>      matchingQuads.forEach((quad) => {<br/>        if (quad.split('\|').every(part => newMatchingPairs[`${part}\|${prime}`])) {<br/>          newMatchingQuints[`${quad}\|${prime}`] = true;<br/>        }<br/>      });<br/><br/>      Object.assign(matchingPairsTable, newMatchingPairs);<br/>      Object.assign(matchingTriplesTable, newMatchingTriples);<br/>      Object.assign(matchingQuadsTable, newMatchingQuads);<br/>      Object.assign(matchingQuintsTable, newMatchingQuints);<br/><br/>      if (Object.keys(matchingQuintsTable).length) {<br/>        return utils.sumArray(Object.keys(matchingQuintsTable)[0].split('\|').map(x => +x));<br/>      }<br/>    }<br/>    // returns true if a member can be accepted into a family<br/>    function doesMatch(oldPrime, newPrime) {<br/>      const concat1 = concat(+oldPrime, +newPrime);<br/>      const concat2 = concat(+newPrime, +oldPrime);<br/>      return (concat1 > largestGeneratedPrime \|\| concat2 > largestGeneratedPrime<br/>        ? utils.isPrime(concat1) && utils.isPrime(concat2)<br/>        : PRIMES_TABLE[concat1] && PRIMES_TABLE[concat2]);<br/>    }<br/><br/>    function concat(n1, n2) {<br/> (10 ** n2.toString().length) + n2;<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> Find the lowest sum for a set of five primes for which any two primes concatenate to produce another prime. | 26*** | 6898.183ms | [:arrow_upper_right:](https://projecteuler.net/problem=60)<br/><br/>
**61.** [Cyclical figurate numbers](https://github.com/zheng214/euler/blob/master/euler/7/index.js#L2-L118) | module.exports = {<br/>*<br/><br/> Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:<br/><br/> Triangle P3,n=n(n+1)/2  1, 3, 6, 10, 15, ...<br/> Square P4,n=n^2  1, 4, 9, 16, 25, ...<br/> Pentagonal P5,n=n(3n−1)/2   1, 5, 12, 22, 35, ...<br/> Hexagonal P6,n=n(2n−1)   1, 6, 15, 28, 45, ...<br/> Heptagonal P7,n=n(5n−3)/2   1, 7, 18, 34, 55, ...<br/> Octagonal P8,n=n(3n−2)   1, 8, 21, 40, 65, ...<br/><br/> The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.<br/> 1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).<br/> 2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.<br/> 3. This is the only set of 4-digit numbers with this property.<br/><br/>    const polygonalTables = [{}, {}, {}, {}, {}, {}];<br/>    const startingIndexes = [45, 32, 26, 23, 21, 19];<br/>    const polygonGenerators = [<br/> (n + 1) / 2,<br/> n,<br/> (3 * n - 1) / 2,<br/> (2 * n - 1),<br/> (5 * n - 3) / 2,<br/> (3 * n - 2),<br/>    ];<br/><br/>    // table indexed by prefixes<br/>    // constructed such that finding all the polygonals starting with any 2 digits can be done with O(1)<br/>    const prefixLookup = {};<br/><br/>    for (let i = 0; i < startingIndexes.length; i++) {<br/>      const side = i + 3;<br/>      const startingIndex = startingIndexes[i];<br/>      let generatedNumber = 0;<br/>      for (let n = startingIndex; generatedNumber < 10000; n++) {<br/>        generatedNumber = polygonGenerators[i](n);<br/>        const [prefix, suffix] = `${generatedNumber}`.match(/\d{1,2}/g);<br/>        if (suffix.charAt(0) === '0' \|\| generatedNumber > 9999) {<br/>          // third digit is 0, cannot be in a cycle<br/>          continue;<br/>        }<br/>        polygonalTables[i][generatedNumber] = true;<br/><br/>        if (!prefixLookup[prefix]) {<br/>          prefixLookup[prefix] = {};<br/>        }<br/><br/>        if (!prefixLookup[prefix][side]) {<br/>          prefixLookup[prefix][side] = [];<br/>        }<br/><br/>        prefixLookup[prefix][side].push(generatedNumber);<br/>      }<br/>    }<br/><br/>    const octagons = polygonalTables[5];<br/><br/>    // simulate a tree, recursively find a path of length 6<br/>    function findPath(path, acc) {<br/>      // cycle complete<br/>      if (path.length === 6) {<br/>        const first = path[0];<br/>        const last = path[5];<br/>        if (Math.floor(first / 100) === last % 100) {<br/>          // FOUND!<br/>          return path;<br/>        }<br/>        return false;<br/>      }<br/>      const last = path[path.length - 1];<br/><br/>      const suffix = last.toString().match(/\d{1,2}/g)[1];<br/><br/>      // all polygonals starting with the current suffix<br/>      const nextPolygons = prefixLookup[suffix];<br/>      if (!nextPolygons) {<br/>        return false;<br/>      }<br/><br/>      // find the next polygon from all sides which are still missing from the cycle<br/>      const missingSides = Object.keys(acc).filter(key => !acc[key]);<br/>      for (let i = 0; i < missingSides.length; i++) {<br/>        const missingSide = missingSides[i];<br/>        const nextMatchingPolygons = nextPolygons[missingSide];<br/>        if (nextMatchingPolygons) {<br/>          for (let j = 0; j < nextMatchingPolygons.length; j++) {<br/>            const nextPolygon = nextMatchingPolygons[j];<br/>            // if a valid path is found, return it, otherwise keep looping<br/>            const findNextPath = findPath([...path, nextPolygon], { ...acc, [missingSide]: nextPolygon });<br/>            if (findNextPath) {<br/>              return findNextPath;<br/>            }<br/>          }<br/>        }<br/>      }<br/><br/>      // if no polygons are found with none of the missing sides, return false<br/>      return false;<br/>    }<br/><br/>    // we start our path from the octagons to minimize loop count<br/>    for (let o = 0; o < Object.keys(octagons).length; o++) {<br/>      const octagon = +Object.keys(octagons)[o];<br/>      const validPath = findPath([octagon], {<br/>        3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: octagon,<br/>      });<br/>      if (validPath) {<br/>        return utils.sumArray(validPath);<br/>      }<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal,<br/>  heptagonal, and octagonal, is represented by a different number in the set. | 28*** | 1.710ms | [:arrow_upper_right:](https://projecteuler.net/problem=61)<br/><br/>
**62.** [Cubic permutations](https://github.com/zheng214/euler/blob/master/euler/7/index.js#L120-L150) | <br/>*<br/><br/> The cube, 41063625 (345^3), can be permuted to produce two other cubes: 56623104 (384^3) and 66430125 (405^3).<br/> In fact, 41063625 is the smallest cube which has exactly three permutations of its digits which are also cube.<br/><br/>    // we generate a cube, sort its digits, and index it<br/>    // whenever an index has length 5, return result<br/>    const cubeClasses = {};<br/><br/>    let base = 1;<br/>    let found = false;<br/>    while (!found) {<br/>* 3;<br/>      const sortedKey = cube.toString().split('').sort().join('');<br/>      if (!cubeClasses[sortedKey]) {<br/>        cubeClasses[sortedKey] = [cube];<br/>      } else {<br/>        cubeClasses[sortedKey].push(cube);<br/>      }<br/><br/>      if (cubeClasses[sortedKey].length > 4) {<br/>        found = true;<br/>        return cubeClasses[sortedKey][0];<br/>      }<br/>      base++;<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> Find the smallest cube for which exactly five permutations of its digits are cube. | 127035****** | 25.525ms | [:arrow_upper_right:](https://projecteuler.net/problem=62)<br/><br/>
**63.** [Powerful digit counts](https://github.com/zheng214/euler/blob/master/euler/7/index.js#L152-L180) | <br/>*<br/><br/> The 5-digit number, 16807=7^5, is also a fifth power. Similarly, the 9-digit number, 134217728=8^9, is a ninth power.<br/>    let answer = 0;<br/><br/>    // we reach the limit when the number of digits of 9^n is smaller than n<br/>    let limitReached = false;<br/>    let exponent = 1;<br/><br/>    while (!limitReached) {<br/>      for (let digit = 9; digit > 0; digit--) {<br/>* exponent;<br/>        const digitCount = power.toString().length;<br/>        if (digitCount < exponent) {<br/>          if (digit === 9) {<br/>            limitReached = true;<br/>            return answer;<br/>          }<br/>          break;<br/>        }<br/>        answer++;<br/>      }<br/>      exponent++;<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> How many n-digit positive integers exist which are also an nth power? | 4* | 0.353ms | [:arrow_upper_right:](https://projecteuler.net/problem=63)<br/><br/>
**64.** [Odd period square roots](https://github.com/zheng214/euler/blob/master/euler/7/index.js#L182-L241) | <br/>*<br/><br/> [tldr; Generate the leading digits of the continued fraction form of the square roots and detect repeating digits](https://projecteuler.net/problem=64)<br/>    const squares = [...Array(100)].reduce((acc, _, i) => {<br/>* 2] = true;<br/>      return acc;<br/>    }, {});<br/><br/>    let answer = 0;<br/><br/>    for (let N = 2; N < 10000; N++) {<br/>      if (squares[N]) {<br/>        continue;<br/>      }<br/><br/>      // we generate the sequence of isolated integers (ie. leading numbers in the continued fraction sequence) by<br/>      // 1. Normalizing our irrational fraction (ie. `numerator / (root - offset)`) by multiplying by `(root + offset)/(root + offset)`<br/>      // 2. Isolating the next leading integer by finding the integral part of our normalized fraction<br/>      // 3. flip the fractional part to use for the next iteration<br/>      const root = Math.sqrt(N);<br/>      const floor = Math.floor(root);<br/><br/>      let repetitionFound = false; // if a repetition has been found, we can exit the loop (explained below)<br/><br/>      // the following variables are updated on every iteration<br/>      let period = 0; // period count<br/><br/>      let isolatedInteger = floor; // leading digit of our current iteration<br/>      let normalizedDenominator; // the denominator as a result of normalization<br/>      let initialNumerator = 1; // the normalized and reduced denominator (by the initial numerator) of the previous iteration<br/>      let denominatorOffset = floor; // the offset found in the denominator as a result of isolating the leading integer from the previous iteration<br/><br/>      while (!repetitionFound) {<br/>        // normalize<br/>* 2);<br/><br/>        // isolate<br/> (floor + denominatorOffset) / normalizedDenominator);<br/>        period++;<br/>        if (normalizedDenominator === initialNumerator) {<br/>          // the initialNumerator always starts with 1<br/>          // if the above two variables are equal, then the next initialNumerator will be 1, which will cause the cycle to repeat<br/>          repetitionFound = true;<br/>          if (period & 1) {<br/>            answer++;<br/>          }<br/>          break;<br/>        }<br/><br/>        // update for next iteration<br/>        initialNumerator = normalizedDenominator / initialNumerator;<br/> isolatedInteger);<br/>      }<br/>    }<br/>    return answer;<br/>  },<br/><br/> <strong>Question:</strong> How many continued fractions for N≤10000 have an odd period? | 13** | 6.930ms | [:arrow_upper_right:](https://projecteuler.net/problem=64)<br/><br/>
**65.** [Convergents of e](https://github.com/zheng214/euler/blob/master/euler/7/index.js#L243-L272) | <br/>*<br/> [tldr; Find ith element from a sequence of partial continued fraction](https://projecteuler.net/problem=65)<br/><br/>    function getNthLeadingInteger(n) {<br/>      if (n < 3) {<br/>        return n;<br/>      }<br/><br/>      if (n % 3 === 2) {<br/> (Math.floor(n / 3) + 1);<br/>      }<br/><br/>      return 1;<br/>    }<br/><br/>    const target = 100;<br/>    let numerator = 1;<br/>    let denominator = getNthLeadingInteger(target - 1);<br/>    for (let i = target - 1; i >= 1; i--) {<br/>      const nextLeadingInteger = getNthLeadingInteger(i - 1);<br/> BigInt(denominator) + BigInt(numerator)];<br/>    }<br/><br/> 2n); // add leading constant<br/>    return utils.sumArray(numerator.toString().split(''), n => +n);<br/>  },<br/><br/> <strong>Question:</strong> Find the sum of digits in the numerator of the 100th convergent of the continued fraction e | 2** | 0.598ms | [:arrow_upper_right:](https://projecteuler.net/problem=65)<br/><br/>
**66.** [Diophantine equation](https://github.com/zheng214/euler/blob/master/euler/7/index.js#L274-L367) | <br/>*<br/><br/> Consider quadratic Diophantine equations of the form: x^2 - D * y^2 = 1<br/> For example, when D=13, the minimal solution in x is 649^2 – 13×180^2 = 1.<br/> It can be assumed that there are no solutions in positive integers when D is square.<br/><br/> By finding minimal solutions in x for D = {2, 3, 5, 6, 7}, we obtain the following:<br/><br/> 3^2 – 2×2^2 = 1<br/> 2^2 – 3×1^2 = 1<br/> 9^2 – 5×4^2 = 1<br/> 5^2 – 6×2^2 = 1<br/> 8^2 – 7×3^2 = 1<br/> Hence, by considering minimal solutions in x for D ≤ 7, the largest x is obtained when D=5.<br/><br/>    // to solve for (x,y) for any D, we need to:<br/>    // 1. find the sequence of leading digits for the continued fractions of sqrt(D)<br/>    // 2. from the list above, expand continued fractions until a solution is found<br/><br/>    let largestSolution = 0n;<br/>    let ANSWER = 0;<br/>    // we combine the previous 2 solutions to achieve the steps above<br/>    for (let D = 2; D <= 1000; D++) {<br/>      // find leading digits<br/>      const sqrt = Math.sqrt(D);<br/>      const floor = Math.floor(sqrt);<br/>      if (sqrt === floor) {<br/>        continue;<br/>      }<br/>      let repetitionFound = false; // if a repetition has been found, we can exit the loop (explained below)<br/><br/>      // Step 1: Sequence of leading digits<br/>      const leadingDigits = [];<br/><br/>      let isolatedInteger = floor; // leading digit of our current iteration<br/>      let normalizedDenominator; // the denominator as a result of normalization<br/>      let initialNumerator = 1; // the normalized and reduced denominator (by the initial numerator) of the previous iteration<br/>      let denominatorOffset = floor; // the offset found in the denominator as a result of isolating the leading integer from the previous iteration<br/><br/>      while (!repetitionFound) {<br/>        // normalize<br/>* 2);<br/><br/>        // isolate<br/> (floor + denominatorOffset) / normalizedDenominator);<br/>        leadingDigits.push(isolatedInteger);<br/>        if (normalizedDenominator === initialNumerator) {<br/>          // the initialNumerator always starts with 1<br/>          // if the above two variables are equal, then the next initialNumerator will be 1, which will cause the cycle to repeat<br/>          repetitionFound = true;<br/>          break;<br/>        }<br/><br/>        // update for next iteration<br/>        initialNumerator = normalizedDenominator / initialNumerator;<br/> isolatedInteger);<br/>      }<br/><br/>      // Step 2: search for solution<br/><br/>      // solution verifier<br/>* BigInt(2)) - (BigInt(D) * (y ** BigInt(2)))) === BigInt(1));<br/>      // returns nth leading integer in the continued fraction expansion of sqrt(D)<br/>      const getNthLeadingInteger = n => leadingDigits[(n - 1) % leadingDigits.length];<br/><br/>      // initial values<br/>      let target = 1;<br/>      let numerator = BigInt(1);<br/>      let denominator = BigInt(getNthLeadingInteger(target));<br/><br/>      // loop while a solution is not found<br/>      while (!isSolution(numerator, denominator)) {<br/>        numerator = BigInt(1);<br/>        denominator = BigInt(getNthLeadingInteger(target));<br/>        // find the convergent at the `target` index by using backtracking<br/>        for (let i = target - 1; i >= 1; i--) {<br/>          const nextLeadingInteger = getNthLeadingInteger(i);<br/> BigInt(denominator) + BigInt(numerator)];<br/>        }<br/> BigInt(floor));<br/>        target++;<br/>      }<br/><br/>      if (numerator > largestSolution) {<br/>        largestSolution = numerator;<br/>        ANSWER = D;<br/>      }<br/>    }<br/>    return ANSWER;<br/>  },<br/><br/> <strong>Question:</strong> Find the value of D ≤ 1000 in minimal solutions of x for which the largest value of x is obtained. | 6** | 36.278ms | [:arrow_upper_right:](https://projecteuler.net/problem=66)<br/><br/>
**67.** [Maximum Path Sum II](https://github.com/zheng214/euler/blob/master/euler/7/index.js#L369-L422) | <br/>*<br/><br/> By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.<br/><br/>    3<br/>   7 4<br/>  2 4 6<br/> 8 5 9 3<br/><br/> That is, 3 + 7 + 4 + 9 = 23.<br/><br/>    const rows = fs.readFileSync(path.join(__dirname, './p067_triangle.txt'))<br/>      .toString()<br/>      .split('\n')<br/>      .map(row => row.split(' ').map(Number));<br/><br/>    // keeps track of the maximum score from the top to each number in the previous row<br/>    let previousRowScores = [];<br/><br/>    rows.forEach((row, rowIndex) => {<br/>      const currentRowScores = [];<br/>      row.forEach((number, position) => {<br/>        const isFirst = position === 0;<br/>        const isLast = position === row.length - 1;<br/>        if (rowIndex === 0) {<br/>          // first row: score is just the number<br/>          currentRowScores[0] = number;<br/>        } else if (isFirst) {<br/>          // first number of row: score is the score of the first element of previous row + this number<br/>          currentRowScores[0] = previousRowScores[0] + number;<br/>        } else if (isLast) {<br/>          // last number of row: same as above<br/>          currentRowScores[position] = previousRowScores[position - 1] + number;<br/>        } else {<br/>          const leftParent = previousRowScores[position - 1];<br/>          const rightParent = previousRowScores[position];<br/>          if (leftParent > rightParent) {<br/>            // if the number is in the middle of a row (not first nor last), simply check which 'parent' is larger<br/>            currentRowScores[position] = number + leftParent;<br/>          } else {<br/>            currentRowScores[position] = number + rightParent;<br/>          }<br/>        }<br/>      });<br/>      previousRowScores = currentRowScores;<br/>    });<br/><br/>    return Math.max(...previousRowScores);<br/>  },<br/><br/> <strong>Question:</strong> Find the maximum total from top to bottom in [triangle.txt]((https://github.com/zheng214/euler/blob/master/euler/7/p067_triangle.txt)),<br/>  a 15K text file containing a triangle with one-hundred rows. | 72** | 1.836ms | [:arrow_upper_right:](https://projecteuler.net/problem=67)<br/><br/>
**68.** [Magic 5-gon ring](https://github.com/zheng214/euler/blob/master/euler/7/index.js#L424-L524) | <br/>*<br/><br/> [tldr; solving magic square variants](https://projecteuler.net/problem=68)<br/><br/>    // The first step consists of generating the list of permutations of digits in the inner and outer ring<br/>    const DIGITS = [1, 2, 3, 4, 5, 6, 7, 8, 9];<br/>    const innerPermutations = [];<br/>    const outerPermutations = [];<br/>    for (let i1 = 1; i1 <= 5; i1++) {<br/>      for (let i2 = i1 + 1; i2 <= 6; i2++) {<br/>        for (let i3 = i2 + 1; i3 <= 7; i3++) {<br/>          for (let i4 = i3 + 1; i4 <= 8; i4++) {<br/>            for (let i5 = i4 + 1; i5 <= 9; i5++) {<br/>              const innerRing = [i1, i2, i3, i4, i5];<br/>              innerPermutations.push(innerRing);<br/>              outerPermutations.push(DIGITS.filter(x => !innerRing.includes(x)));<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/><br/>    let maxSolution = 0;<br/>    // then, for each permutation, we check if it is a legitimate solution with the helper function below<br/>    for (let i = 0; i < innerPermutations.length; i++) {<br/>      const leadingDigit = innerPermutations[i][0];<br/>      const basePermutation = innerPermutations[i].slice(1);<br/>      const outerDigits = outerPermutations[i];<br/>      for (let j = 1; j <= 24; j++) {<br/>        const currentPermutation = utils.getLexicographicPermutation(basePermutation, j).map(Number);<br/>        currentPermutation.unshift(leadingDigit);<br/>        const commonSum = findSolution(currentPermutation, outerDigits);<br/>        if (commonSum) {<br/>          // if a soution is found, find maximal string corresponding to that solution<br/>          // first, find the index of the inner ring adjacent to the smallest outer digit<br/>          const innerStartIndex = currentPermutation.findIndex((permDigit, permIndex) => {<br/>            const currentInnerDigit = permDigit;<br/>            const nextInnerDigit = currentPermutation[(permIndex + 1) % 5];<br/>            return currentInnerDigit + nextInnerDigit === commonSum - outerDigits[0];<br/>          });<br/><br/>          // then we go around the inner ring (clockwise) and preppend the corresponding outer digit<br/>          let solutionString = '';<br/>          for (let k = 0; k <= 4; k++) {<br/>            const currentInnerRingDigit = currentPermutation[(innerStartIndex + k) % 5];<br/>            const nextInnerRingDigit = currentPermutation[(innerStartIndex + k + 1) % 5];<br/>            const currentSum = currentInnerRingDigit + nextInnerRingDigit;<br/>            const correspondingOuterDigit = commonSum - currentSum;<br/>            solutionString += `${correspondingOuterDigit}${currentInnerRingDigit}${nextInnerRingDigit}`;<br/>          }<br/>          const solution = +solutionString;<br/>          if (solution > maxSolution) {<br/>            maxSolution = solution;<br/>          }<br/>        }<br/>      }<br/>    }<br/><br/>    return maxSolution;<br/><br/>    // given a sequence of inner ring, return the common sum if a solution exists, false otherwise<br/>    function findSolution(inner, outer) {<br/>      // we go around the inner ring and extract all the sums of adjacent digits<br/>      const sumsToTest = [...inner].reduce(<br/>        (acc, curr, idx, arr) => {<br/>          const nextIndex = idx === 4 ? 0 : idx + 1;<br/>          const sum = curr + inner[nextIndex];<br/>          if (acc[sum]) {<br/>            // if there are duplicate sums in the inner ring, a solution cannot exist as the outer ring numbers are all disinct<br/>            arr.splice(1);<br/>            return null;<br/>          }<br/>          acc[sum] = true;<br/>          return acc;<br/>        },<br/>        {},<br/>      );<br/><br/>      if (!sumsToTest) { // duplicate sums detected<br/>        return false;<br/>      }<br/><br/>      // the digits of the outer ring are sorted from smallest to largest by design<br/>      // therefore we sort the sums of the inner ring from largest to smallest<br/>      const partialSums = Object.keys(sumsToTest).map(Number).sort((a, b) => b - a);<br/>      const SOLUTION_SUM = partialSums[4] + 10; // smallest inner sum + 10<br/><br/>      // we check if adding the corresponding index of the outer ring will result in the solution sum<br/>      for (let i = 0; i <= 3; i++) {<br/>        if (partialSums[i] + outer[i] !== SOLUTION_SUM) {<br/>          return false;<br/>        }<br/>      }<br/><br/>      return SOLUTION_SUM;<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> What is the maximum 16-digit string for a "magic" 5-gon ring? | 65310319******** | 16.153ms | [:arrow_upper_right:](https://projecteuler.net/problem=68)<br/><br/>
**69.** [Totient Maximum](https://github.com/zheng214/euler/blob/master/euler/7/index.js#L526-L567) | <br/>*<br/><br/> Euler's Totient function, φ(n) [sometimes called the phi function], is used to determine the number of numbers less than n which are relatively prime to n.<br/> For example, as 1, 2, 4, 5, 7, and 8, are all less than nine and relatively prime to nine, φ(9)=6.<br/><br/> For n ≤ 10, n = 6 produces a maximum n/φ(n).<br/>    // we use the Euler's formula for the totient function for all n <= 1 million<br/>    // we start with n, and for each prime p divisible by n, we multiply by ((p - 1) / p)<br/>    // the intuition is as follows:<br/>    // let's take the number 60, which has prime divisors 2, 3, 5<br/> 1/2 = 30;<br/> 2/3 = 20;<br/> 4/5 = 16;<br/>    // indeed, the numbers (<60) relatively prime to 60 are the numbers which are not divisible by 2, 3, or 5, and there are 16 of them<br/><br/>    // we also use a heuristic to cut down a majority of numbers to test:<br/>    // since we want to maximize n/phi(n), we need to find a number which is highly divisible<br/>    // we do that by MAXIMIZING the number of PRIME divisors, and by MINIMIZING the number itself<br/>    // therefore, we search incrementally with products of prime numbers from smallest to largest, and we stop if the product exceeds 1 million<br/>3, 2*3*5, 2*3*5*7, etc.<br/>    const PRIMES_TABLE = utils.generatePrimeTable(100); // product of primes < 100 is guaranteed to exceed 1 million<br/>    const PRIMES_ARR = Object.keys(PRIMES_TABLE).map(Number);<br/>    let maxTotient = 0;<br/>    let maxTotientNumber = 0;<br/>    for (let i = 0; i < PRIMES_ARR.length; i++) {<br/>      const factors = PRIMES_ARR.slice(0, i + 1);<br/> c, 1);<br/>      if (product > 1000000) {<br/>        break;<br/>      }<br/> c / (c - 1), 1); // shortcut to calculate n/phi(n)<br/>      if (reverseTotient > maxTotient) {<br/>        maxTotient = reverseTotient;<br/>        maxTotientNumber = product;<br/>      }<br/>    }<br/>    return maxTotientNumber;<br/>  },<br/><br/> <strong>Question:</strong> Find the value of n ≤ 1,000,000 for which n/φ(n) is a maximum. | 510*** | 0.578ms | [:arrow_upper_right:](https://projecteuler.net/problem=69)<br/><br/>
**70.** [Totient permutation](https://github.com/zheng214/euler/blob/master/euler/7/index.js#L569-L615) | <br/>*<br/> Euler's Totient function, φ(n), is used to determine the number of positive numbers less than or equal to n which are relatively prime to n.<br/> For example, as 1, 2, 4, 5, 7, and 8, are all less than nine and relatively prime to nine, φ(9)=6.<br/> The number 1 is considered to be relatively prime to every positive number, so φ(1)=1.<br/> Interestingly, φ(87109)=79180, and it can be seen that 87109 is a permutation of 79180.<br/>    // to minimize n/phi(n), we need to maximize phi(n), ie. we need to find n which is not highly divisible<br/>    // n cannot be prime as phi(n) = n - 1, and n and n - 1 cannot have the same digits<br/><br/>    // NOTE:<br/>    // let p1, p2, ... pm denote the prime factors of n<br/> p2/(p2-1) * p3/(p3-1) * ... * pm/(pm-1) (1)<br/>    // in order to minimize the equation above, we need to minimize the number of terms (as each term > 1)<br/>    // and also minimize each term by maximizing the value of the prime factors<br/>    const PRIMES_TABLE = utils.generatePrimeTable(10000);<br/>    // this number is chosen with the confidence that the minimal ratio < 1.001<br/>    const PRIMES_ARR = Object.keys(PRIMES_TABLE).reverse().map(Number);<br/>    let minimalTotientRatio = 1.001; // arbitrarily large number<br/>    let minimalTotientNumber = 0;<br/>    for (let i = 0; i < PRIMES_ARR.length - 1; i++) {<br/>      const p1 = PRIMES_ARR[i];<br/>      const phi1 = p1 / (p1 - 1);<br/>      if (phi1 > minimalTotientRatio) {<br/>        break;<br/>      }<br/>      for (let j = PRIMES_ARR.findIndex(x => x < 10000000 / p1); j < PRIMES_ARR.length; j++) {<br/>        const p2 = PRIMES_ARR[j];<br/>        const phi2 = p2 / (p2 - 1);<br/>        if (phi2 > minimalTotientRatio) {<br/>          break;<br/>        }<br/> p2;<br/> (p2 - 1);<br/>        if (utils.haveSameDigits([result, phi])) {<br/>          const totientRatio = result / phi;<br/>          if (totientRatio < minimalTotientRatio) {<br/>            minimalTotientRatio = totientRatio;<br/>            minimalTotientNumber = result;<br/>          }<br/>        }<br/>      }<br/>    }<br/>    return minimalTotientNumber;<br/>  },<br/><br/> <strong>Question:</strong> Find the value of n, 1 < n < 107, for which φ(n) is a permutation of n and the ratio n/φ(n) produces a minimum. | 831**** | 762.765ms | [:arrow_upper_right:](https://projecteuler.net/problem=70)<br/><br/>
**71.** [Ordered fractions](https://github.com/zheng214/euler/blob/master/euler/8/index.js#L2-L37) | module.exports = {<br/>*<br/><br/> Consider the fraction, n/d, where n and d are positive integers.<br/> If n<d and HCF(n,d)=1, it is called a reduced proper fraction.<br/><br/> If we list the set of reduced proper fractions for d ≤ 8 in ascending order of size, we get:<br/> 1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8<br/><br/> It can be seen that 2/5 is the fraction immediately to the left of 3/7.<br/>    // for each d <= 1,000,000, we just need to find maximal integer c such that c/d is smaller than 3/7<br/>    // we accomplish this by multiplying d by 3/7, and taking the floor of the result<br/>    // if the result is divisible by the floor of the result, we can skip to the next d<br/>    // if not, the difference between the result and the floor of the result is indicative of how close the result is to 3/7<br/> 3/7 - floor(d * 3/7))/d<br/>    const FRACTION = 3 / 7;<br/>    let smallestDiff = 1;<br/>    const answer = {};<br/>    for (let d = 1; d <= 1000000; d++) {<br/>      if (d % 7 === 0) {<br/>        continue;<br/>      }<br/> FRACTION;<br/>      const floor = Math.floor(res);<br/>      const diff = (res - floor) / d;<br/>      if (diff < smallestDiff) {<br/>        smallestDiff = diff;<br/>        answer.numerator = floor;<br/>        answer.denominator = d;<br/>      }<br/>    }<br/>    return answer.numerator;<br/>  },<br/><br/> <strong>Question:</strong> By listing the set of reduced proper fractions for d ≤ 1,000,000 in ascending order, find the numerator of the fraction immediately to the left of 3/7. | 428*** | 5.353ms | [:arrow_upper_right:](https://projecteuler.net/problem=71)<br/><br/>
**72.** [Counting fractions](https://github.com/zheng214/euler/blob/master/euler/8/index.js#L39-L80) | <br/>*<br/><br/> Consider the fraction, n/d, where n and d are positive integers.<br/> If n<d and HCF(n,d)=1, it is called a reduced proper fraction.<br/><br/> If we list the set of reduced proper fractions for d ≤ 8 in ascending order of size, we get:<br/> 1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8<br/><br/> It can be seen that there are 21 elements in this set.<br/>    // we are basically calculating phi(2) + ... + phi(1,000,000)<br/> (f2 - 1) / f2 + ... + (fm - 1) / fm<br/>    // where f1, f2, ..., fm are the prime factors of n<br/><br/>    // we start by generating all prime numbers below 1000000<br/> 2, p * 3, etc.<br/>    // by multiplying each number by (p - 1) / p<br/>    // eventually each integer below 1000000 will be sieved once by each of its prime factors<br/>    const target = 1000000;<br/>    const PRIME_TABLE = utils.generatePrimeTable(target);<br/>    const INTEGER_TABLE = { ...PRIME_TABLE };<br/>    let answer = 0;<br/>    for (let i = 2; i <= target; i++) {<br/>      if (PRIME_TABLE[i]) {<br/>        answer += i - 1;<br/> j <= target; j++) {<br/> j]) {<br/> j] = INTEGER_TABLE[i * j] * (i - 1) / i;<br/>          } else {<br/> j] = j * (i - 1);<br/>          }<br/>        }<br/>      } else {<br/>        answer += INTEGER_TABLE[i];<br/>      }<br/>    }<br/><br/>    return answer;<br/>  },<br/><br/> <strong>Question:</strong> How many elements would be contained in the set of reduced proper fractions for d ≤ 1,000,000? | 304017****** | 229.372ms | [:arrow_upper_right:](https://projecteuler.net/problem=72)<br/><br/>
**73.** [Counting fractions in a range](https://github.com/zheng214/euler/blob/master/euler/8/index.js#L82-L111) | <br/>*<br/><br/> Consider the fraction, n/d, where n and d are positive integers.<br/> If n<d and HCF(n,d)=1, it is called a reduced proper fraction.<br/><br/> If we list the set of reduced proper fractions for d ≤ 8 in ascending order of size, we get:<br/> 1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8<br/><br/> It can be seen that there are 3 fractions between 1/3 and 1/2.<br/>    let answer = 0;<br/>    for (let d = 4; d <= 12000; d++) {<br/>      const lower = d / 3;<br/>      const upper = d / 2;<br/>      const lbNumerator = Number.isInteger(lower) ? lower + 1 : Math.ceil(lower); // proper lower bound<br/>      const ubNumerator = Number.isInteger(upper) ? upper - 1 : Math.floor(upper); // proper upper bound<br/>      if (lbNumerator > ubNumerator) {<br/>        continue;<br/>      }<br/>      for (let n = lbNumerator; n <= ubNumerator; n++) {<br/>        if (utils.gcd(n, d) === 1) {<br/>          answer++;<br/>        }<br/>      }<br/>    }<br/>    return answer;<br/>  },<br/><br/> <strong>Question:</strong> How many fractions lie between 1/3 and 1/2 in the sorted set of reduced proper fractions for d ≤ 12,000? | 729**** | 944.184ms | [:arrow_upper_right:](https://projecteuler.net/problem=73)<br/><br/>
**74.** [Digit factorial chains](https://github.com/zheng214/euler/blob/master/euler/8/index.js#L113-L195) | <br/>*<br/><br/> The number 145 is well known for the property that the sum of the factorial of its digits is equal to 145:<br/> 1! + 4! + 5! = 1 + 24 + 120 = 145<br/><br/> Perhaps less well known is 169, in that it produces the longest chain of numbers that link back to 169;<br/> it turns out that there are only three such loops that exist:<br/> 169 → 363601 → 1454 → 169<br/> 871 → 45361 → 871<br/> 872 → 45362 → 872<br/><br/> It is not difficult to prove that EVERY starting number will eventually get stuck in a loop. For example,<br/> 69 → 363600 → 1454 → 169 → 363601 (→ 1454)<br/> 78 → 45360 → 871 → 45361 (→ 871)<br/> 540 → 145 (→ 145)<br/><br/> Starting with 69 produces a chain of five non-repeating terms, but the longest non-repeating chain with a starting number below one million is sixty terms.<br/><br/>    const FACTS = {<br/>      0: 1,<br/>      1: 1,<br/>      2: 2,<br/>      3: 6,<br/>      4: 24,<br/>      5: 120,<br/>      6: 720,<br/>      7: 5040,<br/>      8: 40320,<br/>      9: 362880,<br/>    };<br/><br/>    // giant memoized table of all the numbers and their chain length<br/>    const MEM = {};<br/>    // NOTE: it is true that different numbers with the same digits will have the same chain length.<br/>    // However, it will not reduce the running time by much, as all the numbers with the same digit<br/>    // will find their memoized entry within one depth of the recurrence.<br/>    // Furthermore, the time saved will be recompensed by the sorting of the digits<br/>    // (tested: on average, the sorting method is slightly slower)<br/><br/>    // However, this is a good method if we want to save space<br/><br/>    const sumFactDigits = n => n.toString().split('').reduce((a, c) => a + FACTS[c], 0);<br/><br/>    function computePathLength(n, accMem = {}, chainLength = 0) {<br/>      if (MEM[n]) {<br/>        Object.keys(accMem).forEach((chainElem) => {<br/>          MEM[chainElem] = MEM[n] + chainLength - accMem[chainElem];<br/>        });<br/>        return chainLength + MEM[n];<br/>      }<br/><br/>      if (accMem[n]) {<br/>        const recurrencePeriod = chainLength - accMem[n];<br/>        Object.keys(accMem).forEach((chainElem) => {<br/>          if (accMem[chainElem] < accMem[n]) {<br/>            MEM[chainElem] = chainLength - accMem[chainElem];<br/>          } else {<br/>            MEM[chainElem] = recurrencePeriod;<br/>          }<br/>        });<br/>        return chainLength;<br/>      }<br/><br/>      const next = sumFactDigits(n);<br/>      if (next === n) {<br/>        return 1;<br/>      }<br/>      return computePathLength(next, { ...accMem, [n]: chainLength }, chainLength + 1);<br/>    }<br/><br/>    let res = 0;<br/>    for (let n = 1; n < 1000000; n++) {<br/>      const chainLength = computePathLength(n);<br/>      if (chainLength === 60) {<br/>        res++;<br/>      }<br/>    }<br/>    return res;<br/>  },<br/><br/> <strong>Question:</strong> How many chains, with a starting number below one million, contain exactly sixty non-repeating terms? | 4** | 1067.985ms | [:arrow_upper_right:](https://projecteuler.net/problem=74)<br/><br/>
**75.** [Singular integer right triangles](https://github.com/zheng214/euler/blob/master/euler/8/index.js#L197-L250) | <br/>*<br/><br/> It turns out that 12 cm is the smallest length of wire that can be bent to form an integer sided right angle<br/> triangle in exactly one way, but there are many more examples.<br/><br/> 12 cm: (3,4,5)<br/> 24 cm: (6,8,10)<br/> 30 cm: (5,12,13)<br/> 36 cm: (9,12,15)<br/> 40 cm: (8,15,17)<br/> 48 cm: (12,16,20)<br/><br/> In contrast, some lengths of wire, like 20 cm, cannot be bent to form an integer sided right angle triangle,<br/> and other lengths allow more than one solution to be found; for example, using 120 cm it is possible to form<br/> exactly three different integer sided right angle triangles.<br/><br/> 120 cm: (30,40,50), (20,48,52), (24,45,51)<br/><br/>    // keys are the length, value are how many time it has been sieved<br/>    const TRIANGLE_LENGTH_TABLE = {};<br/>    const target = 1500000;<br/>    // we first generate the table of primitive pythagorean triplets<br/>    for (let n = 1; n < 612; n++) {<br/>      for (let m = n + 1; m <= target; m++) {<br/> m * (n + m);<br/>        if (perimeter > target) {<br/>          break;<br/>        }<br/>        const isCoprime = utils.gcd(m, n) === 1;<br/>        const isPrimitive = isCoprime && (utils.isEven(m) \|\| utils.isEven(n));<br/>        if (isPrimitive) {<br/>          TRIANGLE_LENGTH_TABLE[perimeter] = 1;<br/>        }<br/>      }<br/>    }<br/><br/>    // for each generated triplet, we sieve all the multiples of that perimeter<br/>    const primitivePerimeters = Object.keys(TRIANGLE_LENGTH_TABLE).map(Number);<br/>    for (let i = 0; i < primitivePerimeters.length; i++) {<br/>      const primitive = primitivePerimeters[i];<br/> k <= target; k++) {<br/> k] = TRIANGLE_LENGTH_TABLE[primitive * k]<br/> k] + 1<br/>          : 1;<br/>      }<br/>    }<br/><br/>    // at the end, for each perimeter, if it has value 1 (ie. it has been sieved exactly once), then it fits the condition<br/>    return Object.keys(TRIANGLE_LENGTH_TABLE).filter(p => TRIANGLE_LENGTH_TABLE[p] === 1).length;<br/>  },<br/><br/> <strong>Question:</strong> Given that L is the length of the wire, for how many values of L ≤ 1,500,000 can exactly one integer sided right angle triangle be formed? | 161*** | 207.461ms | [:arrow_upper_right:](https://projecteuler.net/problem=75)<br/><br/>
**76.** [Counting summations](https://github.com/zheng214/euler/blob/master/euler/8/index.js#L252-L286) | <br/>*<br/><br/> It is possible to write five as a sum in exactly six different ways:<br/><br/> 4 + 1<br/> 3 + 2<br/> 3 + 1 + 1<br/> 2 + 2 + 1<br/> 2 + 1 + 1 + 1<br/> 1 + 1 + 1 + 1 + 1<br/><br/>    // this is similar to the change making problem<br/>    // we have 100 coins of value 1, 2 ... 100<br/>    // the question is how to make 100 with those coins<br/>    const MEM = {};<br/>    for (let i = 1; i <= 100; i++) {<br/>      // we do not have to consider j < i as there would be no way of making j with a coin i<br/>      // from this point, MEM[n] denotes the number of ways of making n using coins up to i<br/>      for (let j = i; j <= 100; j++) {<br/>        // the number of ways to make amount j is equal to the sum of<br/>        // 1. the number of ways of making j without using i,<br/>        // which is the number of ways of making change j using coins 1, ..., i - 1<br/>        // which is equal to MEM[j] of the previous iteration<br/>        // 2. the number of ways of making j using i,<br/>        // which is the number of ways of making j - i using 1, 2, ..., i<br/>        // if MEM[j - i] is undefined, it means  j = i, and the answer is 1<br/>        MEM[j] = (MEM[j] \|\| 0) + (MEM[j - i] \|\| 1);<br/>      }<br/>    }<br/>    return MEM[100] - 1;<br/>  },<br/><br/> <strong>Question:</strong> How many different ways can one hundred be written as a sum of at least two positive integers? | 1905***** | 0.414ms | [:arrow_upper_right:](https://projecteuler.net/problem=76)<br/><br/>
**77.** [Prime summations](https://github.com/zheng214/euler/blob/master/euler/8/index.js#L288-L337) | <br/>*<br/> It is possible to write ten as the sum of primes in exactly five different ways:<br/><br/> 7 + 3<br/> 5 + 5<br/> 5 + 3 + 2<br/> 3 + 3 + 2 + 2<br/> 2 + 2 + 2 + 2 + 2<br/><br/>    // from problem above, i = 30 was sufficient to generate > 5000 partitions<br/>    // in order to minimize space and time, we will use 46 primes as an upper bound, and increase if necessary<br/>    const PRIMES = Object.keys(utils.generatePrimeTable(200)).map(Number);<br/>    let answer = 0;<br/>    let I = 2;<br/><br/>    // each key is of the form a\|b, and the value is the number of partitions of a using primes smaller or equal to b<br/>    const MEM = { };<br/>    while (!answer) {<br/>      for (let i = 2; i <= I; i++) {<br/>        for (let j = 0; j < PRIMES.length; j++) {<br/>          const prime = PRIMES[j];<br/>          if (prime > i) {<br/>            MEM[`${i}\|${prime}`] = MEM[`${i}\|${PRIMES[j - 1]}`];<br/>            continue;<br/>          }<br/>          if (j === 0) {<br/>            MEM[`${i}\|${prime}`] = utils.isEven(i) ? 1 : 0;<br/>            continue;<br/>          }<br/>          const usingPrime = MEM[`${i - prime}\|${prime}`] \|\| (i === prime ? 1 : 0);<br/>          const notUsing = MEM[`${i}\|${PRIMES[j - 1]}`] \|\| 0;<br/>          if (notUsing + usingPrime > 5000) {<br/>            MEM[`${i}\|${prime}`] = notUsing + usingPrime;<br/>            answer = i;<br/>            break;<br/>          }<br/>          MEM[`${i}\|${prime}`] = notUsing + usingPrime;<br/>        }<br/>        if (answer) {<br/>          break;<br/>        }<br/>      }<br/>      I++;<br/>    }<br/>    return answer;<br/>  },<br/><br/> <strong>Question:</strong> What is the first value which can be written as the sum of primes in over five thousand different ways? | 7* | 29.370ms | [:arrow_upper_right:](https://projecteuler.net/problem=77)<br/><br/>
**78.** [Coin Partitions](https://github.com/zheng214/euler/blob/master/euler/8/index.js#L339-L387) | <br/>*<br/><br/> Let p(n) represent the number of different ways in which n coins can be separated into piles.<br/> For example, five coins can be separated into piles in exactly seven different ways, so p(5)=7.<br/><br/>    // using the pentagonal number theorem, we can use the following recurrence relationship<br/>    // let p(n) denote the number of partitions of n<br/>    // p(n) = p(n - 1) + p(n - 2) - p(n - 5) - p(n - 7) + p(n - 12) + p(n - 17) - ...<br/>    // the subtracted indices are defined as the generalized pentagonal numbers starting at index 1<br/>    let answer = 0;<br/>    let n = 3;<br/>    // memoized partition list MEM[i] = p(i)<br/>    const MEM = [1, 1, 2];<br/>    while (!answer) {<br/>      let i = 1;<br/>      let term = penta(i);<br/>      let currentPartition = 0;<br/>      // sum all terms p(n-1), p(n-2), p(n-5), etc.<br/>      while (term <= n) {<br/>        const sign = (i - 1) % 4 > 1 ? -1 : 1;<br/> MEM[n - term];<br/>        i++;<br/>        term = penta(i);<br/>      }<br/>      currentPartition %= 1000000;<br/>      if (currentPartition === 0) {<br/>        answer = n;<br/>        break;<br/>      }<br/>      MEM[n] = currentPartition;<br/>      n++;<br/>    }<br/><br/>    return answer;<br/><br/>    // generalized pentagonal number generator<br/>    function penta(k) {<br/>      if (k & 1) {<br/>        const m = (k + 1) / 2;<br/> (3 * m - 1) / 2;<br/>      }<br/>      const m = k / 2;<br/> (3 * m + 1) / 2;<br/>    }<br/>  },<br/><br/> <strong>Question:</strong> Find the least value of n for which p(n) is divisible by one million. | 55*** | 47.084ms | [:arrow_upper_right:](https://projecteuler.net/problem=78)<br/><br/>
**79.** [Passcode derivation](https://github.com/zheng214/euler/blob/master/euler/8/index.js#L389-L457) | <br/>*<br/><br/> A common security method used for online banking is to ask the user for three random characters from a passcode. For example, if the passcode was 531278,<br/> they may ask for the 2nd, 3rd, and 5th characters; the expected reply would be: 317.<br/><br/> The text file, [keylog.txt]((https://github.com/zheng214/euler/blob/master/euler/8/p079_keylog.txt)), contains fifty successful login attempts.<br/><br/>    const passcodes = fs.readFileSync(path.join(__dirname, './p079_keylog.txt'))<br/>      .toString()<br/>      .split('\n')<br/>      .filter(Boolean);<br/>    // we can remove repeated passcodes<br/>    const uniqAttempts = Array.from(new Set(passcodes));<br/><br/>    // if we spend a minute to look at the attempts, we can see that the passcode contains no repeating digits<br/>    // therefore the solution becomes very straightforward<br/>    // we find the first digit of the passcode by finding the digit that is not preceeded by any other digits<br/>    // that digit can always be found, because if not, it means that there must be repeating digits<br/>    // repeat for second, third, etc.<br/><br/>    // since there are no repeats, and our login attempts do not contain a 4 or 5<br/>    // our passcode must have length 8<br/>    const target = 8;<br/>    let digitsFound = 0;<br/>    let answer = '';<br/>    // the list of attempts is updated every time we find a digit, by removing the found digit from it<br/>    let remainingAttempts = [...uniqAttempts];<br/><br/>    // the list of digits yet to be pushed into our answer is updated everytime we find an answer<br/>    let remainingDigits = [0, 1, 2, 3, 6, 7, 8, 9];<br/><br/>    while (digitsFound < target) {<br/>      let foundDigit;<br/>      // the list of remaining possible digits for a given step is updated everytime we find, in each attempt,<br/>      // a digit which is not in the first position<br/>      let currentPossibilities = [...remainingDigits];<br/><br/>      for (let i = 0; i < remainingAttempts.length; i++) {<br/>        // split each attempt into first and non-first digits (rem array)<br/>        const [first, ...nonFirst] = remainingAttempts[i].split('');<br/>        // for the possible digits remaining, keep the ones that are not included in the list of non-first digits<br/>        currentPossibilities = currentPossibilities.filter(x => !nonFirst.includes(`${x}`));<br/>        // if there is only one possible digit left, then it is the answer<br/>        if (currentPossibilities.length === 1) {<br/>          foundDigit = currentPossibilities[0];<br/>          // push digit into answer string<br/>          answer += foundDigit;<br/>          break;<br/>        }<br/>      }<br/><br/>      // remove the found digit from the list of remaining digits<br/>      remainingDigits = remainingDigits.filter(x => x !== foundDigit);<br/>      // reset the list of remaining possible digits used for traversal through attempts<br/>      currentPossibilities = [...remainingDigits];<br/>      // remove every occurrence of the found digit from the list of attempts<br/>      remainingAttempts = remainingAttempts.map(<br/>        attempt => attempt.split('').filter(<br/>          digit => +digit !== foundDigit,<br/>        ).join(''),<br/>      ).filter(x => x !== '');<br/>      digitsFound++;<br/>    }<br/>    return answer;<br/>  },<br/><br/> <strong>Question:</strong> Given that the three characters are always asked for in order, analyse the file so as to determine the shortest possible secret passcode of unknown length. | 7316**** | 1.444ms | [:arrow_upper_right:](https://projecteuler.net/problem=79)<br/><br/>
**80.** [Square root digital expansion](https://github.com/zheng214/euler/blob/master/euler/8/index.js#L459-L566) | <br/>*<br/><br/> It is well known that if the square root of a natural number is not an integer, then it is irrational.<br/> The decimal expansion of such square roots is infinite without any repeating pattern at all.<br/><br/> The square root of two is 1.41421356237309504880..., and the digital sum of the first one hundred decimal digits is 475.<br/><br/>    let ANSWER = 0;<br/>    // this is very similar to problem 66<br/>    // instead of iterating until we find a solution to an equation<br/>    // we keep iterating until we find a number for which the 100 first decimal is 'stable'<br/>    for (let D = 2; D <= 100; D++) {<br/>      // find leading digits<br/>      const sqrt = Math.sqrt(D);<br/>      const floor = Math.floor(sqrt);<br/>      if (sqrt === floor) {<br/>        continue;<br/>      }<br/>      let repetitionFound = false; // if a repetition has been found, we can exit the loop (explained below)<br/><br/>      // Step 1: Sequence of leading digits<br/>      const leadingDigits = [];<br/><br/>      let isolatedInteger = floor; // leading digit of our current iteration<br/>      let normalizedDenominator; // the denominator as a result of normalization<br/>      let initialNumerator = 1; // the normalized and reduced denominator (by the initial numerator) of the previous iteration<br/>      let denominatorOffset = floor; // the offset found in the denominator as a result of isolating the leading integer from the previous iteration<br/><br/>      while (!repetitionFound) {<br/>        // normalize<br/>* 2);<br/><br/>        // isolate<br/> (floor + denominatorOffset) / normalizedDenominator);<br/>        leadingDigits.push(isolatedInteger);<br/>        if (normalizedDenominator === initialNumerator) {<br/>          // the initialNumerator always starts with 1<br/>          // if the above two variables are equal, then the next initialNumerator will be 1, which will cause the cycle to repeat<br/>          repetitionFound = true;<br/>          break;<br/>        }<br/><br/>        // update for next iteration<br/>        initialNumerator = normalizedDenominator / initialNumerator;<br/> isolatedInteger);<br/>      }<br/><br/>      // Step 2: search for solution<br/><br/>      // solution verifier<br/>      // verify if there is a variation in the 101st decimal between the 2 fractions<br/>      // (ie. if the first 101 decimals are equal)<br/>      // we accomplish this by multiplying each numerator by 10^101 before dividing by the denominator<br/>      // this will truncate the 102nd digit (and everything after)<br/>      // if the 101th digit is the same for both fractions,<br/>      // we then just need to round the 100th digit to get our answer<br/>      const getSum100Digits = (num1, denom1, num2, denom2) => {<br/>* BigInt(101);<br/> shift / denom1;<br/> shift / denom2;<br/>        if (prevDigits === currDigits) { // stabilized, return the sum of the 100 digits<br/>          const digits = String(currDigits).slice(0, 100).split('');<br/>          return digits.map(Number).reduce((a, c) => a + c, 0);<br/>        }<br/>        return false;<br/>      };<br/><br/>      // returns nth leading integer in the continued fraction expansion of sqrt(D)<br/>      const getNthLeadingInteger = n => leadingDigits[(n - 1) % leadingDigits.length];<br/><br/>      // initial values<br/>      let target = 1;<br/>      let numerator = BigInt(1);<br/>      let denominator = BigInt(getNthLeadingInteger(target));<br/><br/>      let previousNumerator;<br/>      let previousDenominator;<br/><br/>      let stabilized = false;<br/>      // loop while a solution is not found<br/>      while (!stabilized) {<br/>        numerator = BigInt(1);<br/>        denominator = BigInt(getNthLeadingInteger(target));<br/>        // find the convergent at the `target` index by using backtracking<br/>        for (let i = target - 1; i >= 1; i--) {<br/>          const nextLeadingInteger = getNthLeadingInteger(i);<br/> BigInt(denominator) + BigInt(numerator)];<br/>        }<br/> BigInt(floor));<br/>        if (target > 1) {<br/>          const solution = getSum100Digits(previousNumerator, previousDenominator, numerator, denominator);<br/>          if (solution) {<br/>            ANSWER += solution;<br/>            stabilized = true;<br/>            break;<br/>          }<br/>        }<br/>        previousNumerator = numerator;<br/>        previousDenominator = denominator;<br/>        target++;<br/>      }<br/>    }<br/>    return ANSWER;<br/>  },<br/><br/> <strong>Question:</strong> For the first one hundred natural numbers, find the total of the digital sums of the first one hundred decimal digits for all the irrational square roots. | 40*** | 133.482ms | [:arrow_upper_right:](https://projecteuler.net/problem=80)<br/><br/>
**81.** [Path sum: two ways](https://github.com/zheng214/euler/blob/master/euler/9/index.js#L2-L31) | module.exports = {<br/>*<br/><br/> In the 5 by 5 matrix below, the minimal path sum from the top left to the bottom right, by only moving to the right and down,<br/> is indicated in bold and is equal to 2427.<br/><br/> **131** **673** 234 103 018<br/> 201 **096** **342** 965 150<br/> 630 803 **746** **422** 111<br/> 537 699 497 **121** 956<br/> 805 732 524 **037** **331**<br/><br/>    // we use a memoized table where the entry [i,j] is the optimal path from 0,0 to i,j<br/>    // MEM[i, j] = min(MEM[i - 1, j], MEM[i, j - 1]);<br/>    const MEM = utils.initTable(80, 80);<br/>    const raw = fs.readFileSync(path.join(__dirname, './p081_matrix.txt')).toString();<br/>    const MATRIX = raw.split('\n').slice(0, 80).map(row => row.split(',').map(Number));<br/>    MEM[0] = MATRIX[0].map((_, i) => utils.sumArray(MATRIX[0].slice(0, i + 1)));<br/>    for (let row = 1; row < 80; row++) {<br/>      MEM[row][0] = MATRIX[0][0] + utils.sumArray(MATRIX.map(r => r[0]).slice(1, row + 1));<br/>      for (let col = 1; col < 80; col++) {<br/>        MEM[row][col] = MATRIX[row][col] + Math.min(MEM[row - 1][col], MEM[row][col - 1]);<br/>      }<br/>    }<br/>    return MEM[79][79];<br/>  },<br/><br/> <strong>Question:</strong> Find the minimal path sum, in [matrix.txt](https://github.com/zheng214/euler/blob/master/euler/9/p081_matrix.txt),<br/>  a text file containing a 80 by 80 matrix, from the top left to the bottom right by only moving right and down. | 427*** | 3.605ms | [:arrow_upper_right:](https://projecteuler.net/problem=81)<br/><br/>
**82.** [Path sum: three ways](https://github.com/zheng214/euler/blob/master/euler/9/index.js#L33-L101) | <br/>*<br/><br/> The minimal path sum in the 5 by 5 matrix below, by starting in any cell in the left column and finishing in any cell in the right column,<br/> and only moving up, down, and right, is indicated in bold; the sum is equal to 994.<br/><br/> 131 673 **234** **103** **018**<br/> **201** **096** **342** 965 150<br/> 630 803 746 422 111<br/> 537 699 497 121 956<br/> 805 732 524 037 331<br/><br/>    // we iterate column by column, at each step we memorize the optimal sum from the leftmost column to<br/>    // each element of the current column<br/>    const raw = fs.readFileSync(path.join(__dirname, './p081_matrix.txt')).toString();<br/>    // parse file into a 2D array<br/>    const MATRIX = raw.split('\n').slice(0, 80).map(row => row.split(',').map(Number));<br/>    // initiate MEM to be the first column<br/>    let MEM = MATRIX.map(x => x[0]);<br/>    // at each iteration, MEM[k] remembers the optimal sum from the leftmost column (any starting row)<br/>    // to the kth element of the current column<br/>    for (let col = 1; col < MATRIX.length; col++) {<br/>      // extract current column<br/>      const column = MATRIX.map(x => x[col]);<br/>      // keep the data for the next column separate, as we still need the data of current column<br/>      const nextMEM = [];<br/>      // find optimal path for each element of column<br/>      for (let dest = 0; dest < MATRIX.length; dest++) {<br/>        // keep track of optimal path<br/>        let optimalSum = Infinity;<br/>        // calculate all paths from each element of previous column<br/>        let pathSum = 0;<br/>        for (let origin = 0; origin < MATRIX.length; origin++) {<br/>          // calculate all paths from a specific origin row to a specific destination row<br/>          // paths can only be: 1. go right and up, or 2. go right and down<br/><br/>          // if the memorized value at `origin` index is already exceeding the optimal sum, we can ignore it<br/>          if (MEM[origin] > optimalSum) {<br/>            continue;<br/>          }<br/><br/>          if (origin === dest) {<br/>            // if origin row is the same as destination row, the optimal path is just move right<br/>            pathSum = MEM[origin] + column[dest];<br/>          } else if (origin > dest) {<br/>            // origin is 'lower' (high index == low height) than dest in matrix, move right then up<br/>            pathSum = MEM[origin] + utils.sumArray(column.slice(dest, origin + 1));<br/>          } else {<br/>            // origin is 'higher' than dest in matrix, move right then down<br/>            pathSum = MEM[origin] + utils.sumArray(column.slice(origin, dest + 1));<br/>          }<br/>          if (pathSum < optimalSum) {<br/>            optimalSum = pathSum;<br/>          }<br/>        }<br/>        // memoize optimal sum<br/>        nextMEM[dest] = optimalSum;<br/>      }<br/>      // prepare for next column<br/>      MEM = nextMEM;<br/>    }<br/>    // at the last column, MEM contains all the OPTIMAL paths from the first column to each element of the last column<br/>    // the minimal element will then be the optimal path from left to right<br/>    return Math.min(...MEM);<br/>  },<br/><br/> <strong>Question:</strong> Find the minimal path sum, in [matrix.txt](https://github.com/zheng214/euler/blob/master/euler/9/p082_matrix.txt),<br/>  a 31K text file containing a 80 by 80 matrix, from the left column to the right column. | 260*** | 67.601ms | [:arrow_upper_right:](https://projecteuler.net/problem=82)<br/><br/>


<a href="#">Go to top</a>