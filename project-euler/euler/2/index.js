module.exports = {
  /**
   * Problem 11: Largest product in a grid
   * @question What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, diagonal) in the 20×20 grid?
   */
  e11() {
    const data11 = require('./p11_data');
    const grid = data11.split(/\n/).map(row => row.trim().split(' '));
    let highestScore = 0;
    for (let row = 0; row < 20; row++) {
      for (let column = 0; column < 20; column++) {
        const horizontalScore = computeProduct(grid[row].slice(column, column + 4));
        const verticalScore = computeProduct(grid.slice(row, row + 4).map(x => x[column]));
        const upDiagScore = computeProduct(grid.slice(row - 3, row + 1).map((x, index) => x[column + 4 - index]));
        const downDiagScore = computeProduct(grid.slice(row, row + 4).map((x, index) => x[column + index]));

        const highestOfCoord = Math.max(horizontalScore, verticalScore, upDiagScore, downDiagScore);
        if (highestOfCoord > highestScore) highestScore = highestOfCoord;
      }
    }

    return highestScore;

    function computeProduct(arr) {
      if (arr.length !== 4 || arr.includes(undefined)) {
        return 0;
      }
      return arr.reduce((acc, curr) => (curr || 0) * acc, 1);
    }
  },

  /**
   * Problem 12: Highly divisible triangular number
   * @question What is the value of the first triangle number to have over five hundred divisors?
   * 28 is the 5th triangle number, and it has 6 divisors (1, 2, 4, 7, 14, 28)
   */
  e12() {
    // given triangle number t generated by n(n+1)/2
    // we can compute the number of divisors of t (D(t)) by:
    // 1. D(t) = D(n/2) * D(n+1) if n is even OR
    // 2. D(t) = D(n) * D((n+1)/2) if n + 1 is even
    // Note: we can reuse D(n+1) (or D((n+1)/2)) at the next iteration of n

    let totalDivisorsCount = 0;
    let n = 2;
    let nEven = true;
    let lastComputedDivisorsCount = 1; // D(1) = 1

    while (totalDivisorsCount <= 500) {
      const triangle = n * (n + 1) / 2;
      let nextComputedDivisorsCount = 0;
      if (nEven) {
        nextComputedDivisorsCount = computeDivisorsCount(n + 1);
      } else {
        nextComputedDivisorsCount = computeDivisorsCount((n + 1) / 2);
      }
      totalDivisorsCount = lastComputedDivisorsCount * nextComputedDivisorsCount;
      if (totalDivisorsCount > 500) {
        return triangle;
      }
      lastComputedDivisorsCount = nextComputedDivisorsCount;
      nEven = !nEven;
      n++;
    }

    // check all integers up to sqrt(number)
    // we increment the count by 2 for each divisor found, as each divisor has a complementary divisor (except for the square root)
    function computeDivisorsCount(number) {
      const root = Math.sqrt(number);
      let count = 0;
      let divisor = Math.floor(root);
      if (divisor === root) {
        count++;
        divisor--;
      }
      while (divisor > 0) {
        if (!(number % divisor)) {
          count += 2;
        }
        divisor--;
      }
      return count;
    }
  },

  /**
   * Problem 13: Large sum
   * @question Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
   */
  e13() {
    const data13 = require('./p13_data');
    // filter out the first line which is undefined and remove whitespace (see data.js)
    const numbers = data13.split(/\n/g).filter(x => x).map(x => x.trim());
    let sum = 0;
    for (let position = 0; position < 50; position++) {
      sum += sumNthDigits(position);
      const first10DigitsCurrent = sum.toString(10).substr(0, 10);
      // shift the sum left to prepare for the sum of next 100 digits
      sum *= 10;
      // determine if the sum of the next 100 digits can affect the first 10 digits
      // ie. consider all the digits at the next position are 9s
      const maxValueForNextPosition = sum + 900;
      const first10DigitsNext = maxValueForNextPosition.toString(10).substr(0, 10);
      if (first10DigitsCurrent === first10DigitsNext) {
        return +(first10DigitsCurrent);
      }
    }

    function sumNthDigits(n) {
      return numbers.map(num => +(num[n])).reduce((acc, curr) => acc + curr, 0);
    }
  },

  /**
   * Problem 14: Longest Collatz sequence
   * The following iterative sequence is defined for the set of positive integers:
   *  n → n/2 (n is even)
   *  n → 3n + 1 (n is odd)
   *  Using the rule above and starting with 13, we generate the following sequence (Collatz):
   *  13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
   *
   * @question Which starting number, under one million, produces the longest chain?
   */
  e14() {
    // we use 2 variables to keep track of the highest chain count and the starting number associated with it
    let longestChainNumber = 0;
    let longestChain = 0;
    // we use an array to keep track of the length of each starting number, where the index correspond to the starting number
    const chainLengthArr = [];
    // we start at 500000 because if the longest chain c is below 500000, then there must be a longer chain at c * 2
    for (let i = 500001; i <= 1000000; i += 1) {
      computeChainLength(i, 0);
    }
    function computeChainLength(n, accumulatedLength) {
      // as mentionned above, we do not need to consider numbers below 500001
      if (n < 500001) {
        return accumulatedLength;
      }
      if (chainLengthArr[n]) {
        const totalChainLength = chainLengthArr[n] + accumulatedLength;
        return totalChainLength;
      }
      let result;
      if (utils.isOdd(n)) {
        // if n is odd then 3n + 1 is even, we can skip a step by passing (3n+1)/2 as an argument
        result = computeChainLength((3 * n + 1) / 2, accumulatedLength + 2);
      } else {
        result = computeChainLength(n / 2, accumulatedLength + 1);
      }
      // when the result returns, we need to update the chain length number of each number in the chain
      // we do so by substracting the accumulator associated with that number from the result (back propagation)
      // eg: 5 -> 16 -> 8 -> 4 -> 2 -> 1
      // stack trace:
      // computeChainLength(5, 0) -> result - 0 = 5
      // computeChainLength(16, 1) -> result - 1 = 4
      // computeChainLength(8, 2) -> result - 2 = 3
      // computeChainLength(4, 3) -> result - 3 = 2
      // computeChainLength(2, 4) -> result - 4 = 1
      // computeChainLength(1, 5) -> result - 5 = 0
      // result = 5
      // the memoized array will then be updated will the correct values (5 with 5, 16 with 4, etc.)
      chainLengthArr[n] = result - accumulatedLength;
      if (chainLengthArr[n] > longestChain) {
        longestChain = chainLengthArr[n];
        longestChainNumber = n;
      }
      return result;
    }
    return longestChainNumber;
  },


  /**
   * Problem 15: Lattice paths
   * Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down,
   * there are exactly 6 routes to the bottom right corner.
   * @question How many such routes are there through a 20×20 grid?
   */
  e15() {
    // this problem is equivalent to:
    // given 20 characters "r" (right) and 20 characters "d" (down)
    // how many ways are there to write a string using exactly those 40 characters
    // the answer is just 40 choose 20
    // as it is equivalent of choosing the locations of the 20 "r" inside our string
    return utils.fact(40) / (utils.fact(20) * utils.fact(20));
  },

  /**
   * Problem 16: Power digit sum
   * 2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
   * @question What is the sum of the digits of the number 2^1000?
   */
  e16() {
    // we iteratively multiply our result by 2 and we:
    // 1. store each digit inside an array (the array is "reversed": 1024 is stored as [4,2,0,1])
    // 2. increment the total sum of digits by the correct amount
    let resultArr = [2];
    let sumOfDigits = 2;
    for (let exponent = 2; exponent <= 1000; exponent++) {
      let carry = false;
      // iterate over each digit inside the array and multiply each digit by 2, if digit > 5, we set carry to true
      resultArr = resultArr.reduce(
        (acc, digit, index) => {
          if (digit >= 5) {
            // we only need the last digit of the result (e.g. 6 * 2 = 12 -> 2, the 1 will be carried over)
            acc[index] = 2 * digit - 10;
            // we compute the update rule for sumOfDigits by:
            // net amount = (digit at current iteration) - (digit at previous iteration) + 1(carry)
            // = (2 * digit - 10) - digit + 1
            // = digit - 9
            sumOfDigits += (digit - 9);
          } else {
            // if digit < 5, it is much simpler, just multiply the digit by 2
            acc[index] = 2 * digit;
            // net amount = (digit at current iteration) - (digit at previous iteration)
            // = (2 * digit) - digit
            // = digit
            sumOfDigits += digit;
          }
          // increment current digit by 1 if carry is true
          if (carry) acc[index]++;
          // set carry for next iteration
          carry = (digit > 4);
          return acc;
        },
        resultArr,
      );
      // if we exited the reduce with a carry left over, need to add(append) 1 to the array
      if (carry) {
        resultArr.push(1);
      }
    }
    return sumOfDigits;
  },

  /**
   * Problem 17: Number letter counts
   * If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters
   * used in total.
   * @question If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?
   */
  e17() {
    const oneToNine = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
    const elevenToNineteen = ['eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen'];
    const twentyToNinetyBy10 = ['twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety'];

    // to get count of 1 - 99, we sum the following components:
    // 1. <1-9> * 9 -> [<1-9>, 2<1-9>, 3<1-9>, ..., 9<1-9>]
    // 2. <11-19>
    // 3. <2-9>0 * 10 -> [<2-9>0, <0-9>1, <2-9>2. ..., <2-9>9]
    // 4. <10>
    const oneTo99 = countLetters(oneToNine) * 9 + countLetters(elevenToNineteen) + countLetters(twentyToNinetyBy10) * 10 + 3;
    const oneTo999 = oneTo99 * 10 + oneToNine.reduce((acc, x) => {
      // "<x> hundred and" * 99 + "<x> hundred"
      return acc + (x.length + 10) * 99 + (x.length + 7);
    }, 0);

    // <1000>
    return oneTo999 + 11;

    function countLetters(arr) {
      return arr.join('').length;
    }
  },

  /**
   * Problem 18: Maximum path sum I
   * By starting at the top of the triangle below and moving to adjacent numbers on the row below,
   * the maximum total from top to bottom is 23.
   *
   *    3
   *   7 4
   *  2 4 6
   * 8 5 9 3
   *
   * That is, 3 + 7 + 4 + 9 = 23.
   *
   * @question Find the maximum total from top to bottom of the triangle below:
   */
  e18() {
    const data18 = require('./p18_data');
    // parse the triangle into a 2D array
    // 1. transform it into an array where each element is a row eg. ['75', '95 64', ...]
    const formattedRows = data18.split('\n').map(x => x.trimStart());
    // 2. transform each row into an array of numbers eg. [[75], [95, 64], ...]
    const dataArray = formattedRows.map(
      x => x.split(' ').map( // split the string by space
        y => +(y), // for each element splitted, transform it into a Number
      ),
    ).slice(1); // remove the first element (there is a newline character at the start of the string in data.js)

    // we iterate through each row, and for each number in each row, we keep track of the maximum total from the top to that number

    // keeps track of the maximum score from the top to each number in the previous/current row
    let scoresOfPreviousRow = [];
    // keeps track of the path from the top to each number corresponding to the scores computed above (not required for the problem)
    let optimalpathsToPreviousRow = [];

    dataArray.forEach((row, rowIndex) => {
      const tempScores = [];
      const tempPaths = [];
      row.forEach((number, position) => {
        const isFirst = position === 0;
        const isLast = position === row.length - 1;
        if (rowIndex === 0) {
          tempScores[0] = number;
          tempPaths[0] = '0';
        } else if (isFirst) {
          tempScores[0] = scoresOfPreviousRow[0] + number;
          tempPaths[0] = `${optimalpathsToPreviousRow[0]}0`;
        } else if (isLast) {
          tempScores[position] = scoresOfPreviousRow[position - 1] + number;
          tempPaths[position] = `${optimalpathsToPreviousRow[position - 1]}${position}`;
        // is middle
        // right parent is bigger
        } else if (scoresOfPreviousRow[position] > scoresOfPreviousRow[position - 1]) {
          tempScores[position] = scoresOfPreviousRow[position] + number;
          tempPaths[position] = `${optimalpathsToPreviousRow[position]}${position}`;
        // left parent is bigger
        } else {
          tempScores[position] = scoresOfPreviousRow[position - 1] + number;
          tempPaths[position] = `${optimalpathsToPreviousRow[position - 1]}${position}`;
        }
      });
      scoresOfPreviousRow = tempScores;
      optimalpathsToPreviousRow = tempPaths;
    });
    return Math.max(...scoresOfPreviousRow);
  },

  /**
   * Problem 19: Counting Sundays
   * 1 Jan 1900 was a Monday.
   * A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.
   * @question How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?
   */
  e19() {
    // we just loop through each month of each year, and calculate that day's distance to 1 Jan 1900
    // from that distance we can tell if the day is a sunday or not
    let currentDistance = 365; // 1 jan 1901 - 1 jan 1900
    let sundays = 0;
    const oddMonths = [1, 3, 5, 7, 8, 10, 12]; // 31 days
    const evenMonths = [4, 6, 9, 11]; // 30 days
    for (let year = 1901; year <= 2000; year++) {
      const isLeapYear = (year % 4 === 0);
      for (let month = 1; month <= 12; month++) {
        if (currentDistance % 7 === 6) {
          sundays++;
        }

        if (oddMonths.includes(month)) {
          currentDistance += 31;
        } else if (evenMonths.includes(month)) {
          currentDistance += 30;
        } else if (isLeapYear) {
          currentDistance += 29;
        } else {
          currentDistance += 28;
        }
      }
    }
    return sundays;
  },

  /**
   * Problem 20: Factorial digit sum
   * @question Find the sum of the digits in the number 100!
   */
  e20() {
    // we use the same procedure as in problem 16
    // ie. manually multiply each digit
    let resultArr = [1];
    for (let i = 1; i < 101; i++) {
      const multiplier = i % 10 === 0 ? i / 10 : i; // multiplying by 90 has the same effect as multiplying by 9
      const productArr = resultArr.map(x => x * multiplier);
      resultArr = consolidate(productArr);
    }

    return utils.sumArray(resultArr);

    // "flatten" an array of products
    // eg. 25 * 25 => [5, 2] * 25 => [125, 50](input) => [5, 2 + 0, 1 + 5] => [5, 2, 6](output) => 625
    function consolidate(productArr) {
      let output = productArr.reduce(
        (acc, product, index) => {
          const productDigits = product.toString().split('').reverse().map(x => +(x)); // 125 => [5, 2, 1]
          productDigits.forEach((digit, i) => {
            acc[index + i] = acc[index + i] ? acc[index + i] + digit : digit;
          });
          return acc;
        },
        [],
      );
      if (output.find(x => x >= 10)) {
        output = consolidate(output);
      }
      return output;
    }
  },
};
