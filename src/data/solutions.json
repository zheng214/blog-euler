[
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      " We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "// answer = sum of\n// 1. sum of all multiples of 3 -> (3 + 6 + 9 + ... + 999) = 3 * (1 + 2 + ... + 333)\n// 2. sum of all multiples of 5 -> (5 + 10 + 15 + ... 995) = 5 * (1 + 2 + ... + 199);\n// 3. negative sum of all multiples of 15 -> 15 * (1 + 2 + ... + 66)\nconst sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [],
    "solution": "const totalPrimeFactors = [];\n// for each n, we:\n// (1) compute its prime factorization (see function below)\n// (2) \"merge\" that factorization into totalPrimeFactors by checking if the computed power\n// is higher than the power already in the array\n// (3) after all merging is done, the totalPrimeFactors will contain the prime factorization of our answer\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn totalPrimeFactors.reduce((acc, power, base) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return power ? acc * (base ** power) : acc;\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [],
    "solution": "let difference = 0;\nfor (let i = 0; i <= 100; i++) {\n  // let s_i = 1 + 2 + ... + i-1 + i\n  // let S_i = 1^2 + 2^2 + ... + (i-1)^2 + i^2\n  // let d_i = s_i^2 - S_i = (s_(i-1) + i)^2 - S_i\n  // = s_(i-1)^2 + 2i*s_(i-1) + i^2 - S_(i-1) - i^2\n  // = s_(i-1)^2 - S_(i-1) + 2i*s_(i-1) + i^2 - i^2\n  // = d_(i-1) + 2i * i(i-1)/2 = d_(i-1) + i^2(i-1)\n  difference += (i ** 2) * (i - 1);\n}\nreturn difference;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substr(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substr(i, 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substr(i, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [],
    "solution": "// given m > n > 0\n// we can generate: a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)\n// a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500;\nlet m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [],
    "solution": "// we use the Sieve of Eratosthenes to generate all primes below two million\n// for this purpose we create an array where the indexes represent integers,\n// and the values represent whether the index is prime or not\n// however, to optimize speed, we only sieve by odd multiples, ie. the even numbers are assumed to be non-prime\n// the resulting sieveArr will contain a list of flags indicating\n// whether the odd number corresponding to that index is prime or not\n// e.g. sieveArr[3] = true -> meaning that the 3rd odd number (excluding 1, so 7) is prime\n// e.g. sieveArr[4] = false -> 9 is not prime\nconst sieveArr = [];\n// we can stop at root because all the composite numbers above it must have been crossed out\n// this is because all composite numbers above root must have a factor smaller than root\n// because if a composite number have only factors above root, then that composite number must be > 2 million\nconst root = Math.sqrt(2000000);\nfor (let i = 1; i < root; i++) {\n  if (sieveArr[i] !== false) { // if index is not already sieved\n    sieveArr[i] = true; // then it must be prime\n    // since the indexes represent the odd numbers, we only need to sieve up to a multiple(j) such that:\n    // (ith odd number) * j < 2000000 => (2*i+1)*j < 2000000 => i * j < 2000000/(2*i+1)\n    const sieveTo = 2000000 / (2 * i + 1);\n    // sieve all odd multiples of i\n    // e.g. let i = 3 -> we must sieve 9, 15, 21, ...\n    // therefore we sieve their corresponding indexes -> 4, 7, 10, ...\n    for (let j = 3; j <= sieveTo; j += 2) {\n      sieveArr[((2 * i + 1) * j - 1) / 2] = false;\n    }\n  }\n}\nlet sum = 0;\n// after the array is ready, we loop over it adding all flags which are true,\n// keeping in mind that the p is the pth odd integer\nfor (let p = 1; p < sieveArr.length; p++) {\n  if (sieveArr[p] !== false) {\n    sum += (2 * p + 1);\n  }\n}\n// add 2 because 2 is the only even prime!\nreturn sum + 2;",
    "utils": []
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      " We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "// answer = sum of\n// 1. sum of all multiples of 3 -> (3 + 6 + 9 + ... + 999) = 3 * (1 + 2 + ... + 333)\n// 2. sum of all multiples of 5 -> (5 + 10 + 15 + ... 995) = 5 * (1 + 2 + ... + 199);\n// 3. negative sum of all multiples of 15 -> 15 * (1 + 2 + ... + 66)\nconst sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [],
    "solution": "const totalPrimeFactors = [];\n// for each n, we:\n// (1) compute its prime factorization (see function below)\n// (2) \"merge\" that factorization into totalPrimeFactors by checking if the computed power\n// is higher than the power already in the array\n// (3) after all merging is done, the totalPrimeFactors will contain the prime factorization of our answer\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn totalPrimeFactors.reduce((acc, power, base) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return power ? acc * (base ** power) : acc;\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [],
    "solution": "let difference = 0;\nfor (let i = 0; i <= 100; i++) {\n  // let s_i = 1 + 2 + ... + i-1 + i\n  // let S_i = 1^2 + 2^2 + ... + (i-1)^2 + i^2\n  // let d_i = s_i^2 - S_i = (s_(i-1) + i)^2 - S_i\n  // = s_(i-1)^2 + 2i*s_(i-1) + i^2 - S_(i-1) - i^2\n  // = s_(i-1)^2 - S_(i-1) + 2i*s_(i-1) + i^2 - i^2\n  // = d_(i-1) + 2i * i(i-1)/2 = d_(i-1) + i^2(i-1)\n  difference += (i ** 2) * (i - 1);\n}\nreturn difference;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substr(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substr(i, 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substr(i, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [],
    "solution": "// given m > n > 0\n// we can generate: a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)\n// a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500;\nlet m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [],
    "solution": "// we use the Sieve of Eratosthenes to generate all primes below two million\n// for this purpose we create an array where the indexes represent integers,\n// and the values represent whether the index is prime or not\n// however, to optimize speed, we only sieve by odd multiples, ie. the even numbers are assumed to be non-prime\n// the resulting sieveArr will contain a list of flags indicating\n// whether the odd number corresponding to that index is prime or not\n// e.g. sieveArr[3] = true -> meaning that the 3rd odd number (excluding 1, so 7) is prime\n// e.g. sieveArr[4] = false -> 9 is not prime\nconst sieveArr = [];\n// we can stop at root because all the composite numbers above it must have been crossed out\n// this is because all composite numbers above root must have a factor smaller than root\n// because if a composite number have only factors above root, then that composite number must be > 2 million\nconst root = Math.sqrt(2000000);\nfor (let i = 1; i < root; i++) {\n  if (sieveArr[i] !== false) { // if index is not already sieved\n    sieveArr[i] = true; // then it must be prime\n    // since the indexes represent the odd numbers, we only need to sieve up to a multiple(j) such that:\n    // (ith odd number) * j < 2000000 => (2*i+1)*j < 2000000 => i * j < 2000000/(2*i+1)\n    const sieveTo = 2000000 / (2 * i + 1);\n    // sieve all odd multiples of i\n    // e.g. let i = 3 -> we must sieve 9, 15, 21, ...\n    // therefore we sieve their corresponding indexes -> 4, 7, 10, ...\n    for (let j = 3; j <= sieveTo; j += 2) {\n      sieveArr[((2 * i + 1) * j - 1) / 2] = false;\n    }\n  }\n}\nlet sum = 0;\n// after the array is ready, we loop over it adding all flags which are true,\n// keeping in mind that the p is the pth odd integer\nfor (let p = 1; p < sieveArr.length; p++) {\n  if (sieveArr[p] !== false) {\n    sum += (2 * p + 1);\n  }\n}\n// add 2 because 2 is the only even prime!\nreturn sum + 2;",
    "utils": []
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      " We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "// answer = sum of\n// 1. sum of all multiples of 3 -> (3 + 6 + 9 + ... + 999) = 3 * (1 + 2 + ... + 333)\n// 2. sum of all multiples of 5 -> (5 + 10 + 15 + ... 995) = 5 * (1 + 2 + ... + 199);\n// 3. negative sum of all multiples of 15 -> 15 * (1 + 2 + ... + 66)\nconst sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [],
    "solution": "const totalPrimeFactors = [];\n// for each n, we:\n// (1) compute its prime factorization (see function below)\n// (2) \"merge\" that factorization into totalPrimeFactors by checking if the computed power\n// is higher than the power already in the array\n// (3) after all merging is done, the totalPrimeFactors will contain the prime factorization of our answer\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn totalPrimeFactors.reduce((acc, power, base) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return power ? acc * (base ** power) : acc;\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [],
    "solution": "let difference = 0;\nfor (let i = 0; i <= 100; i++) {\n  // let s_i = 1 + 2 + ... + i-1 + i\n  // let S_i = 1^2 + 2^2 + ... + (i-1)^2 + i^2\n  // let d_i = s_i^2 - S_i = (s_(i-1) + i)^2 - S_i\n  // = s_(i-1)^2 + 2i*s_(i-1) + i^2 - S_(i-1) - i^2\n  // = s_(i-1)^2 - S_(i-1) + 2i*s_(i-1) + i^2 - i^2\n  // = d_(i-1) + 2i * i(i-1)/2 = d_(i-1) + i^2(i-1)\n  difference += (i ** 2) * (i - 1);\n}\nreturn difference;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substr(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substr(i, 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substr(i, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [],
    "solution": "// given m > n > 0\n// we can generate: a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)\n// a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500;\nlet m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [],
    "solution": "// we use the Sieve of Eratosthenes to generate all primes below two million\n// for this purpose we create an array where the indexes represent integers,\n// and the values represent whether the index is prime or not\n// however, to optimize speed, we only sieve by odd multiples, ie. the even numbers are assumed to be non-prime\n// the resulting sieveArr will contain a list of flags indicating\n// whether the odd number corresponding to that index is prime or not\n// e.g. sieveArr[3] = true -> meaning that the 3rd odd number (excluding 1, so 7) is prime\n// e.g. sieveArr[4] = false -> 9 is not prime\nconst sieveArr = [];\n// we can stop at root because all the composite numbers above it must have been crossed out\n// this is because all composite numbers above root must have a factor smaller than root\n// because if a composite number have only factors above root, then that composite number must be > 2 million\nconst root = Math.sqrt(2000000);\nfor (let i = 1; i < root; i++) {\n  if (sieveArr[i] !== false) { // if index is not already sieved\n    sieveArr[i] = true; // then it must be prime\n    // since the indexes represent the odd numbers, we only need to sieve up to a multiple(j) such that:\n    // (ith odd number) * j < 2000000 => (2*i+1)*j < 2000000 => i * j < 2000000/(2*i+1)\n    const sieveTo = 2000000 / (2 * i + 1);\n    // sieve all odd multiples of i\n    // e.g. let i = 3 -> we must sieve 9, 15, 21, ...\n    // therefore we sieve their corresponding indexes -> 4, 7, 10, ...\n    for (let j = 3; j <= sieveTo; j += 2) {\n      sieveArr[((2 * i + 1) * j - 1) / 2] = false;\n    }\n  }\n}\nlet sum = 0;\n// after the array is ready, we loop over it adding all flags which are true,\n// keeping in mind that the p is the pth odd integer\nfor (let p = 1; p < sieveArr.length; p++) {\n  if (sieveArr[p] !== false) {\n    sum += (2 * p + 1);\n  }\n}\n// add 2 because 2 is the only even prime!\nreturn sum + 2;",
    "utils": []
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      " We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "// answer = sum of\n// 1. sum of all multiples of 3 -> (3 + 6 + 9 + ... + 999) = 3 * (1 + 2 + ... + 333)\n// 2. sum of all multiples of 5 -> (5 + 10 + 15 + ... 995) = 5 * (1 + 2 + ... + 199);\n// 3. negative sum of all multiples of 15 -> 15 * (1 + 2 + ... + 66)\nconst sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [],
    "solution": "const totalPrimeFactors = [];\n// for each n, we:\n// (1) compute its prime factorization (see function below)\n// (2) \"merge\" that factorization into totalPrimeFactors by checking if the computed power\n// is higher than the power already in the array\n// (3) after all merging is done, the totalPrimeFactors will contain the prime factorization of our answer\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn totalPrimeFactors.reduce((acc, power, base) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return power ? acc * (base ** power) : acc;\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [],
    "solution": "let difference = 0;\nfor (let i = 0; i <= 100; i++) {\n  // let s_i = 1 + 2 + ... + i-1 + i\n  // let S_i = 1^2 + 2^2 + ... + (i-1)^2 + i^2\n  // let d_i = s_i^2 - S_i = (s_(i-1) + i)^2 - S_i\n  // = s_(i-1)^2 + 2i*s_(i-1) + i^2 - S_(i-1) - i^2\n  // = s_(i-1)^2 - S_(i-1) + 2i*s_(i-1) + i^2 - i^2\n  // = d_(i-1) + 2i * i(i-1)/2 = d_(i-1) + i^2(i-1)\n  difference += (i ** 2) * (i - 1);\n}\nreturn difference;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substr(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substr(i, 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substr(i, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [],
    "solution": "// given m > n > 0\n// we can generate: a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)\n// a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500;\nlet m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [],
    "solution": "// we use the Sieve of Eratosthenes to generate all primes below two million\n// for this purpose we create an array where the indexes represent integers,\n// and the values represent whether the index is prime or not\n// however, to optimize speed, we only sieve by odd multiples, ie. the even numbers are assumed to be non-prime\n// the resulting sieveArr will contain a list of flags indicating\n// whether the odd number corresponding to that index is prime or not\n// e.g. sieveArr[3] = true -> meaning that the 3rd odd number (excluding 1, so 7) is prime\n// e.g. sieveArr[4] = false -> 9 is not prime\nconst sieveArr = [];\n// we can stop at root because all the composite numbers above it must have been crossed out\n// this is because all composite numbers above root must have a factor smaller than root\n// because if a composite number have only factors above root, then that composite number must be > 2 million\nconst root = Math.sqrt(2000000);\nfor (let i = 1; i < root; i++) {\n  if (sieveArr[i] !== false) { // if index is not already sieved\n    sieveArr[i] = true; // then it must be prime\n    // since the indexes represent the odd numbers, we only need to sieve up to a multiple(j) such that:\n    // (ith odd number) * j < 2000000 => (2*i+1)*j < 2000000 => i * j < 2000000/(2*i+1)\n    const sieveTo = 2000000 / (2 * i + 1);\n    // sieve all odd multiples of i\n    // e.g. let i = 3 -> we must sieve 9, 15, 21, ...\n    // therefore we sieve their corresponding indexes -> 4, 7, 10, ...\n    for (let j = 3; j <= sieveTo; j += 2) {\n      sieveArr[((2 * i + 1) * j - 1) / 2] = false;\n    }\n  }\n}\nlet sum = 0;\n// after the array is ready, we loop over it adding all flags which are true,\n// keeping in mind that the p is the pth odd integer\nfor (let p = 1; p < sieveArr.length; p++) {\n  if (sieveArr[p] !== false) {\n    sum += (2 * p + 1);\n  }\n}\n// add 2 because 2 is the only even prime!\nreturn sum + 2;",
    "utils": []
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      " We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "// answer = sum of\n// 1. sum of all multiples of 3 -> (3 + 6 + 9 + ... + 999) = 3 * (1 + 2 + ... + 333)\n// 2. sum of all multiples of 5 -> (5 + 10 + 15 + ... 995) = 5 * (1 + 2 + ... + 199);\n// 3. negative sum of all multiples of 15 -> 15 * (1 + 2 + ... + 66)\nconst sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [],
    "solution": "const totalPrimeFactors = [];\n// for each n, we:\n// (1) compute its prime factorization (see function below)\n// (2) \"merge\" that factorization into totalPrimeFactors by checking if the computed power\n// is higher than the power already in the array\n// (3) after all merging is done, the totalPrimeFactors will contain the prime factorization of our answer\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn totalPrimeFactors.reduce((acc, power, base) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return power ? acc * (base ** power) : acc;\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [],
    "solution": "let difference = 0;\nfor (let i = 0; i <= 100; i++) {\n  // let s_i = 1 + 2 + ... + i-1 + i\n  // let S_i = 1^2 + 2^2 + ... + (i-1)^2 + i^2\n  // let d_i = s_i^2 - S_i = (s_(i-1) + i)^2 - S_i\n  // = s_(i-1)^2 + 2i*s_(i-1) + i^2 - S_(i-1) - i^2\n  // = s_(i-1)^2 - S_(i-1) + 2i*s_(i-1) + i^2 - i^2\n  // = d_(i-1) + 2i * i(i-1)/2 = d_(i-1) + i^2(i-1)\n  difference += (i ** 2) * (i - 1);\n}\nreturn difference;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substr(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substr(i, 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substr(i, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [],
    "solution": "// given m > n > 0\n// we can generate: a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)\n// a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500;\nlet m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [],
    "solution": "// we use the Sieve of Eratosthenes to generate all primes below two million\n// for this purpose we create an array where the indexes represent integers,\n// and the values represent whether the index is prime or not\n// however, to optimize speed, we only sieve by odd multiples, ie. the even numbers are assumed to be non-prime\n// the resulting sieveArr will contain a list of flags indicating\n// whether the odd number corresponding to that index is prime or not\n// e.g. sieveArr[3] = true -> meaning that the 3rd odd number (excluding 1, so 7) is prime\n// e.g. sieveArr[4] = false -> 9 is not prime\nconst sieveArr = [];\n// we can stop at root because all the composite numbers above it must have been crossed out\n// this is because all composite numbers above root must have a factor smaller than root\n// because if a composite number have only factors above root, then that composite number must be > 2 million\nconst root = Math.sqrt(2000000);\nfor (let i = 1; i < root; i++) {\n  if (sieveArr[i] !== false) { // if index is not already sieved\n    sieveArr[i] = true; // then it must be prime\n    // since the indexes represent the odd numbers, we only need to sieve up to a multiple(j) such that:\n    // (ith odd number) * j < 2000000 => (2*i+1)*j < 2000000 => i * j < 2000000/(2*i+1)\n    const sieveTo = 2000000 / (2 * i + 1);\n    // sieve all odd multiples of i\n    // e.g. let i = 3 -> we must sieve 9, 15, 21, ...\n    // therefore we sieve their corresponding indexes -> 4, 7, 10, ...\n    for (let j = 3; j <= sieveTo; j += 2) {\n      sieveArr[((2 * i + 1) * j - 1) / 2] = false;\n    }\n  }\n}\nlet sum = 0;\n// after the array is ready, we loop over it adding all flags which are true,\n// keeping in mind that the p is the pth odd integer\nfor (let p = 1; p < sieveArr.length; p++) {\n  if (sieveArr[p] !== false) {\n    sum += (2 * p + 1);\n  }\n}\n// add 2 because 2 is the only even prime!\nreturn sum + 2;",
    "utils": []
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      " We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "// answer = sum of\n// 1. sum of all multiples of 3 -> (3 + 6 + 9 + ... + 999) = 3 * (1 + 2 + ... + 333)\n// 2. sum of all multiples of 5 -> (5 + 10 + 15 + ... 995) = 5 * (1 + 2 + ... + 199);\n// 3. negative sum of all multiples of 15 -> 15 * (1 + 2 + ... + 66)\nconst sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [],
    "solution": "const totalPrimeFactors = [];\n// for each n, we:\n// (1) compute its prime factorization (see function below)\n// (2) \"merge\" that factorization into totalPrimeFactors by checking if the computed power\n// is higher than the power already in the array\n// (3) after all merging is done, the totalPrimeFactors will contain the prime factorization of our answer\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn totalPrimeFactors.reduce((acc, power, base) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return power ? acc * (base ** power) : acc;\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [],
    "solution": "let difference = 0;\nfor (let i = 0; i <= 100; i++) {\n  // let s_i = 1 + 2 + ... + i-1 + i\n  // let S_i = 1^2 + 2^2 + ... + (i-1)^2 + i^2\n  // let d_i = s_i^2 - S_i = (s_(i-1) + i)^2 - S_i\n  // = s_(i-1)^2 + 2i*s_(i-1) + i^2 - S_(i-1) - i^2\n  // = s_(i-1)^2 - S_(i-1) + 2i*s_(i-1) + i^2 - i^2\n  // = d_(i-1) + 2i * i(i-1)/2 = d_(i-1) + i^2(i-1)\n  difference += (i ** 2) * (i - 1);\n}\nreturn difference;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substr(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substr(i, 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substr(i, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [],
    "solution": "// given m > n > 0\n// we can generate: a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)\n// a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500;\nlet m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [],
    "solution": "// we use the Sieve of Eratosthenes to generate all primes below two million\n// for this purpose we create an array where the indexes represent integers,\n// and the values represent whether the index is prime or not\n// however, to optimize speed, we only sieve by odd multiples, ie. the even numbers are assumed to be non-prime\n// the resulting sieveArr will contain a list of flags indicating\n// whether the odd number corresponding to that index is prime or not\n// e.g. sieveArr[3] = true -> meaning that the 3rd odd number (excluding 1, so 7) is prime\n// e.g. sieveArr[4] = false -> 9 is not prime\nconst sieveArr = [];\n// we can stop at root because all the composite numbers above it must have been crossed out\n// this is because all composite numbers above root must have a factor smaller than root\n// because if a composite number have only factors above root, then that composite number must be > 2 million\nconst root = Math.sqrt(2000000);\nfor (let i = 1; i < root; i++) {\n  if (sieveArr[i] !== false) { // if index is not already sieved\n    sieveArr[i] = true; // then it must be prime\n    // since the indexes represent the odd numbers, we only need to sieve up to a multiple(j) such that:\n    // (ith odd number) * j < 2000000 => (2*i+1)*j < 2000000 => i * j < 2000000/(2*i+1)\n    const sieveTo = 2000000 / (2 * i + 1);\n    // sieve all odd multiples of i\n    // e.g. let i = 3 -> we must sieve 9, 15, 21, ...\n    // therefore we sieve their corresponding indexes -> 4, 7, 10, ...\n    for (let j = 3; j <= sieveTo; j += 2) {\n      sieveArr[((2 * i + 1) * j - 1) / 2] = false;\n    }\n  }\n}\nlet sum = 0;\n// after the array is ready, we loop over it adding all flags which are true,\n// keeping in mind that the p is the pth odd integer\nfor (let p = 1; p < sieveArr.length; p++) {\n  if (sieveArr[p] !== false) {\n    sum += (2 * p + 1);\n  }\n}\n// add 2 because 2 is the only even prime!\nreturn sum + 2;",
    "utils": []
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      " We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "// answer = sum of\n// 1. sum of all multiples of 3 -> (3 + 6 + 9 + ... + 999) = 3 * (1 + 2 + ... + 333)\n// 2. sum of all multiples of 5 -> (5 + 10 + 15 + ... 995) = 5 * (1 + 2 + ... + 199);\n// 3. negative sum of all multiples of 15 -> 15 * (1 + 2 + ... + 66)\nconst sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [],
    "solution": "const totalPrimeFactors = [];\n// for each n, we:\n// (1) compute its prime factorization (see function below)\n// (2) \"merge\" that factorization into totalPrimeFactors by checking if the computed power\n// is higher than the power already in the array\n// (3) after all merging is done, the totalPrimeFactors will contain the prime factorization of our answer\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn totalPrimeFactors.reduce((acc, power, base) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return power ? acc * (base ** power) : acc;\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [],
    "solution": "let difference = 0;\nfor (let i = 0; i <= 100; i++) {\n  // let s_i = 1 + 2 + ... + i-1 + i\n  // let S_i = 1^2 + 2^2 + ... + (i-1)^2 + i^2\n  // let d_i = s_i^2 - S_i = (s_(i-1) + i)^2 - S_i\n  // = s_(i-1)^2 + 2i*s_(i-1) + i^2 - S_(i-1) - i^2\n  // = s_(i-1)^2 - S_(i-1) + 2i*s_(i-1) + i^2 - i^2\n  // = d_(i-1) + 2i * i(i-1)/2 = d_(i-1) + i^2(i-1)\n  difference += (i ** 2) * (i - 1);\n}\nreturn difference;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substr(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substr(i, 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substr(i, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [],
    "solution": "// given m > n > 0\n// we can generate: a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)\n// a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500;\nlet m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [],
    "solution": "// we use the Sieve of Eratosthenes to generate all primes below two million\n// for this purpose we create an array where the indexes represent integers,\n// and the values represent whether the index is prime or not\n// however, to optimize speed, we only sieve by odd multiples, ie. the even numbers are assumed to be non-prime\n// the resulting sieveArr will contain a list of flags indicating\n// whether the odd number corresponding to that index is prime or not\n// e.g. sieveArr[3] = true -> meaning that the 3rd odd number (excluding 1, so 7) is prime\n// e.g. sieveArr[4] = false -> 9 is not prime\nconst sieveArr = [];\n// we can stop at root because all the composite numbers above it must have been crossed out\n// this is because all composite numbers above root must have a factor smaller than root\n// because if a composite number have only factors above root, then that composite number must be > 2 million\nconst root = Math.sqrt(2000000);\nfor (let i = 1; i < root; i++) {\n  if (sieveArr[i] !== false) { // if index is not already sieved\n    sieveArr[i] = true; // then it must be prime\n    // since the indexes represent the odd numbers, we only need to sieve up to a multiple(j) such that:\n    // (ith odd number) * j < 2000000 => (2*i+1)*j < 2000000 => i * j < 2000000/(2*i+1)\n    const sieveTo = 2000000 / (2 * i + 1);\n    // sieve all odd multiples of i\n    // e.g. let i = 3 -> we must sieve 9, 15, 21, ...\n    // therefore we sieve their corresponding indexes -> 4, 7, 10, ...\n    for (let j = 3; j <= sieveTo; j += 2) {\n      sieveArr[((2 * i + 1) * j - 1) / 2] = false;\n    }\n  }\n}\nlet sum = 0;\n// after the array is ready, we loop over it adding all flags which are true,\n// keeping in mind that the p is the pth odd integer\nfor (let p = 1; p < sieveArr.length; p++) {\n  if (sieveArr[p] !== false) {\n    sum += (2 * p + 1);\n  }\n}\n// add 2 because 2 is the only even prime!\nreturn sum + 2;",
    "utils": []
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      " We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "// answer = sum of\n// 1. sum of all multiples of 3 -> (3 + 6 + 9 + ... + 999) = 3 * (1 + 2 + ... + 333)\n// 2. sum of all multiples of 5 -> (5 + 10 + 15 + ... 995) = 5 * (1 + 2 + ... + 199);\n// 3. negative sum of all multiples of 15 -> 15 * (1 + 2 + ... + 66)\nconst sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [],
    "solution": "const totalPrimeFactors = [];\n// for each n, we:\n// (1) compute its prime factorization (see function below)\n// (2) \"merge\" that factorization into totalPrimeFactors by checking if the computed power\n// is higher than the power already in the array\n// (3) after all merging is done, the totalPrimeFactors will contain the prime factorization of our answer\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn totalPrimeFactors.reduce((acc, power, base) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return power ? acc * (base ** power) : acc;\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [],
    "solution": "let difference = 0;\nfor (let i = 0; i <= 100; i++) {\n  // let s_i = 1 + 2 + ... + i-1 + i\n  // let S_i = 1^2 + 2^2 + ... + (i-1)^2 + i^2\n  // let d_i = s_i^2 - S_i = (s_(i-1) + i)^2 - S_i\n  // = s_(i-1)^2 + 2i*s_(i-1) + i^2 - S_(i-1) - i^2\n  // = s_(i-1)^2 - S_(i-1) + 2i*s_(i-1) + i^2 - i^2\n  // = d_(i-1) + 2i * i(i-1)/2 = d_(i-1) + i^2(i-1)\n  difference += (i ** 2) * (i - 1);\n}\nreturn difference;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substr(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substr(i, 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substr(i, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [],
    "solution": "// given m > n > 0\n// we can generate: a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)\n// a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500;\nlet m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [],
    "solution": "// we use the Sieve of Eratosthenes to generate all primes below two million\n// for this purpose we create an array where the indexes represent integers,\n// and the values represent whether the index is prime or not\n// however, to optimize speed, we only sieve by odd multiples, ie. the even numbers are assumed to be non-prime\n// the resulting sieveArr will contain a list of flags indicating\n// whether the odd number corresponding to that index is prime or not\n// e.g. sieveArr[3] = true -> meaning that the 3rd odd number (excluding 1, so 7) is prime\n// e.g. sieveArr[4] = false -> 9 is not prime\nconst sieveArr = [];\n// we can stop at root because all the composite numbers above it must have been crossed out\n// this is because all composite numbers above root must have a factor smaller than root\n// because if a composite number have only factors above root, then that composite number must be > 2 million\nconst root = Math.sqrt(2000000);\nfor (let i = 1; i < root; i++) {\n  if (sieveArr[i] !== false) { // if index is not already sieved\n    sieveArr[i] = true; // then it must be prime\n    // since the indexes represent the odd numbers, we only need to sieve up to a multiple(j) such that:\n    // (ith odd number) * j < 2000000 => (2*i+1)*j < 2000000 => i * j < 2000000/(2*i+1)\n    const sieveTo = 2000000 / (2 * i + 1);\n    // sieve all odd multiples of i\n    // e.g. let i = 3 -> we must sieve 9, 15, 21, ...\n    // therefore we sieve their corresponding indexes -> 4, 7, 10, ...\n    for (let j = 3; j <= sieveTo; j += 2) {\n      sieveArr[((2 * i + 1) * j - 1) / 2] = false;\n    }\n  }\n}\nlet sum = 0;\n// after the array is ready, we loop over it adding all flags which are true,\n// keeping in mind that the p is the pth odd integer\nfor (let p = 1; p < sieveArr.length; p++) {\n  if (sieveArr[p] !== false) {\n    sum += (2 * p + 1);\n  }\n}\n// add 2 because 2 is the only even prime!\nreturn sum + 2;",
    "utils": []
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      " We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "// answer = sum of\n// 1. sum of all multiples of 3 -> (3 + 6 + 9 + ... + 999) = 3 * (1 + 2 + ... + 333)\n// 2. sum of all multiples of 5 -> (5 + 10 + 15 + ... 995) = 5 * (1 + 2 + ... + 199);\n// 3. negative sum of all multiples of 15 -> 15 * (1 + 2 + ... + 66)\nconst sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [],
    "solution": "const totalPrimeFactors = [];\n// for each n, we:\n// (1) compute its prime factorization (see function below)\n// (2) \"merge\" that factorization into totalPrimeFactors by checking if the computed power\n// is higher than the power already in the array\n// (3) after all merging is done, the totalPrimeFactors will contain the prime factorization of our answer\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn totalPrimeFactors.reduce((acc, power, base) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return power ? acc * (base ** power) : acc;\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [],
    "solution": "let difference = 0;\nfor (let i = 0; i <= 100; i++) {\n  // let s_i = 1 + 2 + ... + i-1 + i\n  // let S_i = 1^2 + 2^2 + ... + (i-1)^2 + i^2\n  // let d_i = s_i^2 - S_i = (s_(i-1) + i)^2 - S_i\n  // = s_(i-1)^2 + 2i*s_(i-1) + i^2 - S_(i-1) - i^2\n  // = s_(i-1)^2 - S_(i-1) + 2i*s_(i-1) + i^2 - i^2\n  // = d_(i-1) + 2i * i(i-1)/2 = d_(i-1) + i^2(i-1)\n  difference += (i ** 2) * (i - 1);\n}\nreturn difference;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substr(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substr(i, 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substr(i, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [],
    "solution": "// given m > n > 0\n// we can generate: a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)\n// a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500;\nlet m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [],
    "solution": "// we use the Sieve of Eratosthenes to generate all primes below two million\n// for this purpose we create an array where the indexes represent integers,\n// and the values represent whether the index is prime or not\n// however, to optimize speed, we only sieve by odd multiples, ie. the even numbers are assumed to be non-prime\n// the resulting sieveArr will contain a list of flags indicating\n// whether the odd number corresponding to that index is prime or not\n// e.g. sieveArr[3] = true -> meaning that the 3rd odd number (excluding 1, so 7) is prime\n// e.g. sieveArr[4] = false -> 9 is not prime\nconst sieveArr = [];\n// we can stop at root because all the composite numbers above it must have been crossed out\n// this is because all composite numbers above root must have a factor smaller than root\n// because if a composite number have only factors above root, then that composite number must be > 2 million\nconst root = Math.sqrt(2000000);\nfor (let i = 1; i < root; i++) {\n  if (sieveArr[i] !== false) { // if index is not already sieved\n    sieveArr[i] = true; // then it must be prime\n    // since the indexes represent the odd numbers, we only need to sieve up to a multiple(j) such that:\n    // (ith odd number) * j < 2000000 => (2*i+1)*j < 2000000 => i * j < 2000000/(2*i+1)\n    const sieveTo = 2000000 / (2 * i + 1);\n    // sieve all odd multiples of i\n    // e.g. let i = 3 -> we must sieve 9, 15, 21, ...\n    // therefore we sieve their corresponding indexes -> 4, 7, 10, ...\n    for (let j = 3; j <= sieveTo; j += 2) {\n      sieveArr[((2 * i + 1) * j - 1) / 2] = false;\n    }\n  }\n}\nlet sum = 0;\n// after the array is ready, we loop over it adding all flags which are true,\n// keeping in mind that the p is the pth odd integer\nfor (let p = 1; p < sieveArr.length; p++) {\n  if (sieveArr[p] !== false) {\n    sum += (2 * p + 1);\n  }\n}\n// add 2 because 2 is the only even prime!\nreturn sum + 2;",
    "utils": []
  }
]