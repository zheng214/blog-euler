[
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      "We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "const sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [
      "Very straightforward, just go through all Fibonacci numbers and add the even ones."
    ],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [
      "<span>Starting with the given number (<span class=\"mono\">currentlyDividing</span>), and the factor 2 (<span class=\"mono\">currentFactor</span>), we divide the given number by the factor until it is not divisible by it anymore.</span>",
      "<span>We then increment <span class=\"mono\">currentFactor</span>, and repeat, until the given number equals 1.</span>"
    ],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [
      "Starting with the largest possible number 999999, we iterate through the list of palindromes from biggest to smallest. This is achieved by decrementing 3 digit numbers from 999 and appending its flipped counterpart (ie. 999999, 998899, 997799, ...). For each palindrome, we test whether it is divisible by a 3 digit number, using the <span class=\"mono\">isPalindromeValid</span> function.",
      "<br /><br />",
      "The function first calculates the square root of the palindrome. If the palindrome is valid, it must have a divisor bigger than the square root AND a divisor smaller than the square root.",
      "For small optimization purposes, if the square root is closer to 100, we search all 3 digit numbers between the square root and 100, Otherwise, we search all 3 digit numbers between the square root and 999."
    ],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [
      "The algorithm works as follows:",
      "<br />",
      "For each number 2, 3, ..., 20.",
      "<br />",
      "We extract its prime factorization. (eg. 12 -> 2^2 * 3^1, 18 -> 2^1 * 3^2)",
      "<br />",
      "We add that factorization to the table <span class=\"mono\">totalPrimeFactors</span>. ",
      "<br />",
      "The table <span class=\"mono\">totalPrimeFactors</span> is encoded such that the keys are the bases, and the entries are the exponents.",
      "<br />",
      "So, going from 2 to 20, iteratively, the array will update as follows:",
      "<br />",
      "<span class=\"mono\">{ 2: 1 }</span> (2 = 2^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 1, 3: 1 }</span> (3 = 3^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1 }</span> (4 = 2^2)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (5 = 5^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (6 = 2^1 * 3^1) Note that nothing has changed, since 2^1 and 3^1 are already part of the array.",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1, 7: 1 }</span> (7 = 7^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 3, 3: 1, 5: 1, 7: 1 }</span> (8 = 2^3)",
      "<br />",
      "etc.",
      "<br />",
      "At each step, the product of the bases, raised to their respective exponents, will be the least common multiple of all numbers from 2 to the number inserted at that step. ",
      "After the 20th step (we start with step 2), the array will have the information of the least common multiple of all numbers from 2 to 20."
    ],
    "solution": "const totalPrimeFactors = {};\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn Object.keys(totalPrimeFactors).reduce((acc, power) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return acc * (power ** totalPrimeFactors[power]);\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [
      "Pretty self-explanatory"
    ],
    "solution": "let sum1to100 = 0;\nlet sumOfsquares = 0;\nfor (let i = 0; i <= 100; i++) {\n  sum1to100 += i;\n  sumOfsquares += (i ** 2);\n}\nreturn sum1to100 ** 2 - sumOfsquares;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [
      "Check each number 1 by 1, if it's prime we increment our counter, until our counter becomes 10001. The prime checker function is linked below."
    ],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [
      "We start out by \"slimming\" our input. If 12 or less digits are wrapped between two 0s, we can collapse it down to a single 0.",
      "<br />",
      "Then, for each step, we \"move\" to the right, and, instead of multiplying all 13 numbers, we divide by the leftmost number and multiply by the rightmost number."
    ],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substring(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substring(i, i + 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substring(i, i + 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [
      "There is a formula for generating Pythagorean triplets from 2 numbers m > n > 0: ",
      "<br />",
      "a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)",
      "<br />",
      "We use simple algebra to find the following: a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500; (ie. we must find 2 numbers, m and n, such that m(m+n) = 500)",
      "<br />",
      "Since m(m+n) = 500, we can observe that m < sqrt(500). So we search m by decrementing from sqrt(500)."
    ],
    "solution": "let m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [
      "We use our built-in function to generate the list of primes below 2 million, and add them. The function is linked below."
    ],
    "solution": "const primes = utils.generatePrimesTable(2000000);\nreturn utils.sumArray(Object.keys(primes), n => +n);",
    "utils": [
      "primes/generatePrimesTable",
      "common/sumArray"
    ]
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      "We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "const sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [
      "Very straightforward, just go through all Fibonacci numbers and add the even ones."
    ],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [
      "<span>Starting with the given number (<span class=\"mono\">currentlyDividing</span>), and the factor 2 (<span class=\"mono\">currentFactor</span>), we divide the given number by the factor until it is not divisible by it anymore.</span>",
      "<span>We then increment <span class=\"mono\">currentFactor</span>, and repeat, until the given number equals 1.</span>"
    ],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [
      "Starting with the largest possible number 999999, we iterate through the list of palindromes from biggest to smallest. This is achieved by decrementing 3 digit numbers from 999 and appending its flipped counterpart (ie. 999999, 998899, 997799, ...). For each palindrome, we test whether it is divisible by a 3 digit number, using the <span class=\"mono\">isPalindromeValid</span> function.",
      "<br /><br />",
      "The function first calculates the square root of the palindrome. If the palindrome is valid, it must have a divisor bigger than the square root AND a divisor smaller than the square root.",
      "For small optimization purposes, if the square root is closer to 100, we search all 3 digit numbers between the square root and 100, Otherwise, we search all 3 digit numbers between the square root and 999."
    ],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [
      "The algorithm works as follows:",
      "<br />",
      "For each number 2, 3, ..., 20.",
      "<br />",
      "We extract its prime factorization. (eg. 12 -> 2^2 * 3^1, 18 -> 2^1 * 3^2)",
      "<br />",
      "We add that factorization to the table <span class=\"mono\">totalPrimeFactors</span>. ",
      "<br />",
      "The table <span class=\"mono\">totalPrimeFactors</span> is encoded such that the keys are the bases, and the entries are the exponents.",
      "<br />",
      "So, going from 2 to 20, iteratively, the array will update as follows:",
      "<br />",
      "<span class=\"mono\">{ 2: 1 }</span> (2 = 2^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 1, 3: 1 }</span> (3 = 3^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1 }</span> (4 = 2^2)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (5 = 5^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (6 = 2^1 * 3^1) Note that nothing has changed, since 2^1 and 3^1 are already part of the array.",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1, 7: 1 }</span> (7 = 7^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 3, 3: 1, 5: 1, 7: 1 }</span> (8 = 2^3)",
      "<br />",
      "etc.",
      "<br />",
      "At each step, the product of the bases, raised to their respective exponents, will be the least common multiple of all numbers from 2 to the number inserted at that step. ",
      "After the 20th step (we start with step 2), the array will have the information of the least common multiple of all numbers from 2 to 20."
    ],
    "solution": "const totalPrimeFactors = {};\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn Object.keys(totalPrimeFactors).reduce((acc, power) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return acc * (power ** totalPrimeFactors[power]);\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [
      "Pretty self-explanatory"
    ],
    "solution": "let sum1to100 = 0;\nlet sumOfsquares = 0;\nfor (let i = 0; i <= 100; i++) {\n  sum1to100 += i;\n  sumOfsquares += (i ** 2);\n}\nreturn sum1to100 ** 2 - sumOfsquares;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [
      "Check each number 1 by 1, if it's prime we increment our counter, until our counter becomes 10001. The prime checker function is linked below."
    ],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [
      "We start out by \"slimming\" our input. If 12 or less digits are wrapped between two 0s, we can collapse it down to a single 0.",
      "<br />",
      "Then, for each step, we \"move\" to the right, and, instead of multiplying all 13 numbers, we divide by the leftmost number and multiply by the rightmost number."
    ],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substring(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substring(i, i + 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substring(i, i + 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [
      "There is a formula for generating Pythagorean triplets from 2 numbers m > n > 0: ",
      "<br />",
      "a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)",
      "<br />",
      "We use simple algebra to find the following: a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500; (ie. we must find 2 numbers, m and n, such that m(m+n) = 500)",
      "<br />",
      "Since m(m+n) = 500, we can observe that m < sqrt(500). So we search m by decrementing from sqrt(500)."
    ],
    "solution": "let m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [
      "We use our built-in function to generate the list of primes below 2 million, and add them. The function is linked below."
    ],
    "solution": "const primes = utils.generatePrimesTable(2000000);\nreturn utils.sumArray(Object.keys(primes), n => +n);",
    "utils": [
      "primes/generatePrimesTable",
      "common/sumArray"
    ]
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      "We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "const sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [
      "Very straightforward, just go through all Fibonacci numbers and add the even ones."
    ],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [
      "<span>Starting with the given number (<span class=\"mono\">currentlyDividing</span>), and the factor 2 (<span class=\"mono\">currentFactor</span>), we divide the given number by the factor until it is not divisible by it anymore.</span>",
      "<span>We then increment <span class=\"mono\">currentFactor</span>, and repeat, until the given number equals 1.</span>"
    ],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [
      "Starting with the largest possible number 999999, we iterate through the list of palindromes from biggest to smallest. This is achieved by decrementing 3 digit numbers from 999 and appending its flipped counterpart (ie. 999999, 998899, 997799, ...). For each palindrome, we test whether it is divisible by a 3 digit number, using the <span class=\"mono\">isPalindromeValid</span> function.",
      "<br /><br />",
      "The function first calculates the square root of the palindrome. If the palindrome is valid, it must have a divisor bigger than the square root AND a divisor smaller than the square root.",
      "For small optimization purposes, if the square root is closer to 100, we search all 3 digit numbers between the square root and 100, Otherwise, we search all 3 digit numbers between the square root and 999."
    ],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [
      "The algorithm works as follows:",
      "<br />",
      "For each number 2, 3, ..., 20.",
      "<br />",
      "We extract its prime factorization. (eg. 12 -> 2^2 * 3^1, 18 -> 2^1 * 3^2)",
      "<br />",
      "We add that factorization to the table <span class=\"mono\">totalPrimeFactors</span>. ",
      "<br />",
      "The table <span class=\"mono\">totalPrimeFactors</span> is encoded such that the keys are the bases, and the entries are the exponents.",
      "<br />",
      "So, going from 2 to 20, iteratively, the array will update as follows:",
      "<br />",
      "<span class=\"mono\">{ 2: 1 }</span> (2 = 2^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 1, 3: 1 }</span> (3 = 3^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1 }</span> (4 = 2^2)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (5 = 5^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (6 = 2^1 * 3^1) Note that nothing has changed, since 2^1 and 3^1 are already part of the array.",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1, 7: 1 }</span> (7 = 7^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 3, 3: 1, 5: 1, 7: 1 }</span> (8 = 2^3)",
      "<br />",
      "etc.",
      "<br />",
      "At each step, the product of the bases, raised to their respective exponents, will be the least common multiple of all numbers from 2 to the number inserted at that step. ",
      "After the 20th step (we start with step 2), the array will have the information of the least common multiple of all numbers from 2 to 20."
    ],
    "solution": "const totalPrimeFactors = {};\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn Object.keys(totalPrimeFactors).reduce((acc, power) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return acc * (power ** totalPrimeFactors[power]);\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [
      "Pretty self-explanatory"
    ],
    "solution": "let sum1to100 = 0;\nlet sumOfsquares = 0;\nfor (let i = 0; i <= 100; i++) {\n  sum1to100 += i;\n  sumOfsquares += (i ** 2);\n}\nreturn sum1to100 ** 2 - sumOfsquares;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [
      "Check each number 1 by 1, if it's prime we increment our counter, until our counter becomes 10001. The prime checker function is linked below."
    ],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [
      "We start out by \"slimming\" our input. If 12 or less digits are wrapped between two 0s, we can collapse it down to a single 0.",
      "<br />",
      "Then, for each step, we \"move\" to the right, and, instead of multiplying all 13 numbers, we divide by the leftmost number and multiply by the rightmost number."
    ],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substring(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substring(i, i + 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substring(i, i + 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [
      "There is a formula for generating Pythagorean triplets from 2 numbers m > n > 0: ",
      "<br />",
      "a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)",
      "<br />",
      "We use simple algebra to find the following: a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500; (ie. we must find 2 numbers, m and n, such that m(m+n) = 500)",
      "<br />",
      "Since m(m+n) = 500, we can observe that m < sqrt(500). So we search m by decrementing from sqrt(500)."
    ],
    "solution": "let m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [
      "We use our built-in function to generate the list of primes below 2 million, and add them. The function is linked below."
    ],
    "solution": "const primes = utils.generatePrimesTable(2000000);\nreturn utils.sumArray(Object.keys(primes), n => +n);",
    "utils": [
      "primes/generatePrimesTable",
      "common/sumArray"
    ]
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      "We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "const sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [
      "Very straightforward, just go through all Fibonacci numbers and add the even ones."
    ],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [
      "<span>Starting with the given number (<span class=\"mono\">currentlyDividing</span>), and the factor 2 (<span class=\"mono\">currentFactor</span>), we divide the given number by the factor until it is not divisible by it anymore.</span>",
      "<span>We then increment <span class=\"mono\">currentFactor</span>, and repeat, until the given number equals 1.</span>"
    ],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [
      "Starting with the largest possible number 999999, we iterate through the list of palindromes from biggest to smallest. This is achieved by decrementing 3 digit numbers from 999 and appending its flipped counterpart (ie. 999999, 998899, 997799, ...). For each palindrome, we test whether it is divisible by a 3 digit number, using the <span class=\"mono\">isPalindromeValid</span> function.",
      "<br /><br />",
      "The function first calculates the square root of the palindrome. If the palindrome is valid, it must have a divisor bigger than the square root AND a divisor smaller than the square root.",
      "For small optimization purposes, if the square root is closer to 100, we search all 3 digit numbers between the square root and 100, Otherwise, we search all 3 digit numbers between the square root and 999."
    ],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [
      "The algorithm works as follows:",
      "<br />",
      "For each number 2, 3, ..., 20.",
      "<br />",
      "We extract its prime factorization. (eg. 12 -> 2^2 * 3^1, 18 -> 2^1 * 3^2)",
      "<br />",
      "We add that factorization to the table <span class=\"mono\">totalPrimeFactors</span>. ",
      "<br />",
      "The table <span class=\"mono\">totalPrimeFactors</span> is encoded such that the keys are the bases, and the entries are the exponents.",
      "<br />",
      "So, going from 2 to 20, iteratively, the array will update as follows:",
      "<br />",
      "<span class=\"mono\">{ 2: 1 }</span> (2 = 2^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 1, 3: 1 }</span> (3 = 3^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1 }</span> (4 = 2^2)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (5 = 5^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (6 = 2^1 * 3^1) Note that nothing has changed, since 2^1 and 3^1 are already part of the array.",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1, 7: 1 }</span> (7 = 7^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 3, 3: 1, 5: 1, 7: 1 }</span> (8 = 2^3)",
      "<br />",
      "etc.",
      "<br />",
      "At each step, the product of the bases, raised to their respective exponents, will be the least common multiple of all numbers from 2 to the number inserted at that step. ",
      "After the 20th step (we start with step 2), the array will have the information of the least common multiple of all numbers from 2 to 20."
    ],
    "solution": "const totalPrimeFactors = {};\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn Object.keys(totalPrimeFactors).reduce((acc, power) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return acc * (power ** totalPrimeFactors[power]);\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [
      "Pretty self-explanatory"
    ],
    "solution": "let sum1to100 = 0;\nlet sumOfsquares = 0;\nfor (let i = 0; i <= 100; i++) {\n  sum1to100 += i;\n  sumOfsquares += (i ** 2);\n}\nreturn sum1to100 ** 2 - sumOfsquares;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [
      "Check each number 1 by 1, if it's prime we increment our counter, until our counter becomes 10001. The prime checker function is linked below."
    ],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [
      "We start out by \"slimming\" our input. If 12 or less digits are wrapped between two 0s, we can collapse it down to a single 0.",
      "<br />",
      "Then, for each step, we \"move\" to the right, and, instead of multiplying all 13 numbers, we divide by the leftmost number and multiply by the rightmost number."
    ],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substring(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substring(i, i + 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substring(i, i + 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [
      "There is a formula for generating Pythagorean triplets from 2 numbers m > n > 0: ",
      "<br />",
      "a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)",
      "<br />",
      "We use simple algebra to find the following: a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500; (ie. we must find 2 numbers, m and n, such that m(m+n) = 500)",
      "<br />",
      "Since m(m+n) = 500, we can observe that m < sqrt(500). So we search m by decrementing from sqrt(500)."
    ],
    "solution": "let m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [
      "We use our built-in function to generate the list of primes below 2 million, and add them. The function is linked below."
    ],
    "solution": "const primes = utils.generatePrimesTable(2000000);\nreturn utils.sumArray(Object.keys(primes), n => +n);",
    "utils": [
      "primes/generatePrimesTable",
      "common/sumArray"
    ]
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      "We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "const sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [
      "Very straightforward, just go through all Fibonacci numbers and add the even ones."
    ],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [
      "<span>Starting with the given number (<span class=\"mono\">currentlyDividing</span>), and the factor 2 (<span class=\"mono\">currentFactor</span>), we divide the given number by the factor until it is not divisible by it anymore.</span>",
      "<span>We then increment <span class=\"mono\">currentFactor</span>, and repeat, until the given number equals 1.</span>"
    ],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [
      "Starting with the largest possible number 999999, we iterate through the list of palindromes from biggest to smallest. This is achieved by decrementing 3 digit numbers from 999 and appending its flipped counterpart (ie. 999999, 998899, 997799, ...). For each palindrome, we test whether it is divisible by a 3 digit number, using the <span class=\"mono\">isPalindromeValid</span> function.",
      "<br /><br />",
      "The function first calculates the square root of the palindrome. If the palindrome is valid, it must have a divisor bigger than the square root AND a divisor smaller than the square root.",
      "For small optimization purposes, if the square root is closer to 100, we search all 3 digit numbers between the square root and 100, Otherwise, we search all 3 digit numbers between the square root and 999."
    ],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [
      "The algorithm works as follows:",
      "<br />",
      "For each number 2, 3, ..., 20.",
      "<br />",
      "We extract its prime factorization. (eg. 12 -> 2^2 * 3^1, 18 -> 2^1 * 3^2)",
      "<br />",
      "We add that factorization to the table <span class=\"mono\">totalPrimeFactors</span>. ",
      "<br />",
      "The table <span class=\"mono\">totalPrimeFactors</span> is encoded such that the keys are the bases, and the entries are the exponents.",
      "<br />",
      "So, going from 2 to 20, iteratively, the array will update as follows:",
      "<br />",
      "<span class=\"mono\">{ 2: 1 }</span> (2 = 2^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 1, 3: 1 }</span> (3 = 3^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1 }</span> (4 = 2^2)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (5 = 5^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (6 = 2^1 * 3^1) Note that nothing has changed, since 2^1 and 3^1 are already part of the array.",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1, 7: 1 }</span> (7 = 7^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 3, 3: 1, 5: 1, 7: 1 }</span> (8 = 2^3)",
      "<br />",
      "etc.",
      "<br />",
      "At each step, the product of the bases, raised to their respective exponents, will be the least common multiple of all numbers from 2 to the number inserted at that step. ",
      "After the 20th step (we start with step 2), the array will have the information of the least common multiple of all numbers from 2 to 20."
    ],
    "solution": "const totalPrimeFactors = {};\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn Object.keys(totalPrimeFactors).reduce((acc, power) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return acc * (power ** totalPrimeFactors[power]);\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [
      "Pretty self-explanatory"
    ],
    "solution": "let sum1to100 = 0;\nlet sumOfsquares = 0;\nfor (let i = 0; i <= 100; i++) {\n  sum1to100 += i;\n  sumOfsquares += (i ** 2);\n}\nreturn sum1to100 ** 2 - sumOfsquares;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [
      "Check each number 1 by 1, if it's prime we increment our counter, until our counter becomes 10001. The prime checker function is linked below."
    ],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [
      "We start out by \"slimming\" our input. If 12 or less digits are wrapped between two 0s, we can collapse it down to a single 0.",
      "<br />",
      "Then, for each step, we \"move\" to the right, and, instead of multiplying all 13 numbers, we divide by the leftmost number and multiply by the rightmost number."
    ],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substring(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substring(i, i + 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substring(i, i + 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [
      "There is a formula for generating Pythagorean triplets from 2 numbers m > n > 0: ",
      "<br />",
      "a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)",
      "<br />",
      "We use simple algebra to find the following: a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500; (ie. we must find 2 numbers, m and n, such that m(m+n) = 500)",
      "<br />",
      "Since m(m+n) = 500, we can observe that m < sqrt(500). So we search m by decrementing from sqrt(500)."
    ],
    "solution": "let m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [
      "We use our built-in function to generate the list of primes below 2 million, and add them. The function is linked below."
    ],
    "solution": "const primes = utils.generatePrimesTable(2000000);\nreturn utils.sumArray(Object.keys(primes), n => +n);",
    "utils": [
      "primes/generatePrimesTable",
      "common/sumArray"
    ]
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      "We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "const sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [
      "Very straightforward, just go through all Fibonacci numbers and add the even ones."
    ],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [
      "<span>Starting with the given number (<span class=\"mono\">currentlyDividing</span>), and the factor 2 (<span class=\"mono\">currentFactor</span>), we divide the given number by the factor until it is not divisible by it anymore.</span>",
      "<span>We then increment <span class=\"mono\">currentFactor</span>, and repeat, until the given number equals 1.</span>"
    ],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [
      "Starting with the largest possible number 999999, we iterate through the list of palindromes from biggest to smallest. This is achieved by decrementing 3 digit numbers from 999 and appending its flipped counterpart (ie. 999999, 998899, 997799, ...). For each palindrome, we test whether it is divisible by a 3 digit number, using the <span class=\"mono\">isPalindromeValid</span> function.",
      "<br /><br />",
      "The function first calculates the square root of the palindrome. If the palindrome is valid, it must have a divisor bigger than the square root AND a divisor smaller than the square root.",
      "For small optimization purposes, if the square root is closer to 100, we search all 3 digit numbers between the square root and 100, Otherwise, we search all 3 digit numbers between the square root and 999."
    ],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [
      "The algorithm works as follows:",
      "<br />",
      "For each number 2, 3, ..., 20.",
      "<br />",
      "We extract its prime factorization. (eg. 12 -> 2^2 * 3^1, 18 -> 2^1 * 3^2)",
      "<br />",
      "We add that factorization to the table <span class=\"mono\">totalPrimeFactors</span>. ",
      "<br />",
      "The table <span class=\"mono\">totalPrimeFactors</span> is encoded such that the keys are the bases, and the entries are the exponents.",
      "<br />",
      "So, going from 2 to 20, iteratively, the array will update as follows:",
      "<br />",
      "<span class=\"mono\">{ 2: 1 }</span> (2 = 2^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 1, 3: 1 }</span> (3 = 3^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1 }</span> (4 = 2^2)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (5 = 5^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (6 = 2^1 * 3^1) Note that nothing has changed, since 2^1 and 3^1 are already part of the array.",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1, 7: 1 }</span> (7 = 7^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 3, 3: 1, 5: 1, 7: 1 }</span> (8 = 2^3)",
      "<br />",
      "etc.",
      "<br />",
      "At each step, the product of the bases, raised to their respective exponents, will be the least common multiple of all numbers from 2 to the number inserted at that step. ",
      "After the 20th step (we start with step 2), the array will have the information of the least common multiple of all numbers from 2 to 20."
    ],
    "solution": "const totalPrimeFactors = {};\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn Object.keys(totalPrimeFactors).reduce((acc, power) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return acc * (power ** totalPrimeFactors[power]);\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [
      "Pretty self-explanatory"
    ],
    "solution": "let sum1to100 = 0;\nlet sumOfsquares = 0;\nfor (let i = 0; i <= 100; i++) {\n  sum1to100 += i;\n  sumOfsquares += (i ** 2);\n}\nreturn sum1to100 ** 2 - sumOfsquares;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [
      "Check each number 1 by 1, if it's prime we increment our counter, until our counter becomes 10001. The prime checker function is linked below."
    ],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [
      "We start out by \"slimming\" our input. If 12 or less digits are wrapped between two 0s, we can collapse it down to a single 0.",
      "<br />",
      "Then, for each step, we \"move\" to the right, and, instead of multiplying all 13 numbers, we divide by the leftmost number and multiply by the rightmost number."
    ],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substring(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substring(i, i + 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substring(i, i + 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [
      "There is a formula for generating Pythagorean triplets from 2 numbers m > n > 0: ",
      "<br />",
      "a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)",
      "<br />",
      "We use simple algebra to find the following: a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500; (ie. we must find 2 numbers, m and n, such that m(m+n) = 500)",
      "<br />",
      "Since m(m+n) = 500, we can observe that m < sqrt(500). So we search m by decrementing from sqrt(500)."
    ],
    "solution": "let m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [
      "We use our built-in function to generate the list of primes below 2 million, and add them. The function is linked below."
    ],
    "solution": "const primes = utils.generatePrimesTable(2000000);\nreturn utils.sumArray(Object.keys(primes), n => +n);",
    "utils": [
      "primes/generatePrimesTable",
      "common/sumArray"
    ]
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      "We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "const sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [
      "Very straightforward, just go through all Fibonacci numbers and add the even ones."
    ],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [
      "<span>Starting with the given number (<span class=\"mono\">currentlyDividing</span>), and the factor 2 (<span class=\"mono\">currentFactor</span>), we divide the given number by the factor until it is not divisible by it anymore.</span>",
      "<span>We then increment <span class=\"mono\">currentFactor</span>, and repeat, until the given number equals 1.</span>"
    ],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [
      "Starting with the largest possible number 999999, we iterate through the list of palindromes from biggest to smallest. This is achieved by decrementing 3 digit numbers from 999 and appending its flipped counterpart (ie. 999999, 998899, 997799, ...). For each palindrome, we test whether it is divisible by a 3 digit number, using the <span class=\"mono\">isPalindromeValid</span> function.",
      "<br /><br />",
      "The function first calculates the square root of the palindrome. If the palindrome is valid, it must have a divisor bigger than the square root AND a divisor smaller than the square root.",
      "For small optimization purposes, if the square root is closer to 100, we search all 3 digit numbers between the square root and 100, Otherwise, we search all 3 digit numbers between the square root and 999."
    ],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [
      "The algorithm works as follows:",
      "<br />",
      "For each number 2, 3, ..., 20.",
      "<br />",
      "We extract its prime factorization. (eg. 12 -> 2^2 * 3^1, 18 -> 2^1 * 3^2)",
      "<br />",
      "We add that factorization to the table <span class=\"mono\">totalPrimeFactors</span>. ",
      "<br />",
      "The table <span class=\"mono\">totalPrimeFactors</span> is encoded such that the keys are the bases, and the entries are the exponents.",
      "<br />",
      "So, going from 2 to 20, iteratively, the array will update as follows:",
      "<br />",
      "<span class=\"mono\">{ 2: 1 }</span> (2 = 2^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 1, 3: 1 }</span> (3 = 3^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1 }</span> (4 = 2^2)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (5 = 5^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (6 = 2^1 * 3^1) Note that nothing has changed, since 2^1 and 3^1 are already part of the array.",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1, 7: 1 }</span> (7 = 7^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 3, 3: 1, 5: 1, 7: 1 }</span> (8 = 2^3)",
      "<br />",
      "etc.",
      "<br />",
      "At each step, the product of the bases, raised to their respective exponents, will be the least common multiple of all numbers from 2 to the number inserted at that step. ",
      "After the 20th step (we start with step 2), the array will have the information of the least common multiple of all numbers from 2 to 20."
    ],
    "solution": "const totalPrimeFactors = {};\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn Object.keys(totalPrimeFactors).reduce((acc, power) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return acc * (power ** totalPrimeFactors[power]);\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [
      "Pretty self-explanatory"
    ],
    "solution": "let sum1to100 = 0;\nlet sumOfsquares = 0;\nfor (let i = 0; i <= 100; i++) {\n  sum1to100 += i;\n  sumOfsquares += (i ** 2);\n}\nreturn sum1to100 ** 2 - sumOfsquares;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [
      "Check each number 1 by 1, if it's prime we increment our counter, until our counter becomes 10001. The prime checker function is linked below."
    ],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [
      "We start out by \"slimming\" our input. If 12 or less digits are wrapped between two 0s, we can collapse it down to a single 0.",
      "<br />",
      "Then, for each step, we \"move\" to the right, and, instead of multiplying all 13 numbers, we divide by the leftmost number and multiply by the rightmost number."
    ],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substring(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substring(i, i + 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substring(i, i + 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [
      "There is a formula for generating Pythagorean triplets from 2 numbers m > n > 0: ",
      "<br />",
      "a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)",
      "<br />",
      "We use simple algebra to find the following: a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500; (ie. we must find 2 numbers, m and n, such that m(m+n) = 500)",
      "<br />",
      "Since m(m+n) = 500, we can observe that m < sqrt(500). So we search m by decrementing from sqrt(500)."
    ],
    "solution": "let m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [
      "We use our built-in function to generate the list of primes below 2 million, and add them. The function is linked below."
    ],
    "solution": "const primes = utils.generatePrimesTable(2000000);\nreturn utils.sumArray(Object.keys(primes), n => +n);",
    "utils": [
      "primes/generatePrimesTable",
      "common/sumArray"
    ]
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      "We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "const sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [
      "Very straightforward, just go through all Fibonacci numbers and add the even ones."
    ],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [
      "<span>Starting with the given number (<span class=\"mono\">currentlyDividing</span>), and the factor 2 (<span class=\"mono\">currentFactor</span>), we divide the given number by the factor until it is not divisible by it anymore.</span>",
      "<span>We then increment <span class=\"mono\">currentFactor</span>, and repeat, until the given number equals 1.</span>"
    ],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [
      "Starting with the largest possible number 999999, we iterate through the list of palindromes from biggest to smallest. This is achieved by decrementing 3 digit numbers from 999 and appending its flipped counterpart (ie. 999999, 998899, 997799, ...). For each palindrome, we test whether it is divisible by a 3 digit number, using the <span class=\"mono\">isPalindromeValid</span> function.",
      "<br /><br />",
      "The function first calculates the square root of the palindrome. If the palindrome is valid, it must have a divisor bigger than the square root AND a divisor smaller than the square root.",
      "For small optimization purposes, if the square root is closer to 100, we search all 3 digit numbers between the square root and 100, Otherwise, we search all 3 digit numbers between the square root and 999."
    ],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [
      "The algorithm works as follows:",
      "<br />",
      "For each number 2, 3, ..., 20.",
      "<br />",
      "We extract its prime factorization. (eg. 12 -> 2^2 * 3^1, 18 -> 2^1 * 3^2)",
      "<br />",
      "We add that factorization to the table <span class=\"mono\">totalPrimeFactors</span>. ",
      "<br />",
      "The table <span class=\"mono\">totalPrimeFactors</span> is encoded such that the keys are the bases, and the entries are the exponents.",
      "<br />",
      "So, going from 2 to 20, iteratively, the array will update as follows:",
      "<br />",
      "<span class=\"mono\">{ 2: 1 }</span> (2 = 2^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 1, 3: 1 }</span> (3 = 3^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1 }</span> (4 = 2^2)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (5 = 5^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (6 = 2^1 * 3^1) Note that nothing has changed, since 2^1 and 3^1 are already part of the array.",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1, 7: 1 }</span> (7 = 7^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 3, 3: 1, 5: 1, 7: 1 }</span> (8 = 2^3)",
      "<br />",
      "etc.",
      "<br />",
      "At each step, the product of the bases, raised to their respective exponents, will be the least common multiple of all numbers from 2 to the number inserted at that step. ",
      "After the 20th step (we start with step 2), the array will have the information of the least common multiple of all numbers from 2 to 20."
    ],
    "solution": "const totalPrimeFactors = {};\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn Object.keys(totalPrimeFactors).reduce((acc, power) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return acc * (power ** totalPrimeFactors[power]);\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [
      "Pretty self-explanatory"
    ],
    "solution": "let sum1to100 = 0;\nlet sumOfsquares = 0;\nfor (let i = 0; i <= 100; i++) {\n  sum1to100 += i;\n  sumOfsquares += (i ** 2);\n}\nreturn sum1to100 ** 2 - sumOfsquares;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [
      "Check each number 1 by 1, if it's prime we increment our counter, until our counter becomes 10001. The prime checker function is linked below."
    ],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [
      "We start out by \"slimming\" our input. If 12 or less digits are wrapped between two 0s, we can collapse it down to a single 0.",
      "<br />",
      "Then, for each step, we \"move\" to the right, and, instead of multiplying all 13 numbers, we divide by the leftmost number and multiply by the rightmost number."
    ],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substring(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substring(i, i + 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substring(i, i + 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [
      "There is a formula for generating Pythagorean triplets from 2 numbers m > n > 0: ",
      "<br />",
      "a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)",
      "<br />",
      "We use simple algebra to find the following: a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500; (ie. we must find 2 numbers, m and n, such that m(m+n) = 500)",
      "<br />",
      "Since m(m+n) = 500, we can observe that m < sqrt(500). So we search m by decrementing from sqrt(500)."
    ],
    "solution": "let m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [
      "We use our built-in function to generate the list of primes below 2 million, and add them. The function is linked below."
    ],
    "solution": "const primes = utils.generatePrimesTable(2000000);\nreturn utils.sumArray(Object.keys(primes), n => +n);",
    "utils": [
      "primes/generatePrimesTable",
      "common/sumArray"
    ]
  },
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      "We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice."
    ],
    "solution": "const sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [
      "Very straightforward, just go through all Fibonacci numbers and add the even ones."
    ],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [
      "<span>Starting with the given number (<span class=\"mono\">currentlyDividing</span>), and the factor 2 (<span class=\"mono\">currentFactor</span>), we divide the given number by the factor until it is not divisible by it anymore.</span>",
      "<span>We then increment <span class=\"mono\">currentFactor</span>, and repeat, until the given number equals 1.</span>"
    ],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [
      "Starting with the largest possible number 999999, we iterate through the list of palindromes from biggest to smallest. This is achieved by decrementing 3 digit numbers from 999 and appending its flipped counterpart (ie. 999999, 998899, 997799, ...). For each palindrome, we test whether it is divisible by a 3 digit number, using the <span class=\"mono\">isPalindromeValid</span> function.",
      "<br /><br />",
      "The function first calculates the square root of the palindrome. If the palindrome is valid, it must have a divisor bigger than the square root AND a divisor smaller than the square root.",
      "For small optimization purposes, if the square root is closer to 100, we search all 3 digit numbers between the square root and 100, Otherwise, we search all 3 digit numbers between the square root and 999."
    ],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [
      "The algorithm works as follows:",
      "<br />",
      "For each number 2, 3, ..., 20.",
      "<br />",
      "We extract its prime factorization. (eg. 12 -> 2^2 * 3^1, 18 -> 2^1 * 3^2)",
      "<br />",
      "We add that factorization to the table <span class=\"mono\">totalPrimeFactors</span>. ",
      "<br />",
      "The table <span class=\"mono\">totalPrimeFactors</span> is encoded such that the keys are the bases, and the entries are the exponents.",
      "<br />",
      "So, going from 2 to 20, iteratively, the array will update as follows:",
      "<br />",
      "<span class=\"mono\">{ 2: 1 }</span> (2 = 2^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 1, 3: 1 }</span> (3 = 3^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1 }</span> (4 = 2^2)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (5 = 5^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1 }</span> (6 = 2^1 * 3^1) Note that nothing has changed, since 2^1 and 3^1 are already part of the array.",
      "<br />",
      "<span class=\"mono\">{ 2: 2, 3: 1, 5: 1, 7: 1 }</span> (7 = 7^1)",
      "<br />",
      "<span class=\"mono\">{ 2: 3, 3: 1, 5: 1, 7: 1 }</span> (8 = 2^3)",
      "<br />",
      "etc.",
      "<br />",
      "At each step, the product of the bases, raised to their respective exponents, will be the least common multiple of all numbers from 2 to the number inserted at that step. ",
      "After the 20th step (we start with step 2), the array will have the information of the least common multiple of all numbers from 2 to 20."
    ],
    "solution": "const totalPrimeFactors = {};\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn Object.keys(totalPrimeFactors).reduce((acc, power) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return acc * (power ** totalPrimeFactors[power]);\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [
      "Pretty self-explanatory"
    ],
    "solution": "let sum1to100 = 0;\nlet sumOfsquares = 0;\nfor (let i = 0; i <= 100; i++) {\n  sum1to100 += i;\n  sumOfsquares += (i ** 2);\n}\nreturn sum1to100 ** 2 - sumOfsquares;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [
      "Check each number 1 by 1, if it's prime we increment our counter, until our counter becomes 10001. The prime checker function is linked below."
    ],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [
      "We start out by \"slimming\" our input. If 12 or less digits are wrapped between two 0s, we can collapse it down to a single 0.",
      "<br />",
      "Then, for each step, we \"move\" to the right, and, instead of multiplying all 13 numbers, we divide by the leftmost number and multiply by the rightmost number."
    ],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substring(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substring(i, i + 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substring(i, i + 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [
      "There is a formula for generating Pythagorean triplets from 2 numbers m > n > 0: ",
      "<br />",
      "a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)",
      "<br />",
      "We use simple algebra to find the following: a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500; (ie. we must find 2 numbers, m and n, such that m(m+n) = 500)",
      "<br />",
      "Since m(m+n) = 500, we can observe that m < sqrt(500). So we search m by decrementing from sqrt(500)."
    ],
    "solution": "let m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [
      "We use our built-in function to generate the list of primes below 2 million, and add them. The function is linked below."
    ],
    "solution": "const primes = utils.generatePrimesTable(2000000);\nreturn utils.sumArray(Object.keys(primes), n => +n);",
    "utils": [
      "primes/generatePrimesTable",
      "common/sumArray"
    ]
  }
]