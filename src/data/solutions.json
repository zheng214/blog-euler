[
  {
    "id": "1",
    "title": "Multiples of 3 and 5",
    "description": [],
    "question": [
      "Find the sum of all the multiples of 3 or 5 below 1000."
    ],
    "guide": [
      "We add all multiples of 3 and 5, and substract multiples of 15 since these are counted twice.",
      "<br />"
    ],
    "solution": "const sum3 = 3 * (333 * 334) / 2; // 3(1 + 2 + ... + 333)\nconst sum5 = 5 * (199 * 200) / 2; // 5(1 + 2 + ... + 199)\nconst sum15 = 15 * (66 * 67) / 2; // 15(1 + 2 + ... + 66)\nreturn sum3 + sum5 - sum15;",
    "utils": []
  },
  {
    "id": "2",
    "title": "Even Fibonacci numbers",
    "description": [],
    "question": [
      "Find the sum of the even-valued Fibonacci numbers whose values do not exceed four million."
    ],
    "guide": [
      "Very straightforward, just go through all Fibonacci numbers and add the even ones.",
      "<br />"
    ],
    "solution": "let [a, b] = [0, 1];\nlet result = 0;\nwhile (a < 4000000) {\n  [a, b] = [b, a + b];\n  if (!utils.isOdd(a)) {\n    result += a;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "3",
    "title": "Largest prime factor",
    "description": [],
    "question": [
      "What is the largest prime factor of the number 600851475143."
    ],
    "guide": [
      "<span>Starting with the given number (<code>currentlyDividing</code>), and the factor 2 (<code>currentFactor</code>), we divide the given number by the factor until it is not divisible by it anymore.</span>",
      "<br />",
      "<span>We then increment <code>currentFactor</code>, and repeat, until the given number equals 1.</span>",
      "<br />"
    ],
    "solution": "let currentlyDividing = 600851475143;\nlet currentFactor = 2;\n// for each currentFactor,\n// we keep dividing the current number by it until it is incapable of doing so\nwhile (currentlyDividing > 1) {\n  while (currentlyDividing % currentFactor === 0) {\n    currentlyDividing /= currentFactor;\n  }\n  if (currentlyDividing === 1) break;\n  currentFactor++;\n}\nreturn currentFactor;",
    "utils": []
  },
  {
    "id": "4",
    "title": "Largest palindrome product",
    "description": [
      "The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99."
    ],
    "question": [
      "Find the largest palindrome made from the product of two 3-digit numbers."
    ],
    "guide": [
      "Starting with the largest possible number 999999, we iterate through the list of palindromes from biggest to smallest. This is achieved by decrementing 3 digit numbers from 999 and appending its flipped counterpart (ie. 999999, 998899, 997799, ...). For each palindrome, we test whether it is divisible by a 3 digit number, using the <code>isPalindromeValid</code> function.",
      "<br />",
      "",
      "<br />",
      "The function first calculates the square root of the palindrome. If the palindrome is valid, it must have a divisor bigger than the square root AND a divisor smaller than the square root.",
      "<br />",
      "For small optimization purposes, if the square root is closer to 100, we search all 3 digit numbers between the square root and 100, Otherwise, we search all 3 digit numbers between the square root and 999.",
      "<br />"
    ],
    "solution": "// searching 6 digits palindromes\nfor (let n = 999; n > 100; n--) {\n  const reversedNumString = n.toString().split('').reverse().join('');\n  const palindrome = Number(`${n.toString()}${reversedNumString}`);\n  if (isPalindromeValid(palindrome)) {\n    return palindrome;\n  }\n}\n// searching 5 digits palindromes\nfor (let m = 99; m > 10; m--) {\n  for (let k = 9; k >= 0; k--) {\n    const reversedNumString = m.toString().split('').reverse().join('');\n    const palindrome = Number(`${m.toString()}${k}${reversedNumString}`);\n    if (isPalindromeValid(palindrome)) {\n      return palindrome;\n    }\n  }\n}\nreturn 'no palindromes found';\n// test whether a palindrome is divisible by a three digit number\nfunction isPalindromeValid(palindrome) {\n  const isValidDivisor = n => Number.isInteger(n) && n >= 100 && n <= 999;\n  const centerQuotient = Math.sqrt(palindrome);\n  if (Number.isInteger(centerQuotient)) {\n    return true;\n  }\n  // determine the search direction based on whether the square root is closer to 100 or 999\n  let searchDirection;\n  if (centerQuotient < 550) {\n    searchDirection = 'down';\n  } else {\n    searchDirection = 'up';\n  }\n  let currentDivisor = searchDirection === 'up'\n    ? Math.ceil(centerQuotient)\n    : Math.floor(centerQuotient);\n  do {\n    if (isValidDivisor(palindrome / currentDivisor)) {\n      return true;\n    }\n    if (searchDirection === 'up') {\n      currentDivisor++;\n    } else {\n      currentDivisor--;\n    }\n  } while (isValidDivisor(currentDivisor));\n  return false;\n}",
    "utils": []
  },
  {
    "id": "5",
    "title": "Smallest multiple",
    "description": [
      "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder."
    ],
    "question": [
      "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?"
    ],
    "guide": [
      "By definition, we are trying to find the least common multiple of 1, 2, 3, ..., 20, or LCM(1, 2, 3, ..., 20)",
      "<br />",
      "We use an inductive reasoning to approach this problem. At each step, we ask ourselves: if my number can divide all of the numbers from 1 to n-1, what do I need to do to make my number also divisible by n?",
      "<br />",
      "",
      "<br />",
      "The algorithm works as follows:",
      "<br />",
      "",
      "<br />",
      "For each number 2, 3, ..., 20. (No need to concern about 1, 1 divides every number)",
      "<br />",
      "",
      "<br />",
      "We extract its prime factorization. (for example, 12 -> 2² * 3¹, 18 -> 2¹ * 3²)",
      "<br />",
      "",
      "<br />",
      "We add that factorization to the table <code>totalPrimeFactors</code>. ",
      "<br />",
      "",
      "<br />",
      "The table <code>totalPrimeFactors</code> is encoded such that the keys are the bases, and the corresponding entries are the exponents. So inserting 12 into our table would yield <code>{ 2: 2, 3: 1 }</code>",
      "<br />",
      "",
      "<br />",
      "So, going from 2 to 20, iteratively, the array will update as follows, step by step:",
      "<br />",
      "",
      "<br />",
      "<code>{ 2: 1 }</code> 2¹ = 2 = LCM(2)",
      "<br />",
      "",
      "<br />",
      "<code>{ 2: 1, 3: 1 }</code> 2² * 3¹ = 6 = LCM(2, 3)",
      "<br />",
      "",
      "<br />",
      "<code>{ 2: 2, 3: 1 }</code> 2² * 3¹ = 12 = LCM(2, 3, 4)",
      "<br />",
      "",
      "<br />",
      "<code>{ 2: 2, 3: 1, 5: 1 }</code> 2² * 3¹ * 5¹ = 60 = LCM(2, 3, 4, 5)",
      "<br />",
      "",
      "<br />",
      "<code>{ 2: 2, 3: 1, 5: 1 }</code> 2² * 3¹ * 5¹ = 60 = LCM(2, 3, 4, 5, 6) Note that nothing has changed, since 2¹ and 3¹ are already inserted earlier.",
      "<br />",
      "",
      "<br />",
      "<code>{ 2: 2, 3: 1, 5: 1, 7: 1 }</code> 2² * 3¹ * 5¹ * 7¹ = 420 = LCM(2, 3, 4, 5, 6, 7)",
      "<br />",
      "",
      "<br />",
      "<code>{ 2: 3, 3: 1, 5: 1, 7: 1 }</code> 2³ * 3¹ * 5¹ * 7¹ = 840 = LCM(2, 3, 4, 5, 6, 7, 8)",
      "<br />",
      "",
      "<br />",
      "etc.",
      "<br />",
      "",
      "<br />",
      "At step n, the product of the bases, raised to their respective exponents, will be the least common multiple of all numbers from 1 to n. In other words, it is the smallest number which is divisible by all numbers from 1 to n.",
      "<br />",
      "After the 20th step, the array will have the information of the least common multiple of all numbers from 1 to 20.",
      "<br />"
    ],
    "solution": "const totalPrimeFactors = {};\nfor (let n = 2; n <= 20; n++) {\n  const primeFactors = utils.listPrimeFactors(n); // (1)\n  // we start at 2 since the first two elements are always empty\n  for (let factor = 2; factor < primeFactors.length; factor++) {\n    const computedPower = primeFactors[factor];\n    const existingPower = totalPrimeFactors[factor];\n    if (computedPower && (!existingPower || computedPower > existingPower)) { // (2)\n      totalPrimeFactors[factor] = primeFactors[factor];\n    }\n  }\n}\nreturn Object.keys(totalPrimeFactors).reduce((acc, power) => { // (3)\n  // by definition of totalPrimeFactors, the indexes represent the bases of the prime factorization\n  return acc * (power ** totalPrimeFactors[power]);\n}, 1);",
    "utils": [
      "arithmetic/listPrimeFactors"
    ]
  },
  {
    "id": "6",
    "title": "Sum square difference",
    "description": [],
    "question": [
      "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum."
    ],
    "guide": [
      "Pretty self-explanatory",
      "<br />"
    ],
    "solution": "let sum1to100 = 0;\nlet sumOfsquares = 0;\nfor (let i = 0; i <= 100; i++) {\n  sum1to100 += i;\n  sumOfsquares += (i ** 2);\n}\nreturn sum1to100 ** 2 - sumOfsquares;",
    "utils": []
  },
  {
    "id": "7",
    "title": "10001st prime",
    "description": [],
    "question": [
      "What is the 10001st prime number?"
    ],
    "guide": [
      "Check each number 1 by 1, if it's prime we increment our counter, until our counter becomes 10001. The prime checker function is linked below.",
      "<br />"
    ],
    "solution": "let number = 1;\nlet nthPrime = 0;\nwhile (nthPrime < 10001) {\n  number++;\n  if (utils.isPrime(number)) {\n    nthPrime++;\n  }\n}\nreturn number;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "8",
    "title": "Largest product in a series",
    "description": [],
    "question": [
      "Find the thirteen adjacent digits in the [1000-digit number @asset 'p8_data.txt'] that have the greatest product."
    ],
    "guide": [
      "We start out by \"slimming\" our input. If 12 or less digits are wrapped between two 0s, we can collapse it down to a single 0.",
      "<br />",
      "",
      "<br />",
      "Then, for each step, we \"move\" to the right, and, instead of multiplying all 13 numbers, we divide by the leftmost number and multiply by the rightmost number.",
      "<br />"
    ],
    "solution": "const data8 = require('./p8_data');\nconst formattedNumber = data8.replace(/\\r|\\n|\\s/g, ''); // one line of string\n// if 12 or less digits are wrapped between two 0s, we can collapse it\nconst slimNumber = formattedNumber.replace(/0\\d{0,12}0/g, '0');\n// initial product\nlet largestProduct = slimNumber.substring(0, 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n// initial digit\nlet previousDigit = 7;\nlet newProduct;\nfor (let i = 1; i < slimNumber.length - 13; i++) {\n  // if our substring contains an 0, we can skip it\n  if (!slimNumber.substring(i, i + 13).includes('0')) {\n    // since each iteration have 12 digits in common with the previous iteration\n    // we use our previously computed product, divide the digit that came before it,\n    // and multiply the digit that comes after\n    if (slimNumber[i - 1] === '0') { // make sure we don't divide by 0\n      newProduct = slimNumber.substring(i, i + 13).split('').reduce((acc, curr) => acc * Number(curr), 1);\n    } else {\n      newProduct = newProduct / previousDigit * Number(slimNumber[i + 12]);\n    }\n    previousDigit = Number(slimNumber[i]);\n    if (newProduct > largestProduct) {\n      largestProduct = newProduct;\n    }\n  }\n}\nreturn largestProduct;",
    "utils": []
  },
  {
    "id": "9",
    "title": "Special Pythagorean triplet",
    "description": [],
    "question": [
      "There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc."
    ],
    "guide": [
      "There is a formula for generating Pythagorean triplets from 2 numbers m > n > 0: ",
      "<br />",
      "",
      "<br />",
      "a = m^2-n^2, b = 2mn, c = m^2+n^2 (euclid)",
      "<br />",
      "",
      "<br />",
      "We use simple algebra to find the following: a+b+c = 1000 => 2m(m+n) = 1000 => m(m+n) = 500; (ie. we must find 2 numbers, m and n, such that m(m+n) = 500)",
      "<br />",
      "",
      "<br />",
      "Since m(m+n) = 500, we can observe that m < sqrt(500). So we search m by decrementing from sqrt(500).",
      "<br />"
    ],
    "solution": "let m = Math.floor(Math.sqrt(500));\nwhile (m > 1) {\n  const quotient = 500 / m;\n  const n = quotient - m;\n  if (Number.isInteger(n) && Number.isInteger(m) && m > n) {\n    return ((m ** 2) - (n ** 2)) * (2 * m * n) * ((m ** 2) + (n ** 2)); // a * b * c\n  }\n  m--;\n}\nreturn 0;",
    "utils": []
  },
  {
    "id": "10",
    "title": "Summation of primes",
    "description": [],
    "question": [
      "Find the sum of all the primes below two million."
    ],
    "guide": [
      "We use our built-in function to generate the list of primes below 2 million, and add them. The function is linked below.",
      "<br />"
    ],
    "solution": "const primes = utils.generatePrimesTable(2000000);\nreturn utils.sumArray(Object.keys(primes), n => +n);",
    "utils": [
      "primes/generatePrimesTable",
      "common/sumArray"
    ]
  },
  {
    "id": "11",
    "title": "Largest product in a grid",
    "description": [],
    "question": [
      "What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, diagonal) in this [20×20 grid @asset p11_data.txt]?"
    ],
    "guide": [
      "From top left to bottom right, we go through each coordinate one by one. For each coordinate, we calculate:",
      "<br />",
      "- The product of number at the coordinate and the 3 numbers to the right of it, if applicable.",
      "<br />",
      "- The product of number at the coordinate and the 3 numbers beneath it, if applicable.",
      "<br />",
      "- The product of number at the coordinate and the 3 numbers diagonally top-right of it, if applicable.",
      "<br />",
      "- The product of number at the coordinate and the 3 numbers diagonally bottom-right it, if applicable.",
      "<br />",
      "And we update the highest score, as needed.",
      "<br />"
    ],
    "solution": "const data11 = require('./p11_data');\nconst grid = data11.split(/\\n/).map(row => row.trim().split(' '));\nlet highestScore = 0;\nfor (let row = 0; row < 20; row++) {\n  for (let column = 0; column < 20; column++) {\n    const horizontalScore = computeProduct(grid[row].slice(column, column + 4));\n    const verticalScore = computeProduct(grid.slice(row, row + 4).map(x => x[column]));\n    const upDiagScore = computeProduct(grid.slice(row - 3, row + 1).map((x, index) => x[column + 4 - index]));\n    const downDiagScore = computeProduct(grid.slice(row, row + 4).map((x, index) => x[column + index]));\n    const highestOfCoord = Math.max(horizontalScore, verticalScore, upDiagScore, downDiagScore);\n    if (highestOfCoord > highestScore) highestScore = highestOfCoord;\n  }\n}\nreturn highestScore;\nfunction computeProduct(arr) {\n  if (arr.length !== 4 || arr.includes(undefined)) {\n    return 0;\n  }\n  return arr.reduce((acc, curr) => (curr || 0) * acc, 1);\n}",
    "utils": []
  },
  {
    "id": "12",
    "title": "Highly divisible triangular number",
    "description": [
      "28 is the 5th triangle number, and it has 6 divisors (1, 2, 4, 7, 14, 28)."
    ],
    "question": [
      "What is the value of the first triangle number to have over five hundred divisors?"
    ],
    "guide": [
      "Let D(n) denote the number of divisors of n.",
      "<br />",
      "We rely on the fact that D(a * b) = D(a) * D(b). That's just how math works.",
      "<br />",
      "So, given triangle number t generated by n(n+1)/2, we can compute the number of divisors of t, D(t) by:",
      "<br />",
      "1. D(t) = D(n/2) * D(n+1) if n is even OR",
      "<br />",
      "2. D(t) = D(n) * D((n+1)/2) if n + 1 is even",
      "<br />",
      "",
      "<br />",
      "",
      "<br />",
      "To illustrate how the algorithm works, I will provide an example when n = 10 and n = 11",
      "<br />",
      "",
      "<br />",
      "n = 10, triangle = 55:",
      "<br />",
      "Since n is even, we calculate D(n+1), ie. D(11), and store it in <code>nextComputedDivisorsCount</code>.",
      "<br />",
      "We calculate D(55) = D(11) * D(5), D(5) is stored in <code>lastComputedDivisorsCount</code>, obtained from the previous step, when n = 9.",
      "<br />",
      "We transfer <code>nextComputedDivisorsCount</code> to <code>lastComputedDivisorsCount</code>.",
      "<br />",
      "So now <code>lastComputedDivisorsCount</code> contains D(11);",
      "<br />",
      "",
      "<br />",
      "n = 11, triangle = 66:",
      "<br />",
      "Since n is odd, we calculate D((n + 1) / 2), ie. D(6), and store it in <code>nextComputedDivisorsCount</code>.",
      "<br />",
      "We calculate D(66) = D(11) * D(6), D(11) is obtained from the previous step, when n = 10, from the variable <code>lastComputedDivisorsCount</code>.",
      "<br />",
      "And we repeat till D(n) > 500.",
      "<br />"
    ],
    "solution": "let totalDivisorsCount = 0;\nlet n = 2;\nlet nEven = true;\nlet lastComputedDivisorsCount = 1; // D(1) = 1\n// comments are the example when n = 10\nwhile (totalDivisorsCount <= 500) {\n  const triangle = n * (n + 1) / 2; // triangle = 55\n  let nextComputedDivisorsCount = 0;\n  if (nEven) {\n    nextComputedDivisorsCount = computeDivisorsCount(n + 1); // nextComputedDivisorsCount = D(11)\n  } else {\n    nextComputedDivisorsCount = computeDivisorsCount((n + 1) / 2);\n  }\n  totalDivisorsCount = lastComputedDivisorsCount * nextComputedDivisorsCount; // D(5) * D(11)\n  if (totalDivisorsCount > 500) {\n    return triangle;\n  }\n  lastComputedDivisorsCount = nextComputedDivisorsCount;\n  nEven = !nEven;\n  n++;\n}\n// check all integers up to sqrt(number)\n// we increment the count by 2 for each divisor found,\n// as each divisor has a complementary divisor (except for the square root)\nfunction computeDivisorsCount(number) {\n  const root = Math.sqrt(number);\n  let count = 0;\n  let divisor = Math.floor(root);\n  if (divisor === root) {\n    count++;\n    divisor--;\n  }\n  while (divisor > 0) {\n    if (!(number % divisor)) {\n      count += 2;\n    }\n    divisor--;\n  }\n  return count;\n}",
    "utils": []
  },
  {
    "id": "13",
    "title": "Large sum",
    "description": [],
    "question": [
      "Work out the first ten digits of the sum of the following one-hundred [50-digit numbers @asset p13_data.txt]."
    ],
    "guide": [
      "The algorithms works as follows:",
      "<br />",
      "1. Add to <code>sum</code> all digits at position 0 for each number (leftmost)",
      "<br />",
      "2. Multiply <code>sum</code> by 10.",
      "<br />",
      "3. Add to <code>sum</code> all digits at position 1 for each number",
      "<br />",
      "4. Multiply <code>sum</code> by 10.",
      "<br />",
      "5. We repeat this process until the first 10 digits of <code>sum</code> aren't affected by the sum of digits in the lesser positions.",
      "<br />"
    ],
    "solution": "const data13 = require('./p13_data');\n// filter out the first line which is undefined and remove whitespace (see data.js)\nconst numbers = data13.split(/\\n/g).filter(x => x).map(x => x.trim());\nlet sum = 0;\nfor (let position = 0; position < 50; position++) {\n  sum += sumNthDigits(position);\n  const first10DigitsCurrent = sum.toString(10).substring(0, 10);\n  // shift the sum left to prepare for the sum of next 100 digits\n  sum *= 10;\n  // determine if the sum of the next 100 digits can affect the first 10 digits\n  // ie. consider all the digits at the next position are 9s\n  const maxValueForNextPosition = sum + 900;\n  const first10DigitsNext = maxValueForNextPosition.toString(10).substring(0, 10);\n  if (first10DigitsCurrent === first10DigitsNext) {\n    return +(first10DigitsCurrent);\n  }\n}\nfunction sumNthDigits(n) {\n  return numbers.map(num => +(num[n])).reduce((acc, curr) => acc + curr, 0);\n}",
    "utils": []
  },
  {
    "id": "14",
    "title": "Longest Collatz sequence",
    "description": [
      "The following iterative sequence is defined for the set of positive integers:",
      null,
      "n → n/2 (n is even)",
      null,
      "n → 3n + 1 (n is odd)",
      null,
      "Using the rule above and starting with 13, we generate the following sequence (Collatz):",
      null,
      "13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1",
      null
    ],
    "question": [
      "Which starting number, under one million, produces the longest chain?"
    ],
    "guide": [
      "For each number n below one million, we apply the Collatz sequence to it until it reaches 1, while keeping track of the sequence length in the <code>chainLengthArr</code> array.",
      "<br />"
    ],
    "solution": "// we use 2 variables to keep track of the highest chain count and the starting number associated with it\nlet longestChainNumber = 0;\nlet longestChain = 0;\n// we use an array to keep track of the length of each starting number,\n// where the index correspond to the starting number\nconst chainLengthArr = [];\n// we start at 500000 because if the longest chain c is below 500000,\n// then there must be a longer chain at c * 2\nfor (let i = 500001; i <= 1000000; i += 1) {\n  computeChainLength(i, 0);\n}\nfunction computeChainLength(n, accumulatedLength) {\n  // as mentionned above, we do not need to consider numbers below 500001\n  if (n < 500001) {\n    return accumulatedLength;\n  }\n  if (chainLengthArr[n]) {\n    const totalChainLength = chainLengthArr[n] + accumulatedLength;\n    return totalChainLength;\n  }\n  let result;\n  if (utils.isOdd(n)) {\n    // if n is odd then 3n + 1 is even, we can skip a step by passing (3n+1)/2 as an argument\n    result = computeChainLength((3 * n + 1) / 2, accumulatedLength + 2);\n  } else {\n    result = computeChainLength(n / 2, accumulatedLength + 1);\n  }\n  // when the result returns, we need to update the chain length number of each number in the chain\n  // we do so by subtracting the accumulator associated with that number from the result (back propagation)\n  // eg: 5 -> 16 -> 8 -> 4 -> 2 -> 1\n  // stack trace:\n  // computeChainLength(5, 0) -> result - 0 = 5\n  // computeChainLength(16, 1) -> result - 1 = 4\n  // computeChainLength(8, 2) -> result - 2 = 3\n  // computeChainLength(4, 3) -> result - 3 = 2\n  // computeChainLength(2, 4) -> result - 4 = 1\n  // computeChainLength(1, 5) -> result - 5 = 0\n  // result = 5\n  // the memoized array will then be updated will the correct values (5 with 5, 16 with 4, etc.)\n  chainLengthArr[n] = result - accumulatedLength;\n  if (chainLengthArr[n] > longestChain) {\n    longestChain = chainLengthArr[n];\n    longestChainNumber = n;\n  }\n  return result;\n}\nreturn longestChainNumber;",
    "utils": [
      "arithmetic/isOdd"
    ]
  },
  {
    "id": "15",
    "title": "Lattice paths",
    "description": [
      "Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.",
      null,
      "@image p015.png",
      null
    ],
    "question": [
      "How many such routes are there through a 20×20 grid?"
    ],
    "guide": [
      "This problem is equivalent to:",
      "<br />",
      "Given 20 characters \"r\" (right) and 20 characters \"d\" (down), how many ways are there to write a string using exactly those 40 characters?",
      "<br />",
      "The answer is just 40 choose 20, as it is equivalent of choosing the locations of the 20 \"r\" inside our string",
      "<br />"
    ],
    "solution": "return utils.fact(40) / (utils.fact(20) * utils.fact(20));",
    "utils": [
      "combinatorics/fact"
    ]
  },
  {
    "id": "16",
    "title": "Power digit sum",
    "description": [
      "2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26."
    ],
    "question": [
      "What is the sum of the digits of the number 2^1000?"
    ],
    "guide": [
      "We iteratively multiply our result by 2 and we:",
      "<br />",
      "1. store each digit inside an array (the array is \"reversed\": 1024 is stored as [4,2,0,1])",
      "<br />",
      "2. increment the total sum of digits by the correct amount",
      "<br />"
    ],
    "solution": "let resultArr = [2];\nlet sumOfDigits = 2;\nfor (let exponent = 2; exponent <= 1000; exponent++) {\n  let carry = false;\n  // iterate over each digit inside the array and multiply each digit by 2,\n  // if digit > 5, we set carry to true\n  resultArr = resultArr.reduce(\n    (acc, digit, index) => {\n      if (digit >= 5) {\n        // we only need the last digit of the result\n        // (e.g. 6 * 2 = 12 -> 2, the 1 will be carried over)\n        acc[index] = 2 * digit - 10;\n        // we compute the update rule for sumOfDigits by:\n        // net amount = (digit at current iteration) - (digit at previous iteration) + 1(carry)\n        // = (2 * digit - 10) - digit + 1\n        // = digit - 9\n        sumOfDigits += (digit - 9);\n      } else {\n        // if digit < 5, it is much simpler, just multiply the digit by 2\n        acc[index] = 2 * digit;\n        // net amount = (digit at current iteration) - (digit at previous iteration)\n        // = (2 * digit) - digit\n        // = digit\n        sumOfDigits += digit;\n      }\n      // increment current digit by 1 if carry is true\n      if (carry) acc[index]++;\n      // set carry for next iteration\n      carry = (digit > 4);\n      return acc;\n    },\n    resultArr,\n  );\n  // if we exited the reduce with a carry left over, need to add(append) 1 to the array\n  if (carry) {\n    resultArr.push(1);\n  }\n}\nreturn sumOfDigits;",
    "utils": []
  },
  {
    "id": "17",
    "title": "Number letter counts",
    "description": [
      "If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total."
    ],
    "question": [
      "If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?"
    ],
    "guide": [
      "The comments in the code illustrates how the counting is performed.",
      "<br />",
      "Notation:",
      "<br />",
      "- <code>2<1-9></code> means 21, 22, 23, ..., 29",
      "<br />",
      "- <code><2-9>0</code> means 20, 30, 40, ..., 90",
      "<br />"
    ],
    "solution": "const oneToNine = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];\nconst elevenToNineteen = ['eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen'];\nconst twentyToNinetyBy10 = ['twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety'];\n// to get count of 1 - 99, we sum the following components:\n// 1. <1-9> * 9 -> [<1-9>, 2<1-9>, 3<1-9>, ..., 9<1-9>]\n// 2. <11-19>\n// 3. <2-9>0 * 10 -> [<2-9>0, <0-9>1, <2-9>2. ..., <2-9>9]\n// 4. <10>\nconst oneTo99 = countLetters(oneToNine) * 9 + countLetters(elevenToNineteen) + countLetters(twentyToNinetyBy10) * 10 + 3;\nconst oneTo999 = oneTo99 * 10 + oneToNine.reduce((acc, x) => {\n  // \"<x> hundred and\" * 99 + \"<x> hundred\"\n  return acc + (x.length + 10) * 99 + (x.length + 7);\n}, 0);\n// <1000>\nreturn oneTo999 + 11;\nfunction countLetters(arr) {\n  return arr.join('').length;\n}",
    "utils": []
  },
  {
    "id": "18",
    "title": "Maximum path sum I",
    "description": [
      "By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.",
      null,
      "    3",
      null,
      "   7 4",
      null,
      "  2 4 6",
      null,
      " 8 5 9 3",
      null,
      "That is, 3 + 7 + 4 + 9 = 23.",
      null
    ],
    "question": [
      "Find the maximum total from top to bottom of [this triangle @asset p18_triangle.txt]."
    ],
    "guide": [
      "We iterate through each row, and for each number in each row, we keep track of the maximum total from the top to that number.",
      "<br />",
      "We go down the rows using this update rule:",
      "<br />",
      "Each number has two numbers above it, named \"left parent\" and \"right parent\". The maximum from the top to a number is the largest of the maximum from top to \"left parent\" and the maximum from top to \"right parent\".",
      "<br />"
    ],
    "solution": "const data18 = `\n75\n95 64\n17 47 82\n18 35 87 10\n20 04 82 47 65\n19 01 23 75 03 34\n88 02 77 73 07 63 67\n99 65 04 28 06 16 70 92\n41 41 26 56 83 40 80 70 33\n41 48 72 33 47 32 37 16 94 29\n53 71 44 65 25 43 91 52 97 51 14\n70 11 33 28 77 73 17 78 39 68 17 57\n91 71 52 38 17 14 91 43 58 50 27 29 48\n63 66 04 68 89 53 67 30 73 16 69 87 40 31\n04 62 98 27 23 09 70 98 73 93 38 53 60 04 23`;\n// parse the triangle into a 2D array\n// 1. transform it into an array where each element is a row eg. ['75', '95 64', ...]\nconst formattedRows = data18.split('\\n').map(x => x.trimStart());\n// 2. transform each row into an array of numbers eg. [[75], [95, 64], ...]\nconst dataArray = formattedRows.map(\n  x => x.split(' ').map( // split the string by space\n    y => +(y), // for each element splitted, transform it into a Number\n  ),\n).slice(1); // remove the first element (there is a newline character at the start of the string in data.js)\n// keeps track of the maximum score from the top to each number in the previous/current row\nlet scoresOfPreviousRow = [];\n// keeps track of the path from the top to each number corresponding to the scores computed above\n// (not required for the problem)\nlet optimalpathsToPreviousRow = [];\ndataArray.forEach((row, rowIndex) => {\n  const tempScores = [];\n  const tempPaths = [];\n  row.forEach((number, position) => {\n    const isFirst = position === 0;\n    const isLast = position === row.length - 1;\n    if (rowIndex === 0) {\n      tempScores[0] = number;\n      tempPaths[0] = '0';\n    } else if (isFirst) {\n      tempScores[0] = scoresOfPreviousRow[0] + number;\n      tempPaths[0] = `${optimalpathsToPreviousRow[0]}0`;\n    } else if (isLast) {\n      tempScores[position] = scoresOfPreviousRow[position - 1] + number;\n      tempPaths[position] = `${optimalpathsToPreviousRow[position - 1]}${position}`;\n    // is middle\n    // right parent is bigger\n    } else if (scoresOfPreviousRow[position] > scoresOfPreviousRow[position - 1]) {\n      tempScores[position] = scoresOfPreviousRow[position] + number;\n      tempPaths[position] = `${optimalpathsToPreviousRow[position]}${position}`;\n    // left parent is bigger\n    } else {\n      tempScores[position] = scoresOfPreviousRow[position - 1] + number;\n      tempPaths[position] = `${optimalpathsToPreviousRow[position - 1]}${position}`;\n    }\n  });\n  scoresOfPreviousRow = tempScores;\n  optimalpathsToPreviousRow = tempPaths;\n});\nreturn Math.max(...scoresOfPreviousRow);",
    "utils": []
  },
  {
    "id": "19",
    "title": "Counting Sundays",
    "description": [
      "1 Jan 1900 was a Monday.",
      "A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400."
    ],
    "question": [
      "How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?"
    ],
    "guide": [
      "We just loop through each month of each year, and calculate that day's distance to 1 Jan 1900.",
      "<br />",
      "From that distance we can tell if the day is a sunday or not, by computing it's remainder when dividing by 7.",
      "<br />"
    ],
    "solution": "let currentDistance = 365; // 1 jan 1901 - 1 jan 1900\nlet sundays = 0;\nconst oddMonths = [1, 3, 5, 7, 8, 10, 12]; // 31 days\nconst evenMonths = [4, 6, 9, 11]; // 30 days\nfor (let year = 1901; year <= 2000; year++) {\n  const isLeapYear = (year % 4 === 0);\n  for (let month = 1; month <= 12; month++) {\n    if (currentDistance % 7 === 6) {\n      sundays++;\n    }\n    if (oddMonths.includes(month)) {\n      currentDistance += 31;\n    } else if (evenMonths.includes(month)) {\n      currentDistance += 30;\n    } else if (isLeapYear) {\n      currentDistance += 29;\n    } else {\n      currentDistance += 28;\n    }\n  }\n}\nreturn sundays;",
    "utils": []
  },
  {
    "id": "20",
    "title": "Factorial digit sum",
    "description": [],
    "question": [
      "Find the sum of the digits in the number 100!"
    ],
    "guide": [
      "We use the same procedure as in problem 16, ie. we store our digits in an array, and each step we manually multiply each digit.",
      "<br />"
    ],
    "solution": "let resultArr = [1];\nfor (let i = 1; i < 101; i++) {\n  const multiplier = i % 10 === 0 ? i / 10 : i; // multiplying by 90 has the same \"effect\" as multiplying by 9\n  const productArr = resultArr.map(x => x * multiplier);\n  resultArr = consolidate(productArr);\n}\nreturn utils.sumArray(resultArr);\n// \"flatten\" an array of products\n// eg. 25 * 25 => [5, 2] * 25 => [125, 50](input) => [5, 2 + 0, 1 + 5] => [5, 2, 6](output) => 625\nfunction consolidate(productArr) {\n  let output = productArr.reduce(\n    (acc, product, index) => {\n      const productDigits = product.toString().split('').reverse().map(x => +(x)); // 125 => [5, 2, 1]\n      productDigits.forEach((digit, i) => {\n        acc[index + i] = acc[index + i] ? acc[index + i] + digit : digit;\n      });\n      return acc;\n    },\n    [],\n  );\n  if (output.find(x => x >= 10)) {\n    output = consolidate(output);\n  }\n  return output;\n}",
    "utils": [
      "common/sumArray"
    ]
  },
  {
    "id": "21",
    "title": "Amicable numbers",
    "description": [
      null,
      "Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).",
      null,
      "If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair and each of a and b are called amicable numbers.",
      null,
      "The proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284",
      null,
      "The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.",
      null
    ],
    "question": [
      "Evaluate the sum of all the amicable numbers under 10000."
    ],
    "guide": [
      "We observe that, by definition, a number n has an amicable pair if and only if d(d(n)) = n.",
      "<br />",
      "",
      "<br />",
      "A number cannot be an amicable pair to itself, so for each number i under 10000, we check that is not perfect, ie. d(i) = i.",
      "<br />",
      "Then if it satisfies d(d(i)) = i, we add it to the list, and sum the list at the end.",
      "<br />"
    ],
    "solution": "const primesUnder10000 = utils.generatePrimesTable(10000);\nconst amicableNumbers = [];\nfor (let i = 0; i < 10000; i++) {\n  if (!primesUnder10000[i] && !amicableNumbers.includes(i)) {\n    // d(i)\n    const sumOfDivisors = utils.computeSumOfDivisors(i);\n    // ensure i is not a perfect number (d(i) = i)\n    // which does not qualify as an amicable number by definition\n    if (sumOfDivisors !== i) {\n      // now check if d(d(i)) === i\n      if (utils.computeSumOfDivisors(sumOfDivisors) === i) {\n        amicableNumbers.push(i);\n        amicableNumbers.push(sumOfDivisors);\n      }\n    }\n  }\n}\nreturn utils.sumArray(amicableNumbers);",
    "utils": [
      "primes/generatePrimesTable",
      "arithmetic/computeSumOfDivisors",
      "common/sumArray"
    ]
  },
  {
    "id": "22",
    "title": "Names scores",
    "description": [
      null,
      "Using [p22_names.txt @asset p22_names.txt], a 46K text file containing over five-thousand first names. Begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.",
      null,
      "When the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would obtain a score of 938 × 53 = 49714.",
      null
    ],
    "question": [
      "What is the total of all the name scores in the file?"
    ],
    "guide": [
      "Very straightforward, just go down the list and add the name scores one by one.",
      "<br />"
    ],
    "solution": "const stringNames = fs.readFileSync(path.join(__dirname, 'p22_names.txt')).toString();\nconst arrayNames = stringNames.split(',');\nconst sortedNames = arrayNames.sort();\nreturn sortedNames.reduce(\n  (totalScore, name, index) => {\n    const i = index + 1;\n    const scoreOfName = i * utils.sumArray(\n      name.split(''), // 'AARON' => ['A', 'A', 'R', 'O', 'N']\n      n => n.charCodeAt() - 64, // a -> 1, r -> 18, etc.\n    );\n    return totalScore + scoreOfName;\n  },\n  0,\n);",
    "utils": [
      "common/sumArray"
    ]
  },
  {
    "id": "23",
    "title": "Non-abundant sums",
    "description": [
      null,
      "A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.",
      null,
      "By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers.",
      null,
      "However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.",
      null,
      "As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24.",
      null
    ],
    "question": [
      "Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers."
    ],
    "guide": [
      "Since all numbers above 28123 can be written as the sum of two abundant numbers, we only need to check numbers from 1 to 28123 inclusively.",
      "<br />",
      "",
      "<br />",
      "To do so, for each number i in 1 to 28123, we:",
      "<br />",
      "1. Check if it's abundant, if so, we insert it in the <code>abundantNumbers</code> table.",
      "<br />",
      "2. We substract i by every abundant number encountered so far, if the result of that substraction is another abundant number, then it does not satisfy our condition. And vice-versa.",
      "<br />"
    ],
    "solution": "const abundantNumbers = {};\nlet result = 0;\nfor (let i = 1; i <= 28123; i++) {\n  if (utils.computeSumOfDivisors(i) > i) {\n    abundantNumbers[i] = true;\n  }\n  // check if number can be written as sum of two abundant numbers\n  let canBeSummed = false;\n  const abundantNumbersArray = Object.keys(abundantNumbers);\n  for (let j = 0; j < abundantNumbersArray.length; j++) {\n    if (abundantNumbersArray[j] > i / 2) {\n      break; // we don't need to check for numbers above i / 2\n    }\n    if (abundantNumbers[i - abundantNumbersArray[j]]) {\n      canBeSummed = true;\n      break;\n    }\n  }\n  if (!canBeSummed) {\n    result += i;\n  }\n}\nreturn result;",
    "utils": [
      "arithmetic/computeSumOfDivisors"
    ]
  },
  {
    "id": "24",
    "title": "Lexicographic permutations",
    "description": [
      null,
      "A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4.",
      null,
      "If all of the permutations are listed numerically or alphabetically, we call it lexicographic order.",
      null,
      "The lexicographic permutations of 0, 1 and 2 are:",
      null,
      " 012   021   102   120   201   210",
      null
    ],
    "question": [
      "What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?"
    ],
    "guide": [
      "We achieve the answer to the question in two steps. First we find the factorial number representation of one million. Second we use that representation to 'calculate' our permutation.",
      "<br />",
      "",
      "<br />",
      "1. Factorial number system representation",
      "<br />",
      "For example, let's use the number 5",
      "<br />",
      "decimal -> factorial",
      "<br />",
      "<code>0 -> 00(fact)</code>",
      "<br />",
      "<code>1 -> 1 * 1! -> 01 (fact)</code>",
      "<br />",
      "<code>2 -> 1 * 2! + 0 * 1! -> 10(fact)</code>",
      "<br />",
      "<code>3 -> 1 * 2! + 1 * 1! -> 11(fact)</code>",
      "<br />",
      "<code>4 -> 2 * 2! -> 20(fact)</code>",
      "<br />",
      "<code>5 -> 2 * 2! + 1 * 1! -> 21(fact)</code>",
      "<br />",
      "<code>6 -> 1 * 3! -> 100(fact)</code>",
      "<br />",
      "",
      "<br />",
      "2. Using a Factorial number representation to 'calculate' a permutation",
      "<br />",
      "We iteratively write our permutation, with the following rule: Each digit in the factorial representation decides the index from which we grab our next digit from the remaining digits. It sounds confusing, so here is an example.",
      "<br />",
      "",
      "<br />",
      "For example, if we want the 5th permutation of 1234",
      "<br />",
      "We find the factorial representation of 5, which is 021.",
      "<br />",
      "The first digit is 0, so we pick the 1st digit from 1234, we get 1, this is our first digit of the result.",
      "<br />",
      "The second digit is 2, so we pick the 3rd digit from the <i>remaining</i> digits, ie 234, we get 4, this is the second digit of the result.",
      "<br />",
      "The third digit is 1, so we pick the 2nd digit from the <i>remaining</i> digits, ie 23, we get 3, this is the third digit of the result.",
      "<br />",
      "The only digit left is 2, so our final result is 1432.",
      "<br />"
    ],
    "solution": "const ONE_MILLION = 1000000;\nconst factorialRepr = utils.convertToFactorialBase(ONE_MILLION - 1);\nlet remainingDigits = '0123456789';\nlet result = '';\nfor (let k = 0; k < factorialRepr.length; k++) {\n  const indexToGrab = factorialRepr.charAt(k);\n  result += remainingDigits[indexToGrab];\n  remainingDigits = remainingDigits.replace(`${remainingDigits[indexToGrab]}`, '');\n}\n// add last digit remaining\nreturn +(result + remainingDigits);",
    "utils": [
      "combinatorics/convertToFactorialBase"
    ]
  },
  {
    "id": "25",
    "title": "1000-digit Fibonacci number",
    "description": [],
    "question": [
      "What is the index of the first term in the Fibonacci sequence to contain 1000 digits?"
    ],
    "guide": [
      "Since javascript numbers only handles up to ~ 1.7976931348623157e+308, we have to add each digit manually and store them inside an array.",
      "<br />",
      "e.g. [2, 4] + [3, 8] => [6, 2]",
      "<br />",
      "e.g. [1, 4, 5] + [8, 5, 5] => [1, 0, 0, 0]",
      "<br />"
    ],
    "solution": "let [a, b] = [[1], [1]];\nlet index = 2;\nwhile (b.length < 1000) {\n  index++;\n  [a, b] = [b, manualSum(a, b)];\n}\nreturn index;\nfunction manualSum(arr1, arr2) {\n  const a1 = arr1.length >= arr2.length ? [...arr1].reverse() : [...arr2].reverse(); // longer array\n  const a2 = arr1.length >= arr2.length ? [...arr2].reverse() : [...arr1].reverse(); // shorter array\n  const result = [];\n  let carry = 0;\n  for (let i = 0; i < a1.length; i++) {\n    const partialResult = a1[i] + (a2[i] || 0) + carry;\n    if (partialResult >= 10) {\n      carry = 1;\n      result[i] = partialResult - 10;\n    } else {\n      carry = 0;\n      result[i] = partialResult;\n    }\n  }\n  if (carry) {\n    result.push(1);\n  }\n  return result.reverse();\n}",
    "utils": []
  },
  {
    "id": "26",
    "title": "Reciprocal cycles",
    "description": [
      "The decimal representation of the unit fractions with denominators 2 to 10 are given:",
      null,
      " 1/2 = 0.5",
      null,
      " 1/3 = 0.(3)",
      null,
      " 1/4 = 0.25",
      null,
      " 1/5 = 0.2",
      null,
      " 1/6 = 0.1(6)",
      null,
      " 1/7 = 0.(142857)",
      null,
      " 1/8 = 0.125",
      null,
      " 1/9 = 0.(1)",
      null,
      " 1/10 = 0.1",
      null,
      "Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.",
      null
    ],
    "question": [
      "Find the value of d < 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part."
    ],
    "guide": [
      "First, we can skip numbers that are divisible by 2, 3 or 5, as they are either terminating (2, 5) or have only 1 repeating digit (3).",
      "<br />",
      "For each number i in 1 to 1000, we do a manual long division on it, the way we learned in primary school.",
      "<br />",
      "At each step in the division, we will obtain a remainder, that remainder will be stored in <code>remainders</code>.",
      "<br />",
      "We repeat until we find a remainder that we have already seen, i.e. in the array <code>remainders</code>.",
      "<br />",
      "At this point, the length of <code>remainders</code> will be the recurring cycle length.",
      "<br />"
    ],
    "solution": "let longestRecurringCycle = 0;\nlet longestRecurringCycleValue = 0;\nfor (let i = 1; i < 1000; i++) {\n  // we can skip numbers that are divisible by 2, 3 or 5, as they are either terminating (2, 5) or have only 1 repeating digit (3)\n  if (i % 2 && i % 3 && i % 5) {\n    // we manually divide 1/i, and keep track of the remainders,\n    // if a remainder is in the list of seen remainders,\n    // then the length of the seen remainders is the length recurrent cycle\n    // the length of the recurrent cycle cannot be greater or equal than i,\n    // as the number of unique remainders obtained by dividing by i are between (0 and i - 1)\n    const remainders = [];\n    let remainder = 1;\n    for (let j = 1; j <= i; j++) {\n      remainder = (remainder * 10) % i;\n      if (remainders.includes(remainder)) {\n        if (remainders.length > longestRecurringCycle) {\n          longestRecurringCycle = remainders.length;\n          longestRecurringCycleValue = i;\n        }\n        break;\n      }\n      remainders.push(remainder);\n    }\n  }\n}\nreturn longestRecurringCycleValue;",
    "utils": []
  },
  {
    "id": "27",
    "title": "Quadratic primes",
    "description": [
      "Euler discovered the remarkable quadratic formula: n²+n+41.",
      null,
      "It turns out that the formula will produce 40 primes for the consecutive integer values 0≤n≤39.",
      null,
      "However, when n=40,40²+40+41=40(40+1)+41 is divisible by 41, and certainly when n=41,41²+41+41 is clearly divisible by 41.",
      null,
      "The incredible formula n²−79n+1601 was discovered, which produces 80 primes for the consecutive values 0≤n≤79.",
      null,
      "The product of the coefficients, −79 and 1601, is −126479.",
      null,
      "Considering quadratics of the form:",
      null,
      "n^2+an+b, where |a|<1000 and |b|≤1000",
      null
    ],
    "question": [
      "Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n=0."
    ],
    "guide": [
      "Instead of searching for every value of a and b between -999 to 999, we can observe the following:",
      "<br />",
      "Let Q be a prime generating quadratic polynomial, for Q to be valid, b must be a prime number (as Q(0) = b).",
      "<br />",
      "Further, we can see that Q(n) > 1, since primes all are bigger than 1.",
      "<br />",
      "Therefore Q(1) > 1.",
      "<br />",
      "=> 1 + a + b > 1",
      "<br />",
      "=> a > -b",
      "<br />",
      "So, b must be a prime and a > -b, which limits our search space.",
      "<br />"
    ],
    "solution": "const primesArray = Object.keys(utils.generatePrimesTable(1000)).map(x => +(x));\nlet longestConsecutivePrimes = 40;\nlet productOfLongest = 0;\nfor (let i = 0; i < primesArray.length; i++) {\n  const b = primesArray[i];\n  for (let a = -b + 1; a < 999; a++) {\n    const consecutivePrimesLength = computeConsecutivePrimesLength(a, b);\n    if (consecutivePrimesLength > longestConsecutivePrimes) {\n      longestConsecutivePrimes = consecutivePrimesLength;\n      productOfLongest = a * b;\n    }\n  }\n}\nreturn productOfLongest;\nfunction computeConsecutivePrimesLength(a, b) {\n  let n = 1;\n  let Q = 1 + a + b;\n  while (utils.isPrime(Q)) {\n    n++;\n    Q = (n ** 2) + a * n + b;\n  }\n  return n;\n}",
    "utils": [
      "primes/generatePrimesTable",
      "primes/isPrime"
    ]
  },
  {
    "id": "28",
    "title": "Number spiral diagonals",
    "description": [
      "Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:",
      null,
      " [21]  22   23   24  [25]",
      null,
      " 20  [07]  08  [09]  10",
      null,
      " 19   06  [01]  02   11",
      null,
      " 18  [05]  4   [03]  12",
      null,
      " [17]  16   15   14  [13]",
      null,
      "It can be verified that the sum of the numbers on the diagonals (enclosed by [brackets]) is 101.",
      null
    ],
    "question": [
      "What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?"
    ],
    "guide": [
      "By convenience we will say that [01] is on the 0th square.",
      "<br />",
      "We notice that the 4 corner numbers on the nth outer square are spaced apart from each other by 2*n.",
      "<br />",
      "We can also observe that the last encountered diagonal number (top-right corner) is (2n-1)^2.",
      "<br />",
      "Then the sum of diagonals of the nth square is",
      "<br />",
      "(2n-1)² + 2n + (2n-1)² + 4n + (2n-1)² + 6n + (2n-1)² + 8n",
      "<br />",
      "= 4(2n-1)² + 20n = 16n² + 4n + 4",
      "<br />",
      "In a 5x5 square, there are 2 layers + [01]",
      "<br />",
      "If we have a 1001 by 1001 square then we have 500 layers + [01]",
      "<br />"
    ],
    "solution": "let sum = 0;\nfor (let i = 1; i <= 500; i++) {\n  sum += (16 * (i ** 2) + (4 * i) + 4);\n}\nreturn sum + 1;",
    "utils": []
  },
  {
    "id": "29",
    "title": "Distinct powers",
    "description": [
      "Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:",
      null,
      "If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:",
      null,
      "4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125",
      null
    ],
    "question": [
      "How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?"
    ],
    "guide": [
      "We just need to find the number of collisions (ie. 2⁴ = 4²), and subtract that from 99²",
      "<br />",
      "Collisions must involve a power of 2, 3, 5, 6, 7, 10",
      "<br />",
      "2 will collide with powers of 4, 8, 16, ..., 64",
      "<br />",
      "3 will collide with powers of 9, 27, 81",
      "<br />",
      "5 will collide with powers of 25, 6 with 36, 7 with 49, and 10 with 100.",
      "<br />",
      "For 5,6,7, and 10 there are 49 collisions each, ie. even powers",
      "<br />",
      "For example, (5⁴ collides with 25², 5⁶ collides with 25³, ..., 5¹⁰⁰ collides with 25⁵⁰)",
      "<br />",
      "We get 196 collisions for those 4 bases.",
      "<br />",
      "Next we compute the collisions for powers of 2 (ie. 2, 4, 8, 16, 32, 64), and the collisions for powers of 3 (ie. 3, 9, 27, 81)",
      "<br />",
      "",
      "<br />",
      "I will explain how to count the collisions for powers of 2, powers of 3 works in the same way.",
      "<br />",
      "We reduce all numbers that are powers of two to the base of 2.",
      "<br />",
      "For example, instead of writing 32⁶, we write 2⁵⁽⁶⁾ = 2³⁰.",
      "<br />",
      "For example, instead of writing 64⁵, we write 2⁶⁽⁵⁾ = 2³⁰.",
      "<br />",
      "We reduce all powers of 2 into 2^(m * n) where 1 <= m <= 6 and 1 <= n <= 100.",
      "<br />",
      "We then loop through all 1 <= m <= 6 and 1 <= n <= 100, calculate m * n and see how many unique values we get, that is the number of non-collisions.",
      "<br />"
    ],
    "solution": "// the power is unique if the exponent part (m * n) is also unique\nconst uniquePowersOf2 = new Set();\nconst uniquePowersOf3 = new Set();\nfor (let i = 2; i <= 100; i++) {\n  for (let m = 1; m <= 6; m++) {\n    // if i * m is already in the set, ie. we seen that equivalent power before,\n    // the following operation will add nothing\n    uniquePowersOf2.add(i * m);\n    if (m <= 4) {\n      uniquePowersOf3.add(i * m);\n    }\n  }\n}\nconst collisionsOf2 = 6 * 99 - uniquePowersOf2.size;\nconst collisionsOf3 = 4 * 99 - uniquePowersOf3.size;\nconst totalCollisions = collisionsOf2 + collisionsOf3 + 196;\nreturn 99 * 99 - totalCollisions;",
    "utils": []
  },
  {
    "id": "30",
    "title": "Digit fifth powers",
    "description": [
      "Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:",
      null,
      "1634 = 1⁴ + 6⁴ + 3⁴ + 4⁴",
      null,
      "8208 = 8⁴ + 2⁴ + 0⁴ + 8⁴",
      null,
      "9474 = 9⁴ + 4⁴ + 7⁴ + 4⁴",
      null,
      "As 1 = 1⁴ is not a sum it is not included.",
      null,
      "The sum of these numbers is 1634 + 8208 + 9474 = 19316.",
      null
    ],
    "question": [
      "Find the sum of all the numbers that can be written as the sum of fifth powers of their digits."
    ],
    "guide": [
      "Let N be a number that can be written as the sum of fifth powers of their digits.",
      "<br />",
      "We first observe N cannot have more than 6 digits, as it will be too large for the sum to add up to.",
      "<br />",
      "N also obviously cannot have 1 digit, by quickly checking we can also see that N cannot have 2 digits, so we need to verify numbers between 3 and 6 digits.",
      "<br />",
      "We use a few heuristics to limit our search space. For example, for numbers with 3 digits, the valid numbers that form N are 0 to 3, as 4^5 > 999",
      "<br />"
    ],
    "solution": "const fifthPowerDigits = []; // list of N's defined above\n// table that stores the max allowed digit for a given number length\n// e.g for numbers with 3 digits, the valid numbers that form N are 0 to 3, as 4^5 > 999\nconst maxAllowedDigits = {};\n// if max allowed digit is 9, we don't need to go through the trouble of skipping/pruning\nlet needPruning = true;\nfor (let i = 100; i < 999999; i++) {\n  const digits = i.toString().split('');\n  let maxExceeded = false;\n  if (needPruning) {\n    const numberOfDigits = digits.length;\n    let maxAllowedDigit;\n    if (maxAllowedDigits[numberOfDigits]) {\n      // if max allowed digit is already in table, we grab it\n      maxAllowedDigit = maxAllowedDigits[numberOfDigits];\n    } else {\n      // otherwise, we compute the max allowed digits for a given digits length\n      maxAllowedDigit = 0;\n      while ((maxAllowedDigit + 1) ** 5 < 10 ** numberOfDigits) {\n        maxAllowedDigit++;\n      }\n      maxAllowedDigits[numberOfDigits] = maxAllowedDigit;\n    }\n    if (maxAllowedDigit === 9) {\n      needPruning = false;\n    }\n    // we check if a digit exceed the max, if so we check the next number\n    // e.g. 240 is not a valid number as 4 > 3, so we add 60 (ie. 6 * 10^1, or (10 - 4) * 10 ^ (3 - 2))\n    digits.forEach((digit, position) => {\n      if (+(digit) > maxAllowedDigit) {\n        i += (10 - maxAllowedDigit) * (10 ** (numberOfDigits - position - 1)) - 2;\n        maxExceeded = true;\n      }\n    });\n  }\n  if (!maxExceeded) {\n    const sumOfFifthPowers = utils.sumArray(digits, x => (+(x)) ** 5);\n    if (sumOfFifthPowers === i) {\n      fifthPowerDigits.push(i);\n    }\n  }\n}\nreturn utils.sumArray(fifthPowerDigits);",
    "utils": [
      "common/sumArray"
    ]
  },
  {
    "id": "31",
    "title": "Coin sums",
    "description": [
      "In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:",
      null,
      "1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).",
      null,
      "It is possible to make £2 in the following way:",
      null,
      "1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p",
      null
    ],
    "question": [
      "How many different ways can £2 be made using any number of coins?"
    ],
    "guide": [
      "Starting out with 2£, we branch out all the possible scenarios for using each amount of each type of coin, going from largest coin to smallest.",
      "<br />",
      "The comments in the code explain in detail how it's done.",
      "<br />"
    ],
    "solution": "const CHANGES = [1, 2, 5, 10, 20, 50, 100, 200];\n// our final result\nlet changes = 0;\n// our algorithm works by traversing down a 'tree'\n// we start with the top level: 200\n// [tree level: 200] we create 2 branches: left (using 200) and right (not using 200)\n// from each branch we find the amount of combinations of the next coin\n// [tree level: 200] left branch used 200, has 0 left, return 1 (1 way to make 200 using 200p coins)\n// [tree level: 200] right branch did not use 200, has 200 left, now we can either:\n// [tree level: 100] use 2 100p coins, 1 100p coins, or 0 100p coins, -> we create 3 branches for the next level\n// the tree looks like this:\n// [root]            200\n//                  /   \\\n// [level: 200]    0    200\n//                     / | \\\n// [level: 100]       0 100 200\n//                       |   \\\n// [level: 50]          ...  ...\n//\n// when we reach level 2, we can stop and return Math.floor(amountLeft / 2) + 1\n// which is equal to the number of ways we can make amountLeft using only 2p and 1p\nfunction makeChange(amountLeft, levelIndex = CHANGES.length - 1) {\n  if (amountLeft < 0) {\n    // dead branch\n    return 0;\n  }\n  if (levelIndex === 1) {\n    // reached leaf\n    return Math.floor(amountLeft / 2) + 1;\n  }\n  if (amountLeft === 1 || amountLeft === 0) {\n    // there is only 1 way to make 1p\n    // also if amountLeft is 0, it means we called makeChange on amountLeft with a coin equal to it\n    // eg. using 200p coin to make 200p, there is only 1 way\n    return 1;\n  }\n  for (let i = 0; i <= Math.floor(amountLeft / CHANGES[levelIndex]); i++) {\n    // 'generate' branches according to amountLeft/level\n    const changesAtLevel = makeChange(amountLeft - i * CHANGES[levelIndex], levelIndex - 1);\n    changes += changesAtLevel;\n  }\n  return 0;\n}\nmakeChange(200);\nreturn changes;",
    "utils": []
  },
  {
    "id": "32",
    "title": "Pandigital products",
    "description": [
      "The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.",
      null
    ],
    "question": [
      "Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.",
      "HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum."
    ],
    "guide": [
      "Let a * b = c (for convenience, assume a < b), we know that c must have 4 digits because if digits(c) > 4, a * b < c and if digits(c) < 4, a * b > c.",
      "<br />",
      "We just need to check values of c from 1234 to 9876, and find 1 < a <= 98 st. our condition is satisfied",
      "<br />"
    ],
    "solution": "const DIGITS = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconst pandigitalProducts = [];\nfor (let i = 1111; i <= 9876; i++) {\n  const selectionIndexes = i.toString().split('');\n  // we only check if the selection is valid\n  if (+(selectionIndexes[1]) < 9\n    && +(selectionIndexes[2]) < 8\n    && +(selectionIndexes[3]) < 7\n    && !selectionIndexes.some(x => x === '0')\n  ) {\n    let c = '';\n    let remainingDigits = [...DIGITS];\n    selectionIndexes.forEach(\n      (selectionIndex) => {\n        const selected = remainingDigits[selectionIndex - 1].toString();\n        c += selected;\n        remainingDigits = remainingDigits.filter(x => x !== remainingDigits[selectionIndex - 1]);\n      },\n    );\n    c = +(c);\n    const root = Math.sqrt(c);\n    // now assume that a has only 1 digit, check for pandigital equations\n    let a;\n    let isPandigital = false;\n    for (a = 0; a < remainingDigits.length; a++) {\n      const dividend = remainingDigits[a];\n      const b = c / dividend;\n      if (Number.isInteger(b)) {\n        if (b.toString().split('').sort().join('') === remainingDigits.filter(x => x !== dividend).join('')) {\n          pandigitalProducts.push(c);\n          isPandigital = true;\n          break;\n        }\n      }\n    }\n    if (!isPandigital) {\n      // now assume a has 2 digits, check for pandigital equations\n      for (let j = 11; j <= 54; j++) {\n        // we select 2 digits from the remaining pool of 5\n        const selectionIndexes2 = j.toString().split('');\n        if (selectionIndexes2[0] < 6 && selectionIndexes2[1] < 5 && !selectionIndexes2.some(x => x === '0')) {\n          let a2 = '';\n          let remainingDigits2 = [...remainingDigits]; // remaining digits after a second round of selection\n          selectionIndexes2.forEach(\n            (selectionIndex2) => {\n              const selected = remainingDigits2[selectionIndex2 - 1].toString();\n              a2 += selected;\n              remainingDigits2 = remainingDigits2.filter(x => x !== remainingDigits2[selectionIndex2 - 1]);\n            },\n          );\n          a2 = +(a2);\n          if (a2 < root) {\n            const b = c / a2;\n            if (Number.isInteger(b)) {\n              if (b.toString().split('').sort().join('') === remainingDigits2.join('')) {\n                pandigitalProducts.push(c);\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\nreturn utils.sumArray(pandigitalProducts);",
    "utils": [
      "common/sumArray"
    ]
  },
  {
    "id": "33",
    "title": "Digit cancelling fractions",
    "description": [
      null,
      "The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is correct, is obtained by cancelling the 9s.",
      null,
      "We shall consider fractions like, 30/50 = 3/5, to be trivial examples.",
      null,
      "There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.",
      null
    ],
    "question": [
      "If the product of these four fractions is given in its lowest common terms, find the value of the denominator."
    ],
    "guide": [
      "We check all fractions of the form mx/xn, where:",
      "<br />",
      "1. 1 <= m, n, x <= 9",
      "<br />",
      "2. m =/= n",
      "<br />"
    ],
    "solution": "   const curiousFractions = [];\nfor (let m = 1; m <= 9; m++) {\n  for (let n = 1; n <= 9; n++) {\n    if (m !== n) {\n      for (let x = 1; x <= 9; x++) {\n        const numerator = (10 * m) + x;\n        const denominator = (x * 10) + n;\n        const fraction = numerator / denominator;\n        if (fraction === m / n) {\n          curiousFractions.push({ numerator, denominator });\n        }\n      }\n    }\n  }\n}\nconst productFraction = curiousFractions.reduce(\n  (acc, curr) => {\n    acc.numerator *= curr.numerator;\n    acc.denominator *= curr.denominator;\n    return acc;\n  },\n  {\n    numerator: 1,\n    denominator: 1,\n  },\n);\nreturn utils.reduceLCT(productFraction.numerator, productFraction.denominator)[1];",
    "utils": [
      "arithmetic/reduceLCT"
    ]
  },
  {
    "id": "34",
    "title": "Digit factorials",
    "description": [
      "145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.",
      null
    ],
    "question": [
      "Find the sum of all numbers which are equal to the sum of the factorial of their digits.",
      "Note: as 1! = 1 and 2! = 2 are not sums they are not included."
    ],
    "guide": [
      "We just search through all numbers, with some pruning explained in the comments in the code.",
      "<br />"
    ],
    "solution": "const FACTORIALS = utils.generateFactTable(9);\nconst curiousNumbers = [];\n// check whether n is curious\nfunction isCurious(n) {\n  return utils.sumArray(n.toString().split(''), x => FACTORIALS[x]) === n;\n}\n// ensures that none of n's digits exceed d\nfunction boundedBy(n, d) {\n  return n.toString().split('').every(x => +(x) <= d);\n}\n// check if number `n` contains exactly `c` copies of the digit `d`\nfunction containExactly(n, d, c) {\n  return n.toString().split('').filter(x => +(x) === d).length === c;\n}\n// we note that curious numbers must have between 3 and 7 digits, since 8 * 9! < 10^8\n// and we can quickly manually verify that numbers with 2 digits cannot be curious\n// for each digit count we use a heuristic to prune some numbers\nfor (let d = 3; d <= 7; d++) {\n  // for 3-digit numbers (n₃), we notice that\n  // 1. n₃ < 700 since 7! > 999\n  // 2. to comply with above, n₃ cannot contain a digit > 5\n  if (d === 3) {\n    for (let i = 100; i <= 555; i++) {\n      if (boundedBy(i, 5) && isCurious(i)) curiousNumbers.push(i);\n    }\n  }\n  // for 4-digit numbers (n₄), we have two main options, either use one 7, or no 7\n  // if not using 7, upper bound is 4 * 6! = 2880\n  // if using one 7, lower bound is 7000, upper bound is 5040 + 3 * 6! = 7200\n  if (d === 4) {\n    // no 7\n    for (let i = 1000; i < 2880; i++) {\n      if (boundedBy(i, 6) && isCurious(i)) curiousNumbers.push(i);\n    }\n    for (let i = 7000; i < 7200; i++) {\n      if (containExactly(i, 7, 1) && isCurious(i)) curiousNumbers.push(i);\n    }\n  }\n  // for 5-digit numbers, the options are to use 2 8's, 1 8, or no 8\n  if (d === 5) {\n    // no 8\n    // upper bound is 5 * 7! = 25200\n    // since our number < 25200, we cannot have five 7's, as the first digit is either 1 or 2\n    // therefore our upper bound becomes 4 * 7! = 20160\n    // we can lower it down further by noticing that we must be using four 7's\n    for (let i = 10000; i < 17777; i++) {\n      if (boundedBy(i, 7) && isCurious(i)) curiousNumbers.push(i);\n    }\n    // the same min-maxing upper/lower bound logic is applied\n    // to all further digit count and code below\n    // using one 8\n    for (let i = 40320; i < 57778; i++) {\n      if (boundedBy(i, 8) && containExactly(i, 8, 1) && isCurious(i)) curiousNumbers.push(i);\n    }\n    // using two 8's\n    for (let i = 80640; i < 88777; i++) {\n      if (boundedBy(i, 8) && containExactly(i, 8, 2) && isCurious(i)) curiousNumbers.push(i);\n    }\n  }\n  // for 6-digit numbers, the options are to use two 9's, one 9, or no 9\n  // if we use more than two 9s, the sum will exceed 6 digits\n  if (d === 6) {\n    // two 9's\n    for (let i = 725799; i < 886998; i++) {\n      if (containExactly(i, 9, 2) && isCurious(i)) curiousNumbers.push(i);\n    }\n    // one 9\n    for (let i = 362889; i < 488889; i++) {\n      if (containExactly(i, 9, 1) && isCurious(i)) curiousNumbers.push(i);\n    }\n    // no 9\n    for (let i = 100088; i < 158888; i++) {\n      if (boundedBy(i, 8) && isCurious(i)) curiousNumbers.push(i);\n    }\n  }\n  // for 7 digit numbers, we must use 4 9's\n  if (d === 7) {\n    // 4 9's\n    for (let i = 1459999; i < 1489999; i++) {\n      if (containExactly(i, 9, 4) && isCurious(i)) curiousNumbers.push(i);\n    }\n  }\n}\nreturn utils.sumArray(curiousNumbers);",
    "utils": [
      "combinatorics/generateFactTable",
      "common/sumArray"
    ]
  },
  {
    "id": "35",
    "title": "Circular primes",
    "description": [
      "The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.",
      null,
      "There are thirteen such primes below 100:",
      null,
      "2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.",
      null
    ],
    "question": [
      "How many circular primes are there below one million?"
    ],
    "guide": [
      "We generate a table of 1 million primes. For each prime, we check if every rotation is also in the table.",
      "<br />"
    ],
    "solution": "const PRIMES_TABLE = utils.generatePrimesTable(1000000);\nconst PRIMES = Object.keys(PRIMES_TABLE);\nconst circularPrimes = {};\nfor (let p of PRIMES) {\n  // if p < 100, skip it\n  if (p < 100) {\n    continue;\n  }\n  // if p contains a digit that is even, we can skip it.\n  if (p.toString().split('').some(x => ['0', '2', '4', '6', '8'].includes(x))) {\n    continue;\n  }\n  let allRotations = computeRotations(p);\n  if (allRotations.every(x => PRIMES_TABLE[x])) {\n    for (r of allRotations) {\n      circularPrimes[r] = true;\n    }\n  }\n}\n// returns an array with all rotations of p, including p itself\nfunction computeRotations(p) {\n  const rotations = [p];\n  const numberString = p.toString();\n  const digits = numberString.split('').length;\n  for (let i = 1; i < digits; i++) {\n    const left = numberString.substring(0, i);\n    const right = numberString.substring(i, numberString.length);\n    rotations.push(+`${right}${left}`);\n  }\n  return rotations;\n}\nreturn Object.keys(circularPrimes).length + 13; // there are 13 rotations under 100 (given)",
    "utils": [
      "primes/generatePrimesTable"
    ]
  },
  {
    "id": "36",
    "title": "Double-base palindromes",
    "description": [
      "The decimal number, 585 = 1001001001 (binary), is palindromic in both bases."
    ],
    "question": [
      "Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2."
    ],
    "guide": [
      "We loop through each decimal palindrome and check whether its binary representation is also palindromic",
      "<br />",
      "Note that even numbers cannot be palindromic in its binary representation",
      "<br />"
    ],
    "solution": "const doublePalindromes = [];\n  for (let i = 1; i <= 999; i++) {\n  // we can skip the numbers whose leading digit is even\n  if (i.toString().charAt(0) & 1) {\n    // we generate a list of palindromes based on current index\n    // ie. i = 57 -> 5775, 57075, 57175, ..., 57975\n    const evenDigitPalindrome = +(`${i.toString()}${i.toString().split('').reverse().join('')}`);\n    let oddDigitPalindromes = [];\n    if (i < 100) { // we don't want to generate 7 digit palindromes\n      oddDigitPalindromes = [...Array(10)].map(\n        (x, idx) => +(`${i.toString()}${idx}${i.toString().split('').reverse().join('')}`)\n      );\n    }\n    const decimalPalindromes = [evenDigitPalindrome, ...oddDigitPalindromes];\n    decimalPalindromes.forEach((dp) => {\n      const bin = dp.toString(2);\n      if (bin === bin.split('').reverse().join('')) {\n        doublePalindromes.push(dp);\n      }\n    });\n  }\n}\n// we did not yet take into account the numbers under 10 (which are palindromes by default)\n// 1,3,5,7,9 are all binary palindromes, their sum is 25\nreturn utils.sumArray(doublePalindromes) + 25;",
    "utils": [
      "common/sumArray"
    ]
  },
  {
    "id": "37",
    "title": "Truncatable primes",
    "description": [
      "The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.",
      null
    ],
    "question": [
      "Find the sum of the only eleven primes that are both truncatable from left to right and right to left.",
      "NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes."
    ],
    "guide": [
      "We start with two arrays, the append array [2, 3, 5, 7], which we will append numbers to, and the preppend array [3, 7], which we will preppend numbers to.",
      "<br />",
      "After one step, the append array will become [3, 5, 7, 21, 23, 27, 29]",
      "<br />",
      "After two step, it will become [5, 7, 21, 23, 27, 29, 31, 33, 37, 39]",
      "<br />",
      "After one step, the preppend array will become [7, 13, 23, 33, 53, 73, 93]",
      "<br />",
      "After two step, it will become [13, 23, 33, 53, 73, 93, 17, 27, 37, 57, 77, 97]",
      "<br />",
      "A truncatable prime is valid only if we can find it in both the append array and the preppend array.",
      "<br />",
      "In the example given above, 37 is the only prime satisfying those conditions, and it is a truncatable prime.",
      "<br />",
      "We keep expanding our arrays until none of the numbers in our array are prime.",
      "<br />"
    ],
    "solution": "const truncatedPrimes = [];\n// Appending an even number, or the number 5, to any number, will make that number composite.\nconst validDigitsA = [1, 3, 7, 9];\n// 2 and 5 are valid digit for preppending, however, they are only valid as the leading digit in a number\nconst validDigitsP = [1, 2, 3, 5, 7, 9];\n// we use BFS on a tree, where the root is a starting digit\n// for each number in root, we create 2 trees, one for only appending numbers (TA), and the other preppending (TP)\n// everytime we traverse down, we can prune a number if it is not prime\n// a number is a valid truncated prime if it is seen once in TA and once in TP\nconst seen = { };\n// 1, 9 cannot be a root as it is not prime\nconst queueA = [2, 3, 5, 7]; // queue for append\n// queue for preppend (preppending to a 2 or 5 will automatically make a number composite)\nconst queueP = [3, 7];\nwhile (queueA.length || queueP.length) {\n  if (queueA.length) {\n    const nodeA = queueA.shift();\n    if (seen[nodeA] && nodeA.toString().length > 1) {\n      truncatedPrimes.push(nodeA);\n      validDigitsA.forEach((vd) => {\n        queueA.push(+(`${nodeA}${vd}`));\n      });\n    } else if (utils.isPrime(nodeA)) {\n      seen[nodeA] = true;\n      validDigitsA.forEach((vd) => {\n        queueA.push(+(`${nodeA}${vd}`));\n      });\n    }\n  }\n  if (queueP.length) {\n    const nodeP = queueP.shift();\n    const firstDigitOfNode = +(nodeP.toString().charAt(0));\n    // preppending to 2, 5 will result in a composite right truncation\n    const stopPreppend = firstDigitOfNode === 2 || firstDigitOfNode === 5;\n    // preppending the same digit to the leading digit eg. 357 -> 3357\n    // will result in the first 2 leading digit to be divisible by 11\n    // except when the leading digit is 1, then preppending by 1 is still fine as 11 is prime\n    const validDigits = validDigitsP.filter(x => x === 1 || x !== firstDigitOfNode);\n    if (seen[nodeP] && nodeP.toString().length > 1) {\n      truncatedPrimes.push(nodeP);\n      if (!stopPreppend) {\n        validDigits.forEach((vd) => {\n          queueP.push(+(`${vd}${nodeP}`));\n        });\n      }\n    } else if (utils.isPrime(nodeP)) {\n      seen[nodeP] = true;\n      if (!stopPreppend) {\n        validDigits.forEach((vd) => {\n          queueP.push(+(`${vd}${nodeP}`));\n        });\n      }\n    }\n  }\n}\nreturn utils.sumArray(truncatedPrimes);",
    "utils": [
      "primes/isPrime",
      "common/sumArray"
    ]
  },
  {
    "id": "38",
    "title": "Pandigital multiples",
    "description": [
      "Take the number 192 and multiply it by each of 1, 2, and 3:",
      null,
      "192 × 1 = 192",
      null,
      "192 × 2 = 384",
      null,
      "192 × 3 = 576",
      null,
      "By concatenating each product we get the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated product of 192 and (1,2,3)",
      null,
      "The same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5, giving the pandigital, 918273645, which is the concatenated product of 9 and (1,2,3,4,5)",
      null
    ],
    "question": [
      "What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, ... , n) where n > 1?"
    ],
    "guide": [
      "We are given that the answer is >= 918273645",
      "<br />",
      "",
      "<br />",
      "If our multiplicand (in the example of the question the multiplicand would be 192) has two digits, then it must be >= 91, since our answer >= 918273645.",
      "<br />",
      "Successive multiplication by 1, 2, 3, 4 will yield products of 2 digits, 3 digits, 3 digits, 3 digits = 11 digits > 9 digits.",
      "<br />",
      "",
      "<br />",
      "We can apply the same logic to 3 digit multiplicands: 3 + 4 + 4 > 9",
      "<br />",
      "",
      "<br />",
      "For 5 digits and above, the result of multipliying by 1 and 2 will result (respectively) in a >5 and >6 digit number => > 9 digits",
      "<br />",
      "",
      "<br />",
      "So we can only check 4-digits multiplicands where m * 1 has 4 digits and m * 2 has 5 digits, 4 + 5 = 9.",
      "<br />",
      "we dont have to check numbers > 9500 as multipliying by 2 will yield 19..., and the number will contain 2 9's, and won't be pandigital.",
      "<br />"
    ],
    "solution": "let largestPandigitalProduct = 918273645;\nfor (let m = 9182; m <= 9487; m++) {\n  const multiplicandArr = m.toString().split('');\n  const mHasDuplicate = multiplicandArr.length !== (new Set(multiplicandArr)).size;\n  if (!mHasDuplicate) {\n    const product = m * 100000 + 2 * m; // eg. 9182 -> 918200000 + 18364 -> 918218364\n    // check if product is pandigital\n    const productArr = product.toString().split('');\n    const hasDuplicate = productArr.length !== (new Set(productArr)).size;\n    if (!hasDuplicate && !productArr.includes('0')) {\n      largestPandigitalProduct = +(`${product}`);\n    }\n  }\n}\nreturn largestPandigitalProduct;",
    "utils": []
  },
  {
    "id": "39",
    "title": "Integer right triangles",
    "description": [
      "If p is the perimeter of a right angle triangle with integral length sides, {a,b,c}, there are exactly three solutions for p = 120.",
      null,
      "{20,48,52}, {24,45,51}, {30,40,50}",
      null
    ],
    "question": [
      "For which value of p ≤ 1000, is the number of solutions maximised?"
    ],
    "guide": [
      "We generate each primitive triplet one by one, then we multiply the perimeter by integer multiples to get its non-primitive triplets.",
      "<br />",
      "For example, (3,4,5) is a primitive triplet, but (6,8,10) is not.",
      "<br />",
      "In a table, we store as the keys the perimeter, and we store as the values the number of solutions for that perimeter.",
      "<br />",
      "So starting with m = 2, n = 1, we get a perimeter of 12.",
      "<br />",
      "We multiply that perimeter until it is close to 1000, and so our table will look like { 12: 1, 24: 1, ..., 996: 1 }",
      "<br />",
      "We then go to the next primitive solution, and repeat, until the tables is filled with multiples of all primitive solutions.",
      "<br />",
      "The key-value pair with the largest value will be the perimeter with the most solutions.",
      "<br />"
    ],
    "solution": "// we can generate all unique primitive pythagorean triples given a pair of integers m, n:\n// a = m^2 - n^2, b = 2mn, c = m^2 + n^2, where:\n// 1. m > n > 0\n// 2. m and n must not both be odd\n// 3. m and n must be coprime:\n// so we have perimeter = a+b+c = 2m^2 + 2mn = 2m(m+n)\n// we just generate each m, n pair and increment the value associated with p\n// then we also increment each multiple of the generated perimeter\nconst perimeters = {};\nlet maximizedPerimeter = 12;\nlet maximizedPerimeterSolutionsCount = 0;\n// we can quickly check that in order to satisfy p <= 1000, m <= 23\nfor (let m = 2; m <= 23; m++) {\n  for (let n = 1; n < m; n++) {\n    if ((utils.isEven(m) || utils.isEven(n)) && utils.isCoprime(m, n)) {\n      const primitivePerimeter = 2 * m * (m + n);\n      let multiple = 1;\n      let multipliedPerimeter = primitivePerimeter * multiple;\n      while (multipliedPerimeter <= 1000) {\n        perimeters[multipliedPerimeter] = (perimeters[multipliedPerimeter] || 0) + 1;\n        const perimeterSolutionsCount = perimeters[multipliedPerimeter];\n        if (perimeterSolutionsCount > maximizedPerimeterSolutionsCount) {\n          maximizedPerimeterSolutionsCount = perimeterSolutionsCount;\n          maximizedPerimeter = multipliedPerimeter;\n        }\n        multiple++;\n        multipliedPerimeter = primitivePerimeter * multiple;\n      }\n    }\n  }\n}\nreturn maximizedPerimeter;",
    "utils": [
      "arithmetic/isEven",
      "arithmetic/isCoprime"
    ]
  },
  {
    "id": "40",
    "title": "Champernowne's constant",
    "description": [
      "An irrational decimal fraction is created by concatenating the positive integers:",
      null,
      "0.12345678910[1]112131415161718192021...",
      null,
      "It can be seen that the 12th digit of the fractional part is 1 (enclosed in square brackets []).",
      null
    ],
    "question": [
      "If d_n represents the nth digit of the fractional part, find the value of the following expression.",
      "d_1 × d_10 × d_100 × d_1000 × d_10000 × d_100000 × d_1000000"
    ],
    "guide": [
      "We split the fractional part into sections.",
      "<br />",
      "The first section contains the numbers with one digit (1,2,3,...,9). 9 digits",
      "<br />",
      "The second section contains the 2-digits numbers (10,11,12,...,99). 180 digits",
      "<br />",
      "The third section contains the 2-digits numbers (100,101,102,...,999). 2700 digits",
      "<br />",
      "The sections after will contain 36000, 450000, and 5400000 digits.",
      "<br />",
      "So we first find the section, then we find the number in the section, and finally the digit in the number.",
      "<br />"
    ],
    "solution": "const searchIndexes = [1, 10, 100, 1000, 10000, 100000, 1000000];\nconst foundDigits = searchIndexes.map(x => champernowne(x));\nfunction champernowne(index) {\n  // it can be seen that each section contains 9i * 10^(i-1) digits total\n  let countSectionNumbers = section => 9 * section * 10 ** (section - 1);\n  // first find section\n  let section = 1;\n  while (countSectionNumbers(section) < index) {\n    section++;\n  }\n  \n  for (let i = 1; i < section; i++) {\n    index -= countSectionNumbers(i);\n  }\n  \n  // find number in section\n  let nth = Math.floor(index / section);\n  if (section > 1) {\n    nth += 10 ** (section - 1)\n  }\n  // find digit in number\n  let nthdigit = (index - 1) % section; // have to substract by 1 because 0th index is actually the first digit, etc.\n  return nth.toString().split('')[nthdigit]\n}\nreturn foundDigits.reduce((a, c) => a * c, 1);",
    "utils": []
  },
  {
    "id": "41",
    "title": "Pandigital prime",
    "description": [
      "We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once.",
      null,
      "For example, 2143 is a 4-digit pandigital and is also prime.",
      null
    ],
    "question": [
      "What is the largest n-digit pandigital prime that exists?"
    ],
    "guide": [
      "We don't need to check 9-digit numbers, as the sum of the digits is 45, which makes the number divisible by 3. We can apply the same logic to 8 digit numbers.",
      "<br />"
    ],
    "solution": "const digits = [7, 6, 5, 4, 3, 2, 1];\n// we don't need to check if the number is prime if the finalDigit is 2, 4, 5, or 6\nconst validFinalDigits = [1, 3, 7];\n// we search from n = 7 to n = 4 (given in problem statement)\nfor (let n = 7; n >= 4; n--) {\n  const validDigits = digits.slice(7 - n);\n  // here i represents the ith lexicographic permutation\n  for (let i = 1; i <= utils.fact(n); i++) {\n    const pandigitalArray = utils.getLexicalPermutation(validDigits, i);\n    const finalDigit = pandigitalArray[pandigitalArray.length - 1];\n    if (validFinalDigits.includes(+(finalDigit))) {\n      const pandigitalNumber = +(pandigitalArray.join(''));\n      if (utils.isPrime(pandigitalNumber)) {\n        return pandigitalNumber;\n      }\n    }\n  }\n}",
    "utils": [
      "combinatorics/fact",
      "combinatorics/getLexicalPermutation",
      "primes/isPrime"
    ]
  },
  {
    "id": "42",
    "title": "Coded Triangle numbers",
    "description": [
      null,
      "The nth term of the sequence of triangle numbers is given by, tn = ½n(n+1); so the first ten triangle numbers are:",
      null,
      "1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...",
      null,
      "By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value. For example, the word value for SKY is 19 + 11 + 25 = 55 = t10. If the word value is a triangle number then we shall call the word a triangle word.",
      null
    ],
    "question": [
      "Using [p042_words.txt @asset p042_words.txt], a 16K text file containing nearly two-thousand common English words, how many are triangle words?"
    ],
    "guide": [
      "Very straightforward, we go through the list of words and check if each word is triangle.",
      "<br />"
    ],
    "solution": "// we can assume that a word cannot exceed the word value of 500 (almost 20 consecutive 'z')\n// we generate a table of triangle numbers up to 500\nlet triangleWords = 0;\nconst triangleTable = utils.generateTriangulars(500);\nconst words = fs.readFileSync(path.join(__dirname, 'p042_words.txt'))\n  .toString()\n  .replace(/\"/g, '')\n  .split(',');\nwords.forEach((word) => {\n  const wordValue = utils.sumArray(word.split(''), char => char.charCodeAt(0) - 64);\n  if (triangleTable[wordValue]) {\n    triangleWords++;\n  }\n});\nreturn triangleWords;",
    "utils": [
      "arithmetic/generateTriangulars",
      "common/sumArray"
    ]
  },
  {
    "id": "43",
    "title": "Sub-string divisibility",
    "description": [
      null,
      "The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property.",
      null,
      "Let d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note the following:",
      null,
      "d2d3d4=406 is divisible by 2",
      null,
      "d3d4d5=063 is divisible by 3",
      null,
      "d4d5d6=635 is divisible by 5",
      null,
      "d5d6d7=357 is divisible by 7",
      null,
      "d6d7d8=572 is divisible by 11",
      null,
      "d7d8d9=728 is divisible by 13",
      null,
      "d8d9d10=289 is divisible by 17",
      null
    ],
    "question": [
      "Find the sum of all 0 to 9 pandigital numbers with this property."
    ],
    "guide": [
      "Our algorithm is as follows:",
      "<br />",
      "1. start by picking the last 3 digits such that it is divisible by 17, ie. 017, 034, ...",
      "<br />",
      "2. we then pick d7 such that d7d8d9 is divisible by 13, if such d7 does not exist, we go to the next multiple of 17",
      "<br />",
      "3. if it does exist, we pick d6 s.t. d6d7d8 is divisible by 11, etc.",
      "<br />",
      "4. repeat until we find d2d3d4 s.t. it is divisible by 2.",
      "<br />"
    ],
    "solution": "const subdivisibleNumbers = [];\nconst digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n// 58 * 17 = 986, largest 3-digit number which is divisible by 17\nfor (let i = 1; i <= 58; i++) {\n  const last3 = (i * 17).toString().padStart(3, '0'); // 1 -> '017', 2 -> '034, etc\n  if (!utils.containsDuplicate(last3)) {\n    buildNumber(\n      last3,\n      digits.filter(x => !last3.includes(x)),\n      [2, 3, 5, 7, 11, 13],\n    );\n  }\n}\n// recursively build a number digit by digit, ensuring divisibility at each step\nfunction buildNumber(acc, remainingDigits, remainingDividers) {\n  if (!remainingDividers.length) {\n    return subdivisibleNumbers.push(`${remainingDigits[0]}${acc}`);\n  }\n  const divider = remainingDividers.pop();\n  for (let j = 0; j < remainingDigits.length; j++) {\n    const leadingDigit = remainingDigits[j];\n    const trailingDigits = +acc.slice(0, 2);\n    const numToCheck = leadingDigit * 100 + trailingDigits;\n    if (numToCheck % divider === 0) {\n      buildNumber(\n        `${leadingDigit}${acc}`,\n        [...remainingDigits].filter(x => x !== leadingDigit),\n        [...remainingDividers],\n      );\n    }\n  }\n}\nreturn utils.sumArray(subdivisibleNumbers, x => +x);",
    "utils": [
      "lang/containsDuplicate",
      "common/sumArray"
    ]
  },
  {
    "id": "44",
    "title": "Pentagon numbers",
    "description": [
      null,
      "Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:",
      null,
      "1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...",
      null,
      "It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.",
      null
    ],
    "question": [
      "Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimized; what is the value of D?"
    ],
    "guide": [
      "We loop through each pentagonal number Pk, and for each Pk loop through each Pj smaller than Pk",
      "<br />",
      "We check whether Pk - Pj AND Pk + Pj is pentagonal, if so return the difference",
      "<br />"
    ],
    "solution": "let k = 2;\nwhile (true) {\n  const Pk = pentg(k);\n  let j = k;\n  while (j >= 1) {\n    const Pj = pentg(j);\n    if (utils.isPentagonal(Pk - Pj) && utils.isPentagonal(Pk + Pj)) {\n      return Pk - Pj;\n    }\n    j--;\n  }\n  k++;\n}\nfunction pentg(n) {\n  return ((3 * (n ** 2)) - n) / 2;\n}",
    "utils": [
      "arithmetic/isPentagonal"
    ]
  },
  {
    "id": "45",
    "title": "Triangular, pentagonal, and hexagonal",
    "description": [
      "Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:",
      null,
      "Triangle T(n)=n(n+1)/2: 1, 3, 6, 10, 15, ...",
      null,
      "Pentagonal P(n)=n(3n−1)/2: 1, 5, 12, 22, 35, ...",
      null,
      "Hexagonal H(n)=n(2n−1): 1, 6, 15, 28, 45, ...",
      null,
      "It can be verified that T(285) = P(165) = H(143) = 40755.",
      null
    ],
    "question": [
      "Find the next triangle number that is also pentagonal and hexagonal."
    ],
    "guide": [
      "We go through each hexagonal number until we find one that is both pentagonal and triangle.",
      "<br />"
    ],
    "solution": "let h = 144;\nwhile (true) {\n  const hexagonal = hexg(h);\n  if (utils.isPentagonal(hexagonal) && utils.isTriangular(hexagonal)) {\n    return hexagonal;\n  }\n  h++;\n}\nfunction hexg(n) {\n  return (n * ((2 * n) - 1));\n}",
    "utils": [
      "arithmetic/isPentagonal",
      "arithmetic/isTriangular"
    ]
  },
  {
    "id": "46",
    "title": "Goldbach's other conjecture",
    "description": [
      "It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.",
      null,
      "9 = 7 + 2×1²",
      null,
      "15 = 7 + 2×2²",
      null,
      "21 = 3 + 2×3²",
      null,
      "25 = 7 + 2×3²",
      null,
      "27 = 19 + 2×2²",
      null,
      "33 = 31 + 2×1²",
      null,
      "It turns out that the conjecture was false.",
      null
    ],
    "question": [
      "What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?"
    ],
    "guide": [
      "We check each odd number for primality; if it is composite, check for conjecture validity.",
      "<br />"
    ],
    "solution": "let num = 9;\nwhile (true) {\n  if (!utils.isPrime(num)) {\n    if (!conjValid(num)) {\n      return num;\n    }\n  }\n  num += 2;\n}\n// determines whether a number is valid for Goldbach's conjecture\nfunction conjValid(n) {\n  const rootUB = Math.sqrt((n - 2) / 2);\n  for (let i = 1; i <= rootUB; i++) {\n    const twiceSquare = (i ** 2) * 2;\n    if (utils.isPrime(n - twiceSquare)) {\n      return true;\n    }\n  }\n  return false;\n}",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "47",
    "title": "Distinct primes factors",
    "description": [
      "The first two consecutive numbers to have two distinct prime factors are:",
      null,
      "14 = 2 × 7",
      null,
      "15 = 3 × 5",
      null,
      "The first three consecutive numbers to have three distinct prime factors are:",
      null,
      "644 = 2² × 7 × 23",
      null,
      "645 = 3 × 5 × 43",
      null,
      "646 = 2 × 17 × 19.",
      null
    ],
    "question": [
      "Find the first four consecutive integers to have four distinct prime factors each. What is the first of these numbers?"
    ],
    "guide": [
      "Starting with the smallest number, <code>first</code>, which has 4 distinct prime factors(DPF), 2 * 3 * 5 * 7, we check if the next 3 consecutive number also has 4 DPF.",
      "<br />",
      "If yes, we found our solution, if not, we increment <code>first</code>.",
      "<br />"
    ],
    "solution": "// assume for now that we don't need prime factors over 1000\nconst first1000Primes = Object.keys(utils.generatePrimesTable(1000));\nlet first = 2 * 3 * 5 * 7;\nwhile (first < 1000000) {\n  const second = first + 1;\n  const third = first + 2;\n  const fourth = first + 3;\n  if (isDPFValid(first)) {\n    if (isDPFValid(second)) {\n      if (isDPFValid(third)) {\n        if (isDPFValid(fourth)) {\n          return first;\n        } // if the fourth number is not valid, skip over the next four numbers\n        first += 4;\n      } else { // if the third number is not valid, skip over the next 3 numbers, etc.\n        first += 3;\n      }\n    } else {\n      first += 2;\n    }\n  } else {\n    first++;\n  }\n}\n// we implement a tailored function which returns true iff n has exactly 4 distinct prime factors\nfunction isDPFValid(n) {\n  let quotient = n;\n  let DPFCount = 0;\n  for (let primeIndex = 0; primeIndex < first1000Primes.length; primeIndex++) {\n    const primeFactor = first1000Primes[primeIndex];\n    if (primeFactor > quotient) {\n      return DPFCount === 4;\n    }\n    if (quotient % primeFactor === 0) {\n      DPFCount++;\n    }\n    while (quotient % primeFactor === 0) {\n      if (DPFCount > 4) {\n        return false;\n      }\n      quotient /= primeFactor;\n    }\n  }\n}",
    "utils": [
      "primes/generatePrimesTable"
    ]
  },
  {
    "id": "48",
    "title": "Self powers",
    "description": [
      "The series, 1¹ + 2² + 3³ + ... + 10¹⁰ = 10405071317.",
      null
    ],
    "question": [
      "Find the last ten digits of the series, 1¹ + 2² + 3³ + ... + 1000¹⁰⁰⁰."
    ],
    "guide": [
      "For each number, we only need to keep track of the last ten digits. For example, when calculating 32³², we iteratively multiply the last ten digits by 32, and keep the last 10 digits of the result, instead of computing the whole number.",
      "<br />"
    ],
    "solution": "let result = 0;\nfor (let i = 1; i <= 1000; i++) {\n  result = getLast10Digits(result) + getSelfPower(i);\n}\nreturn result;\nfunction getSelfPower(n) {\n  // returns the last 10 digits of n^n\n  if (n % 10 === 0) {\n    // if n = 10 * k, then n^n = (k*10)^(k*10) = (k*10)^k * 10^(k*10) = C * 10^(k*10)\n    // => last 10 digits will be 0s\n    return 0;\n  }\n  return [...Array(n - 1)].reduce(acc => getLast10Digits(acc) * n, n);\n}\nfunction getLast10Digits(n) {\n  // returns the last 10 digits of a number\n  return +n.toString().slice(-10);\n}",
    "utils": []
  },
  {
    "id": "49",
    "title": "Prime permutations",
    "description": [
      null,
      "The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, is unusual in two ways:",
      null,
      "(i) each of the three terms are prime, and,",
      null,
      "(ii) each of the 4-digit numbers are permutations of one another.",
      null
    ],
    "question": [
      "There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, exhibiting this property, but there is one other 4-digit increasing sequence. What 12-digit number do you form by concatenating the three terms in this sequence?"
    ],
    "guide": [
      "The comments in the code explains how the search is performed.",
      "<br />"
    ],
    "solution": "// we generate all primes under 10000,\n// for each prime generated we sort their digits from lower to higher, and classify them in a table\n// Equivalence Class table, the key represents the equivalence class number (e.g 1478)\n// And the value will be the list of primes in that equivalence class\n// e.g. for 1478, the value will be [ '1487', '1847', '4817', '4871', '7481', '7841', '8147', '8741' ]\nconst permutationClassTable = {};\nconst fourDigitPrimes = Object.keys(utils.generatePrimesTable(10000)).filter(x => x >= 1000);\nfor (let i = 0; i < fourDigitPrimes.length; i++) {\n  const sortedDigits = fourDigitPrimes[i].toString().split('').sort().join('');\n  const permutations = permutationClassTable[sortedDigits];\n  if (permutations) {\n    permutationClassTable[sortedDigits].push(fourDigitPrimes[i]);\n  } else {\n    permutationClassTable[sortedDigits] = [fourDigitPrimes[i]];\n  }\n}\n// now that we have our equivalence class table\n// we loop over the keys and for each key, we check the list of corresponding primes\n// for whether or not one number is the average of 2 other numbers\nconst keys = Object.keys(permutationClassTable);\nfor (let i = 0; i < keys.length; i++) {\n  const key = keys[i];\n  if (key !== '1478') { // this answer is given in problem statement\n    const primes = permutationClassTable[key];\n    if (primes.length >= 3) {\n      for (let j = 0; j < primes.length - 2; j++) {\n        for (let k = j + 2; k < primes.length; k++) {\n          const avg = (+primes[j] + +primes[k]) / 2;\n          if (primes.includes(avg.toString())) {\n            return `${primes[j]}${avg}${primes[k]}`;\n          }\n        }\n      }\n    }\n  }\n}",
    "utils": [
      "primes/generatePrimesTable"
    ]
  },
  {
    "id": "50",
    "title": "Consecutive prime sum",
    "description": [
      "The prime 41, can be written as the sum of six consecutive primes:",
      null,
      "41 = 2 + 3 + 5 + 7 + 11 + 13",
      null,
      "This is the longest sum of consecutive primes that adds to a prime below one-hundred.",
      null,
      "The longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, and is equal to 953.",
      null
    ],
    "question": [
      "Which prime, below one-million, can be written as the sum of the most consecutive primes?"
    ],
    "guide": [
      "Guide is in the code comments.",
      "<br />"
    ],
    "solution": "// we begin by generating the list of primes under 1 million\nconst primesTable = utils.generatePrimesTable(1000000);\nconst primesList = Object.keys(primesTable).map(x => +x);\n// next we determine the upper bound for the number of consecutive primes s.t. their sum does not exceed one million\nconst upperConsec = [...primesList].reduce(\n  (sum, curr, i, arr) => {\n    if (sum >= 1000000) {\n      // if sum exceeds one million, returns the number of terms and exit from the reducer\n      arr.splice(1);\n      return i;\n    }\n    return sum + curr;\n  },\n); // spoiler: the upper bound is 547, ie. if you try to add 548 primes, their sum will always exceed one million.\nlet largestSum = 0;\n// t := number of terms in the sum\n// for each t, we sum t consecutive primes and check if their sum is also prime\n// if it is we store that number and continue checking for the current t\n// once we are done we just return the largest sum obtained at the current t\nfor (let t = upperConsec; t >= 21; t--) {\n  let j = 0;\n  let sum = utils.sumArray(primesList.slice(j, j + t));\n  while (sum < 1000000) {\n    if (primesTable[sum] && sum > largestSum) {\n      largestSum = sum;\n    }\n    j++;\n    sum = utils.sumArray(primesList.slice(j, j + t));\n  }\n  if (largestSum > 0) {\n    return largestSum;\n  }\n}",
    "utils": [
      "primes/generatePrimesTable",
      "common/sumArray"
    ]
  },
  {
    "id": "51",
    "title": "Prime digit replacements",
    "description": [
      "By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values:",
      null,
      "13, 23, 43, 53, 73, and 83, are all prime.",
      null,
      "By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit number is the first example having seven primes among the ten generated numbers, yielding the family:",
      null,
      "56003, 56113, 56333, 56443, 56663, 56773, and 56993.",
      null,
      "Consequently 56003, being the first member of this family, is the smallest prime with this property.",
      null
    ],
    "question": [
      "Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family."
    ],
    "guide": [],
    "solution": "// define * as the \"variable\" part, and the rest of digits as the \"fixed\" part\n// the number of * must be a multiple of 3, as otherwise there will be at least 3 numbers in each family which will be divisible by 3\n// because the sum of their digits will be a multiple of 3.\n// we first try with 3 variable digits and 3 fixed digits or less;\nconst candidates = [];\nfor (let fixedDigits = 1; fixedDigits <= 999; fixedDigits++) {\n  // for each fixed set of digits, generate the list of combinations comprising of fixed digits and *'s\n  const binomialCombinations = utils.listOrderedCombinations(fixedDigits, '***');\n  for (let i = 0; i < binomialCombinations.length; i++) {\n    const family = [];\n    let composites = 0;\n    for (let repl = 0; repl <= 9; repl++) { // replacement\n      if (repl !== 0 || binomialCombinations[i][0] !== '*') { // leading 0's aren't valid\n        const familyMember = +binomialCombinations[i].join('').replace(/\\*/g, repl);\n        if (utils.isPrime(familyMember)) {\n          family.push(familyMember);\n          if (family.length >= 8) {\n            candidates.push(family);\n          }\n        } else {\n          composites++;\n          if (composites >= 3) {\n            break;\n          }\n        }\n      }\n    }\n  }\n}\n// from the list of candidates, return the family with the smallest member\nreturn Math.min(candidates.map(x => x[0]));",
    "utils": [
      "combinatorics/listOrderedCombinations",
      "primes/isPrime"
    ]
  },
  {
    "id": "52",
    "title": "Permuted multiples",
    "description": [
      "It can be seen that the number, 125874, and its double, 251748, contain exactly the same digits, but in a different order."
    ],
    "question": [
      "Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits."
    ],
    "guide": [],
    "solution": "// let d denote the number of digits of a number,\n// for each d = 2, 3, 4, 5, 6, 7, ...\n// we only need to check up to 10^d/6 as number greater than this will overflow an extra digit\n// optimizations:\n// 1. we can skip numbers which ends with a 0, since if such a number is qualified,\n// we would already have found a qualified number by dividing this number by 10\n// 2. we can skip even numbers which do not contain 0, as multiplying by 5 will produce a 0 in the result\n// and we can skip odd numbers which do not contain a 5\n// 3. we can skip numbers which do not contain any digit greater than 5, as multiplying by 2 will double the digit sum of the result\n// return console.log(containSameDigits(142857, 285714, 5))\n// search between 2 to 8 digits\nfor (let d = 1; d <= 7; d++) {\n  // define search range for a particular d\n  const min = 10 ** d;\n  const max = Math.floor((10 ** (d + 1)) / 6);\n  let even = false;\n  for (let n = min; n <= max; n++) {\n    even = !even; // we flip the parity flag instead of checking for parity each time\n    if (!canSkip(n, d, even)) { // skip numbers which fulfill the criteria above\n      let failed = false;\n      for (let m = 2; m <= 6; m++) {\n        const product = m * n;\n        if (!containSameDigits(product, n, d)) {\n          failed = true;\n          break;\n        }\n      }\n      if (!failed) {\n        return n;\n      }\n      // if all tests pass, return result\n    }\n  }\n}\n// return true if a contains the same digits of b, where d := number of digits - 1\nfunction containSameDigits(a, b, d) {\n  const balanceArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  // index of this arr represents the digit found in a and b\n  // content of an index i represents the number of occurrences of digit i in a minus the number of occurrences of digit i in b\n  // a and b contain the same digits if, at the end, this array contains all 0s\n  for (let i = 0; i <= d; i++) {\n    balanceArr[+a.toString().charAt(i)]++;\n    balanceArr[+b.toString().charAt(i)]--;\n  }\n  return balanceArr.every(x => x === 0);\n}\n// evaluates if a number is skippable\nfunction canSkip(number, digits, even) {\n  const stringNumber = number.toString();\n  if (stringNumber.charAt(digits) === '0') {\n    return true;\n  }\n  if (even && !stringNumber.includes('0')) {\n    return true;\n  }\n  if (!even && !stringNumber.includes('5')) {\n    return true;\n  }\n  if (stringNumber.split('').every(x => +x < 5)) {\n    return true;\n  }\n  return false;\n}",
    "utils": []
  },
  {
    "id": "53",
    "title": "Combinatorics selections",
    "description": [
      "There are exactly ten ways of selecting three from five, 12345:",
      null,
      "123, 124, 125, 134, 135, 145, 234, 235, 245, and 345",
      null,
      "In combinatorics, we use the notation, C(5, 3) = 10",
      null,
      "In general, C(n, r) = n!/(r!(n−r)!), where r ≤ n",
      null,
      "It is not until n=23, that a value exceeds one-million: C(23, 10)=1144066.",
      null
    ],
    "question": [
      "How many, not necessarily distinct, values of C(n, r) for 1 ≤ n ≤ 100, are greater than one-million?"
    ],
    "guide": [],
    "solution": "// we generate the table of 100 x 100 where each cell, row i, column j holds the result C(i, j)\n// instead of calculating each combination using the formula, we can use basic algebra for the follow update rules:\n// 1. C(n + 1, r) = C(n, r) * N where N = (n+1)/(n-r+1)\n// 2. C(n, r + 1) = C(n, r) * R where R = (n-r)/(r+1) => C(n, r - 1) = C(n, r) * r/(n-r+1)\n// we also know that C(n, r) is greater than one million for all n >= 23 and r = 10, so we don't need to check for r > 10\nlet totalCount = 4; // for n = 23, obvious from problem statement\nconst combinationTable = new Array(101); // for convenience, n = 0 ... 100\nfor (let i = 23; i <= 100; i++) {\n  combinationTable[i] = new Array(11); // r = 0 ... 10\n}\ncombinationTable[23][10] = 1144066;\nfor (let n = 24; n <= 100; n++) { // we can start at 24 given by problem statement\n  for (let r = 10; r > 0; r--) {\n    if (r === 10 && n !== 23) {\n      combinationTable[n][r] = combinationTable[n - 1][r] * n / (n - r);\n    } else {\n      combinationTable[n][r] = combinationTable[n][r + 1] * (r + 1) / (n - r);\n    }\n    if (combinationTable[n][r] < 1000000) {\n      const increment = utils.isEven(n)\n        ? 1 + 2 * (n / 2 - r - 1)\n        : 2 * ((n + 1) / 2 - r - 1);\n      totalCount += increment;\n      break;\n    }\n  }\n}\nreturn totalCount;",
    "utils": [
      "arithmetic/isEven"
    ]
  },
  {
    "id": "54",
    "title": "Poker hands",
    "description": [
      null,
      "In the card game poker, a hand consists of five cards and are ranked, from lowest to highest, in the following way:",
      null,
      "High Card: Highest value card.",
      null,
      "One Pair: Two cards of the same value.",
      null,
      "Two Pairs: Two different pairs.",
      null,
      "Three of a Kind: Three cards of the same value.",
      null,
      "Straight: All cards are consecutive values.",
      null,
      "Flush: All cards of the same suit.",
      null,
      "Full House: Three of a kind and a pair.",
      null,
      "Four of a Kind: Four cards of the same value.",
      null,
      "Straight Flush: All cards are consecutive values of same suit.",
      null,
      "Royal Flush: Ten, Jack, Queen, King, Ace, in same suit.",
      null,
      "The cards are valued in the order:",
      null,
      "2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace.",
      null,
      "If two players have the same ranked hands then the rank made up of the highest value wins; for example, a pair of eights beats a pair of fives. But if two ranks tie for example, both players have a pair of queens, then highest cards in each hand are compared; if the highest cards tie then the next highest cards are compared, and so on.",
      null,
      "The file, [poker.txt @asset p054_poker.txt], contains one-thousand random hands dealt to two players. Each line of the file contains ten cards (separated by a single space): the first five are Player 1's cards and the last five are Player 2's cards.",
      null,
      "You can assume that all hands are valid (no invalid characters or repeated cards), each player's hand is in no specific order, and in each hand there is a clear winner.",
      null
    ],
    "question": [
      "How many hands does Player 1 win?"
    ],
    "guide": [],
    "solution": "// list of possible ranks\nconst RANKS = [2, 3, 4, 5, 6, 7, 8, 9, 'T', 'J', 'Q', 'K', 'A'];\n// generate the list of combinations of straights and all their combinations\n// the keys of the table are the valid combinations of strings of 5 characters (not necessarily in order) which form a straight, ie. J8TQ9\n// the value of each key is the highest rank of that straight\n// note: this method may not be the fastest solution for this problem, but it is much more scalable (eg. 1 million hands instead of 1000)\nconst STRAIGHTS_TABLE = ['A', ...RANKS].reduce( // ace to ace\n  (table, curr, index, arr) => {\n    if (curr === 'J') {\n      arr.splice(1);\n    }\n    const highest = index + 5;\n    const base = arr.slice(index, index + 5);\n    for (let i = 0; i <= 120; i++) {\n      table[utils.getLexicalPermutation(base, i).join('')] = highest;\n    }\n    return table;\n  },\n  {},\n);\nconst GAMES = fs.readFileSync(path.join(__dirname, 'p054_poker.txt')).toString().split('\\n');\nreturn GAMES.reduce((p1Score, currentGame) => {\n  const [p1Hand, p2Hand] = [currentGame.substring(0, 14), currentGame.substring(15, 29)];\n  if (!p1Hand) { // end of games\n    return p1Score;\n  }\n  const [p1HandValue, p2HandValue] = [evaluateHand(p1Hand), evaluateHand(p2Hand)];\n  for (let i = 0; i < p1HandValue.length; i++) {\n    if (p1HandValue[i] > p2HandValue[i]) {\n      return p1Score + 1;\n    }\n    if (p1HandValue[i] < p2HandValue[i]) {\n      return p1Score;\n    }\n  }\n  return p1Score;\n}, 0);\n// input: string of 5 cards, separated by a space\n// output: score of hand, which is an array of size up to 6\n// first element is the rank of the hand, where 9: straight flush, 8: four of a kind, etc.\n// second element is the value of the first type within that rank, ie. a hand with 4 aces will have value 13, a hand with 4 kings value 12, etc.\n// third element is the value of the second type within that rank, ie. if both players have 2 pair of aces and 3 singles, then we compare the\n// second highest value etc.\nfunction evaluateHand(hand) {\n  const cards = hand.split(' ');\n  // FLUSH check\n  // check if every card has the same suit as the first card\n  const firstSuit = cards[0].charAt(1);\n  const isFlush = cards.every(card => card.charAt(1) === firstSuit);\n  // STRAIGHT check\n  // check the generated table of all possible straights\n  const highestStraight = STRAIGHTS_TABLE[cards.map(card => card.charAt(0)).join('')] || false;\n  // same of a kind table, keys are the ranks, values are the number of occurences of that rank\n  const rankTable = cards.reduce((table, currentCard) => {\n    const rank = currentCard.charAt(0);\n    table[rank] = table[rank] ? table[rank] + 1 : 1;\n    return table;\n  }, {});\n  // inverted table of above, keys are occurrences and corresponding values are the ranks that fit that occurrence\n  const occurencesTable = Object.entries(rankTable).reduce((table, [key, value]) => {\n    if (table[value]) {\n      table[value].push(key);\n    } else {\n      table[value] = [key];\n    }\n    return table;\n  }, {});\n  // now that we have all the variables we need, we attempt to match a hand with each hand type from strongest to weakest\n  // STRAIGHT FLUSH\n  if (highestStraight && isFlush) {\n    return [9, getRank(highestStraight)];\n  }\n  // FOUR OF A KIND\n  if (occurencesTable['4']) {\n    return [8, getRank(occurencesTable['4'][0]), getRank(occurencesTable['1'])];\n  }\n  // FULL HOUSE\n  if (occurencesTable['3'] && occurencesTable['2']) {\n    return [7, getRank(occurencesTable['3'][0]), getRank(occurencesTable['2'][0])];\n  }\n  // FLUSH\n  if (isFlush) {\n    return [6, ...occurencesTable['1'].map(getRank).sort(sortBiggest)];\n  }\n  // STRAIGHT\n  if (highestStraight) {\n    return [5, getRank(highestStraight)];\n  }\n  // THREE OF A KIND\n  if (occurencesTable['3']) {\n    return [4, getRank(occurencesTable['3'][0]), ...occurencesTable['1'].map(getRank).sort(sortBiggest)];\n  }\n  // TWO PAIRS\n  if (occurencesTable['2'] && occurencesTable['2'].length === 2) {\n    return [3, ...occurencesTable['2'].map(getRank).sort(sortBiggest), getRank(occurencesTable['1'][0])];\n  }\n  // ONE PAIR\n  if (occurencesTable['2']) {\n    return [2, getRank(occurencesTable['2'][0]), ...occurencesTable['1'].map(getRank).sort(sortBiggest)];\n  }\n  // HIGH CARD\n  return [1, ...occurencesTable['1'].map(getRank).sort(sortBiggest)];\n}\nfunction sortBiggest(a, b) {\n  return b - a;\n}\n// returns the numerical rank of a card from a character\nfunction getRank(card) {\n  if (+card) {\n    return +card;\n  }\n  return {\n    T: 10,\n    J: 11,\n    Q: 12,\n    K: 13,\n    A: 14,\n  }[card];\n}",
    "utils": [
      "combinatorics/getLexicalPermutation"
    ]
  },
  {
    "id": "55",
    "title": "Lychrel numbers",
    "description": [
      null,
      "If we take 47, reverse and add, 47 + 74 = 121, which is palindromic.",
      null,
      "Not all numbers produce palindromes so quickly. For example,",
      null,
      "349 + 943 = 1292,",
      null,
      "1292 + 2921 = 4213",
      null,
      "4213 + 3124 = 7337",
      null,
      "That is, 349 took three iterations to arrive at a palindrome.",
      null,
      "Although no one has proved it yet, it is thought that some numbers, like 196, never produce a palindrome. A number that never forms a palindrome through the reverse and add process is called a Lychrel number. Due to the theoretical nature of these numbers, and for the purpose of this problem, we shall assume that a number is Lychrel until proven otherwise. In addition you are given that for every number below ten-thousand, it will either:",
      null,
      "(i) become a palindrome in less than fifty iterations, or,",
      null,
      "(ii) no one, with all the computing power that exists, has managed so far to map it to a palindrome.",
      null,
      "10677 is the first number to be shown to require over fifty iterations before producing a palindrome: 4668731596684224866951378664 (53 iterations, 28-digits).",
      null,
      "Surprisingly, there are palindromic numbers that are themselves Lychrel numbers; the first example is 4994.",
      null
    ],
    "question": [
      "How many Lychrel numbers are there below ten-thousand?"
    ],
    "guide": [],
    "solution": "const lychrelNumbers = {}; // memoized table for all lychrel numbers (doesnt terminate)\nconst nonLychrelNumbers = {}; // numbers which produce a palindrome through reverse add\nfor (let n = 1; n <= 10000; n++) {\n  testLychrel(n);\n}\nfunction testLychrel(n) {\n  const encounteredNumbers = {};\n  let sum = n;\n  for (let i = 1; i <= 50; i++) {\n    const flipped = utils.flip(sum);\n    encounteredNumbers[sum] = true;\n    if (sum % 10) {\n      encounteredNumbers[flipped] = true;\n    }\n    if (nonLychrelNumbers[sum]) {\n      Object.assign(nonLychrelNumbers, encounteredNumbers);\n      break;\n    }\n    if (lychrelNumbers[sum] || i === 50) {\n      Object.assign(lychrelNumbers, encounteredNumbers);\n      break;\n    }\n    sum += flipped;\n    if (utils.isPalindrome(sum)) {\n      Object.assign(nonLychrelNumbers, encounteredNumbers);\n      break;\n    }\n  }\n}\nreturn Object.keys(lychrelNumbers).filter(x => x <= 10000).length;",
    "utils": [
      "lang/flip",
      "lang/isPalindrome"
    ]
  },
  {
    "id": "56",
    "title": "Powerful digit sum",
    "description": [
      null,
      "A googol (10^100) is a massive number: one followed by one-hundred zeros;",
      null,
      "100^100 is almost unimaginably large: one followed by two-hundred zeros.",
      null,
      "Despite their size, the sum of the digits in each number is only 1.",
      null
    ],
    "question": [
      "Considering natural numbers of the form, ab, where a, b < 100, what is the maximum digital sum?"
    ],
    "guide": [],
    "solution": "const expTable = [...Array(99)].map((x, i) => [(i + 1).toString()]); // initialize\nlet largestDigitSum = 0;\nexpTable.forEach((column, colIndex) => {\n  const base = colIndex + 1;\n  // each column i contains the result of [i ^ 1, i ^ 2, ..., i ^ 99]\n  // we will skip numbers < 10 and multiples of 10\n  if (base < 10 || base % 10 === 0) {\n    return null;\n  }\n  for (let exp = 1; exp <= 99; exp++) {\n    const result = longMultiply(column[exp - 1], base.toString());\n    const digitSum = utils.sumArray(result, x => +x);\n    if (digitSum > largestDigitSum) {\n      largestDigitSum = digitSum;\n    }\n    column.push(result.reverse().join(''));\n  }\n});\nreturn largestDigitSum;\n// takes 2 strings of numbers as params, returns an array containing the digits of the product of the 2 numbers\n// multiplies the 2 numbers using long multiplication\nfunction longMultiply(a, b) {\n  const mTable = {};\n  const [n1, n2] = [a.split('').reverse(), b.split('').reverse()];\n  const partialResultsTable = n2.reduce(\n    (acc, curr, idx) => {\n      if (curr) {\n        const power = idx;\n        const results = mTable[curr] || n1.map(x => x * curr);\n        mTable[curr] = results;\n        results.forEach((partialProduct, i) => {\n          if (!acc[power + i + 1]) acc[power + i + 1] = [];\n          if (partialProduct < 10) {\n            acc[power + i].push(partialProduct);\n          } else {\n            acc[power + i].push(partialProduct.toString().split('')[1]);\n            acc[power + i + 1].push(partialProduct.toString().split('')[0]);\n          }\n        });\n      }\n      return acc;\n    },\n    [[]],\n  );\n  // add the digits with respect to their positions\n  return consolidatePartialResults(partialResultsTable);\n}\nfunction consolidatePartialResults(table) {\n  const flatResults = [];\n  let carry = 0;\n  for (let columnIndex = 0; columnIndex < table.length; columnIndex++) {\n    const col = table[columnIndex];\n    const sum = (col.reduce((a, c) => +c + a, 0) + +carry).toString();\n    const retainedDigit = sum.slice(-1);\n    carry = sum.slice(0, sum.length - 1);\n    flatResults.push(retainedDigit);\n  }\n  return flatResults;\n}",
    "utils": [
      "common/sumArray"
    ]
  },
  {
    "id": "57",
    "title": "Square root convergents",
    "description": [
      "It is possible to show that the square root of two can be expressed as an infinite continued fraction.",
      null,
      "@math \\sqrt 2 =1+ \\frac 1 {2+ \\frac 1 {2 +\\frac 1 {2+ \\dots}}}",
      null,
      "By expanding for the first four iterations. we get:",
      null,
      "@math 1 + \\frac 1 2 = \\frac  32 = 1.5",
      "@math 1 + \\frac 1 {2 + \\frac 1 2} = \\frac 7 5 = 1.4",
      "@math 1 + \\frac 1 {2 + \\frac 1 {2+\\frac 1 2}} = \\frac {17}{12} = 1.41666 \\dots",
      "@math 1 + \\frac 1 {2 + \\frac 1 {2+\\frac 1 {2+\\frac 1 2}}} = \\frac {41}{29} = 1.41379 \\dots",
      null,
      "The next three expansions are 41/29, 99/70, and 239/169, but the 8th expansion, 1393/985, is the first example where the number of digits in the numerator exceeds the number of digits in the denominator.",
      null
    ],
    "question": [
      "In the first one-thousand expansions, how many fractions contain a numerator with more digits than the denominator?"
    ],
    "guide": [],
    "solution": "let currentExpansion = [3n, 2n];\nlet numeratorDigitExcessCount = 0;\nfor (let i = 1; i < 1000; i++) {\n  currentExpansion = computeNextCF(currentExpansion);\n  if (currentExpansion[0].toString().length > currentExpansion[1].toString().length) {\n    numeratorDigitExcessCount++;\n  }\n}\n// compute the next continued fraction expansion based on the current expansion\nfunction computeNextCF([n, d]) {\n  return [2n * d + n, d + n];\n}\nreturn numeratorDigitExcessCount;",
    "utils": []
  },
  {
    "id": "58",
    "title": "Spiral Primes",
    "description": [
      "Starting with 1 and spiralling anticlockwise in the following way, a square spiral with side length 7 is formed.",
      null,
      " 37 36 35 34 33 32 31",
      null,
      " 38 17 16 15 14 13 30",
      null,
      " 39 18 05 04 03 12 29",
      null,
      " 40 19 06 01 02 11 28",
      null,
      " 41 20 07 08 09 10 27",
      null,
      " 42 21 22 23 24 25 26",
      null,
      " 43 44 45 46 47 48 49",
      null,
      "It is interesting to note that the odd squares lie along the bottom right diagonal, but what is more interesting is that 8 out of the 13 numbers lying along both diagonals are prime; that is, a ratio of 8/13 ≈ 62%.",
      null,
      "If one complete new layer is wrapped around the spiral above, a square spiral with side length 9 will be formed.",
      null
    ],
    "question": [
      "If this process is continued, what is the side length of the square spiral for which the ratio of primes along both diagonals first falls below 10%?"
    ],
    "guide": [],
    "solution": "// generate a table of 1 million primes\n// const PRIMES = utils.generatePrimesTable(10000000);\n// start from the second layer\nlet currentNumber = 9;\nlet primes = 3;\nlet diagonals = 5;\nlet sideLength = 3;\nwhile (`${primes}0` >= diagonals) {\n  sideLength += 2;\n  diagonals += 4;\n  const incr = sideLength - 1;\n  for (let i = 0; i < 4; i++) {\n    currentNumber += incr;\n    if (utils.isPrime(currentNumber)) {\n      primes++;\n    }\n  }\n}\nreturn sideLength;",
    "utils": [
      "primes/isPrime"
    ]
  },
  {
    "id": "59",
    "title": "XOR decryption",
    "description": [
      null,
      "Each character on a computer is assigned a unique code and the preferred standard is ASCII (American Standard Code for Information Interchange). For example, uppercase A = 65, asterisk (*) = 42, and lowercase k = 107.",
      null,
      "A modern encryption method is to take a text file, convert the bytes to ASCII, then XOR each byte with a given value, taken from a secret key. The advantage with the XOR function is that using the same encryption key on the cipher text, restores the plain text; for example, 65 XOR 42 = 107, then 107 XOR 42 = 65.",
      null,
      "For unbreakable encryption, the key is the same length as the plain text message, and the key is made up of random bytes. The user would keep the encrypted message and the encryption key in different locations, and without both \"halves\", it is impossible to decrypt the message.",
      null,
      "Unfortunately, this method is impractical for most users, so the modified method is to use a password as a key. If the password is shorter than the message, which is likely, the key is repeated cyclically throughout the message. The balance for this method is using a sufficiently long password key for security, but short enough to be memorable.",
      null,
      "Your task has been made easy, as the encryption key consists of three lower case characters.",
      null
    ],
    "question": [
      "Using [p059_cipher.txt @asset p059_cipher.txt], a file containing the encrypted ASCII codes, and the knowledge that the plain text must contain common English words, decrypt the message and find the sum of the ASCII values in the original text."
    ],
    "guide": [],
    "solution": "// we start by compiling a list of valid password characters for each position\n// we check each character of the password one by one, that is, we start with 'a', and we XOR it with the 1st, 4th, 7th, etc. characters of the cyphertext\n// if at any point we xor a resulting character which is not a valid character for english text, ie. a-z, A-Z and punctuations, we discard it\n// we repeat for the second and third character of the password p059_cipher.txt\nconst formatted = fs.readFileSync('6/p059_cipher.txt').toString().split(',').map(x => +x);\nconst filtered = {\n  first: formatted.filter((_, i) => i % 3 === 0), // every third ascii starting from pos 0\n  second: formatted.filter((_, i) => i % 3 === 1), // every third ascii starting from pos 1\n  third: formatted.filter((_, i) => i % 3 === 2), // every third ascii starting from pos 2\n};\nconst validPass = {\n  first: [],\n  second: [],\n  third: [],\n};\nfor (let i = 97; i <= 122; i++) {\n  if (isPassValid(i, 'first')) {\n    validPass.first.push(i);\n  }\n  if (isPassValid(i, 'second')) {\n    validPass.second.push(i);\n  }\n  if (isPassValid(i, 'third')) {\n    validPass.third.push(i);\n  }\n}\nfunction isAsciiValid(ascii) {\n  // include all characters that can be typed on a standard english keyboard,\n  // except fractions, tab, and the following: \\{}|`~^_\n  return (ascii >= 32 && ascii <= 90) || (ascii >= 97 && ascii <= 122) || ascii === 91 || ascii === 93;\n}\nfunction isPassValid(code, startPosition) {\n  const encryptedChars = filtered[startPosition];\n  const isValid = encryptedChars.every((x) => {\n    return isAsciiValid((x ^ code));\n  });\n  return isValid;\n}\n// console.log(validPass) // this will yield { first: [101], second: [120], third: [112] }\nconst password = [101, 120, 112];\nconst plaintext = formatted.map((char, i) => char ^ password[i % 3]);\n// console.log(String.fromCharCode(...plaintext)); // this will yield the following plaintext output\n/*\nAn extract taken from the introduction of one of Euler's most celebrated papers,\n\"De summis serierum reciprocarum\" [On the sums of series of reciprocals]: I have\nrecently found, quite unexpectedly, an elegant expression for the entire sum of\nthis series 1 + 1/4 + 1/9 + 1/16 + etc., which depends on the quadrature of the\ncircle, so that if the true sum of this series is obtained, from it at once the\nquadrature of the circle follows. Namely, I have found that the sum of this series\nis a sixth part of the square of the perimeter of the circle whose diameter is 1;\nor by putting the sum of this series equal to s, it has the ratio sqrt(6) multiplied\nby s to 1 of the perimeter to the diameter. I will soon show that the sum of this\nseries to be approximately 1.644934066842264364; and from multiplying this number\nby six, and then taking the square root, the number 3.141592653589793238 is indeed\nproduced, which expresses the perimeter of a circle whose diameter is 1. Following\nagain the same steps by which I had arrived at this sum, I have discovered that the\nsum of the series 1 + 1/16 + 1/81 + 1/256 + 1/625 + etc. also depends on the\nquadrature of the circle. Namely, the sum of this multiplied by 90 gives the biquadrate\n(fourth power) of the circumference of the perimeter of a circle whose\ndiameter is 1. And by similar reasoning I have likewise been able to determine the sums\nof the subsequent series in which the exponents are even numbers.\n*/\nreturn utils.sumArray(plaintext);",
    "utils": [
      "common/sumArray"
    ]
  },
  {
    "id": "60",
    "title": "Prime pair sets",
    "description": [
      null,
      "The primes 3, 7, 109, and 673, are quite remarkable. By taking any two primes and concatenating them in any order the result will always be prime.",
      null,
      "For example, taking 7 and 109, both 7109 and 1097 are prime. The sum of these four primes, 792, represents the lowest sum for a set of four primes with this property.",
      null
    ],
    "question": [
      "Find the lowest sum for a set of five primes for which any two primes concatenate to produce another prime."
    ],
    "guide": [],
    "solution": "const PRIMES_TABLE = utils.generatePrimesTable(100000);\ndelete PRIMES_TABLE['2'];\ndelete PRIMES_TABLE['5'];\nconst PRIMES_ARR = Object.keys(PRIMES_TABLE);\nconst largestGeneratedPrime = PRIMES_ARR[PRIMES_ARR.length - 1];\n// we build tables which contains matching pairs, matching triples and matching quads\n// we iteratively build them on top of each other\n// for example, if we found a prime which matches with an existing member in the table of matched pairs\n// then we can insert that prime, along with the matched pair, into the table of matched triples\n// so on and so forth until we reach a matched quintuple\nconst matchingPairsTable = {}; // prime pairs\nconst matchingTriplesTable = {}; // connected prime triples\nconst matchingQuadsTable = {}; // connected prime quads\nconst matchingQuintsTable = {}; // connected prime quint (answer)\nfor (let i = 0; i < PRIMES_ARR.length; i++) {\n  const prime = PRIMES_ARR[i];\n  const newMatchingPairs = {};\n  for (let j = 0; j < i; j++) {\n    const smallerPrime = PRIMES_ARR[j];\n    if (doesMatch(smallerPrime, prime)) {\n      newMatchingPairs[`${smallerPrime}|${prime}`] = true;\n    }\n  }\n  const newMatchingTriples = {};\n  const matchingPairs = Object.keys(matchingPairsTable);\n  matchingPairs.forEach((pair) => {\n    if (pair.split('|').every(part => newMatchingPairs[`${part}|${prime}`])) {\n      newMatchingTriples[`${pair}|${prime}`] = true;\n    }\n  });\n  const newMatchingQuads = {};\n  const matchingTriples = Object.keys(matchingTriplesTable);\n  matchingTriples.forEach((triple) => {\n    if (triple.split('|').every(part => newMatchingPairs[`${part}|${prime}`])) {\n      newMatchingQuads[`${triple}|${prime}`] = true;\n    }\n  });\n  const newMatchingQuints = {};\n  const matchingQuads = Object.keys(matchingQuadsTable);\n  matchingQuads.forEach((quad) => {\n    if (quad.split('|').every(part => newMatchingPairs[`${part}|${prime}`])) {\n      newMatchingQuints[`${quad}|${prime}`] = true;\n    }\n  });\n  Object.assign(matchingPairsTable, newMatchingPairs);\n  Object.assign(matchingTriplesTable, newMatchingTriples);\n  Object.assign(matchingQuadsTable, newMatchingQuads);\n  Object.assign(matchingQuintsTable, newMatchingQuints);\n  if (Object.keys(matchingQuintsTable).length) {\n    return utils.sumArray(Object.keys(matchingQuintsTable)[0].split('|').map(x => +x));\n  }\n}\n// returns true if a member can be accepted into a family\nfunction doesMatch(oldPrime, newPrime) {\n  const concat1 = concat(+oldPrime, +newPrime);\n  const concat2 = concat(+newPrime, +oldPrime);\n  return (concat1 > largestGeneratedPrime || concat2 > largestGeneratedPrime\n    ? utils.isPrime(concat1) && utils.isPrime(concat2)\n    : PRIMES_TABLE[concat1] && PRIMES_TABLE[concat2]);\n}\nfunction concat(n1, n2) {\n  return n1 * (10 ** n2.toString().length) + n2;\n}",
    "utils": [
      "primes/generatePrimesTable",
      "common/sumArray",
      "primes/isPrime"
    ]
  },
  {
    "id": "61",
    "title": "Cyclical figurate numbers",
    "description": [
      null,
      "Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:",
      null,
      "Triangle P3,n=n(n+1)/2  1, 3, 6, 10, 15, ...",
      null,
      "Square P4,n=n²  1, 4, 9, 16, 25, ...",
      null,
      "Pentagonal P5,n=n(3n−1)/2   1, 5, 12, 22, 35, ...",
      null,
      "Hexagonal P6,n=n(2n−1)   1, 6, 15, 28, 45, ...",
      null,
      "Heptagonal P7,n=n(5n−3)/2   1, 7, 18, 34, 55, ...",
      null,
      "Octagonal P8,n=n(3n−2)   1, 8, 21, 40, 65, ...",
      null,
      "The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.",
      null,
      "1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).",
      null,
      "2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.",
      null,
      "3. This is the only set of 4-digit numbers with this property.",
      null
    ],
    "question": [
      "Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set."
    ],
    "guide": [],
    "solution": "const polygonalTables = [{}, {}, {}, {}, {}, {}];\nconst startingIndexes = [45, 32, 26, 23, 21, 19];\nconst polygonGenerators = [\n  n => n * (n + 1) / 2,\n  n => n * n,\n  n => n * (3 * n - 1) / 2,\n  n => n * (2 * n - 1),\n  n => n * (5 * n - 3) / 2,\n  n => n * (3 * n - 2),\n];\n// table indexed by prefixes\n// constructed such that finding all the polygonals starting with any 2 digits can be done with O(1)\nconst prefixLookup = {};\nfor (let i = 0; i < startingIndexes.length; i++) {\n  const side = i + 3;\n  const startingIndex = startingIndexes[i];\n  let generatedNumber = 0;\n  for (let n = startingIndex; generatedNumber < 10000; n++) {\n    generatedNumber = polygonGenerators[i](n);\n    const [prefix, suffix] = `${generatedNumber}`.match(/\\d{1,2}/g);\n    if (suffix.charAt(0) === '0' || generatedNumber > 9999) {\n      // third digit is 0, cannot be in a cycle\n      continue;\n    }\n    polygonalTables[i][generatedNumber] = true;\n    if (!prefixLookup[prefix]) {\n      prefixLookup[prefix] = {};\n    }\n    if (!prefixLookup[prefix][side]) {\n      prefixLookup[prefix][side] = [];\n    }\n    prefixLookup[prefix][side].push(generatedNumber);\n  }\n}\nconst octagons = polygonalTables[5];\n// simulate a tree, recursively find a path of length 6\nfunction findPath(path, acc) {\n  // cycle complete\n  if (path.length === 6) {\n    const first = path[0];\n    const last = path[5];\n    if (Math.floor(first / 100) === last % 100) {\n      // FOUND!\n      return path;\n    }\n    return false;\n  }\n  const last = path[path.length - 1];\n  const suffix = last.toString().match(/\\d{1,2}/g)[1];\n  // all polygonals starting with the current suffix\n  const nextPolygons = prefixLookup[suffix];\n  if (!nextPolygons) {\n    return false;\n  }\n  // find the next polygon from all sides which are still missing from the cycle\n  const missingSides = Object.keys(acc).filter(key => !acc[key]);\n  for (let i = 0; i < missingSides.length; i++) {\n    const missingSide = missingSides[i];\n    const nextMatchingPolygons = nextPolygons[missingSide];\n    if (nextMatchingPolygons) {\n      for (let j = 0; j < nextMatchingPolygons.length; j++) {\n        const nextPolygon = nextMatchingPolygons[j];\n        // if a valid path is found, return it, otherwise keep looping\n        const findNextPath = findPath([...path, nextPolygon], { ...acc, [missingSide]: nextPolygon });\n        if (findNextPath) {\n          return findNextPath;\n        }\n      }\n    }\n  }\n  // if no polygons are found with none of the missing sides, return false\n  return false;\n}\n// we start our path from the octagons to minimize loop count\nfor (let o = 0; o < Object.keys(octagons).length; o++) {\n  const octagon = +Object.keys(octagons)[o];\n  const validPath = findPath([octagon], {\n    3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: octagon,\n  });\n  if (validPath) {\n    return utils.sumArray(validPath);\n  }\n}",
    "utils": [
      "common/sumArray"
    ]
  },
  {
    "id": "62",
    "title": "Cubic permutations",
    "description": [
      null,
      "The cube, 41063625 (345^3), can be permuted to produce two other cubes: 56623104 (384^3) and 66430125 (405^3).",
      null,
      "In fact, 41063625 is the smallest cube which has exactly three permutations of its digits which are also cube.",
      null
    ],
    "question": [
      "Find the smallest cube for which exactly five permutations of its digits are cube."
    ],
    "guide": [],
    "solution": "// we generate a cube, sort its digits, and index it\n// whenever an index has length 5, return result\nconst cubeClasses = {};\nlet base = 1;\nlet found = false;\nwhile (!found) {\n  const cube = base ** 3;\n  const sortedKey = cube.toString().split('').sort().join('');\n  if (!cubeClasses[sortedKey]) {\n    cubeClasses[sortedKey] = [cube];\n  } else {\n    cubeClasses[sortedKey].push(cube);\n  }\n  if (cubeClasses[sortedKey].length > 4) {\n    found = true;\n    return cubeClasses[sortedKey][0];\n  }\n  base++;\n}",
    "utils": []
  },
  {
    "id": "63",
    "title": "Powerful digit counts",
    "description": [
      null,
      "The 5-digit number, 16807=7^5, is also a fifth power. Similarly, the 9-digit number, 134217728=8^9, is a ninth power."
    ],
    "question": [
      "How many n-digit positive integers exist which are also an nth power?"
    ],
    "guide": [],
    "solution": "let answer = 0;\n// we reach the limit when the number of digits of 9^n is smaller than n\nlet limitReached = false;\nlet exponent = 1;\nwhile (!limitReached) {\n  for (let digit = 9; digit > 0; digit--) {\n    const power = digit ** exponent;\n    const digitCount = power.toString().length;\n    if (digitCount < exponent) {\n      if (digit === 9) {\n        limitReached = true;\n        return answer;\n      }\n      break;\n    }\n    answer++;\n  }\n  exponent++;\n}",
    "utils": []
  },
  {
    "id": "64",
    "title": "Odd period square roots",
    "description": [
      null,
      "All square roots are periodic when written as continued fractions and can be written in the form:",
      null,
      "@math \\displaystyle \\quad \\quad \\sqrt{N}=a_0+\\frac 1 {a_1+\\frac 1 {a_2+ \\frac 1 {a3+ \\dots}}}",
      null,
      "For example, let us consider √23:",
      null,
      "@math \\quad \\quad \\sqrt{23}=4+\\sqrt{23}-4=4+\\frac 1 {\\frac 1 {\\sqrt{23}-4}}=4+\\frac 1  {1+\\frac{\\sqrt{23}-3}7}",
      null,
      "If we continue we would get the following expansion:",
      null,
      "@math \\displaystyle \\quad \\quad \\sqrt{23}=4+\\frac 1 {1+\\frac 1 {3+ \\frac 1 {1+\\frac 1 {8+ \\dots}}}}",
      null,
      "The process can be summarized as follows:",
      null,
      "@math \\quad \\quad a_0=4, \\frac 1 {\\sqrt{23}-4}=\\frac {\\sqrt{23}+4} 7=1+\\frac {\\sqrt{23}-3} 7",
      "@math \\quad \\quad a_1=1, \\frac 7 {\\sqrt{23}-3}=\\frac {7(\\sqrt{23}+3)} {14}=3+\\frac {\\sqrt{23}-3} 2",
      "@math \\quad \\quad a_2=3, \\frac 2 {\\sqrt{23}-3}=\\frac {2(\\sqrt{23}+3)} {14}=1+\\frac {\\sqrt{23}-4} 7",
      "@math \\quad \\quad a_3=1, \\frac 7 {\\sqrt{23}-4}=\\frac {7(\\sqrt{23}+4)} 7=8+\\sqrt{23}-4",
      "@math \\quad \\quad a_4=8, \\frac 1 {\\sqrt{23}-4}=\\frac {\\sqrt{23}+4} 7=1+\\frac {\\sqrt{23}-3} 7",
      "@math \\quad \\quad a_5=1, \\frac 7 {\\sqrt{23}-3}=\\frac {7 (\\sqrt{23}+3)} {14}=3+\\frac {\\sqrt{23}-3} 2",
      "@math \\quad \\quad a_6=3, \\frac 2 {\\sqrt{23}-3}=\\frac {2(\\sqrt{23}+3)} {14}=1+\\frac {\\sqrt{23}-4} 7",
      "@math \\quad \\quad a_7=1, \\frac 7 {\\sqrt{23}-4}=\\frac {7(\\sqrt{23}+4)} {7}=8+\\sqrt{23}-4",
      null,
      "It can be seen that the sequence is repeating. For conciseness, we use the notation √23=[4;(1,3,1,8)], to indicate that the block (1,3,1,8) repeats indefinitely.",
      null,
      "The first ten continued fraction representations of (irrational) square roots are:",
      null,
      "√2 = [1;(2)] , period=1",
      null,
      "√3 = [1;(1,2)], period=2",
      null,
      "√5 = [2;(4)], period=1",
      null,
      "√6 = [2;(2,4)], period=2",
      null,
      "√7 = [2;(1,1,1,4)], period=4",
      null,
      "√8 = [2;(1,4)], period=2",
      null,
      "√10 = [3;(6)], period=1",
      null,
      "√11 = [3;(3,6)], period=2",
      null,
      "√12 = [3;(2,6)], period=2",
      null,
      "√13 = [3;(1,1,1,1,6)], period=5",
      null,
      "Exactly four continued fractions, for N≤13, have an odd period.",
      null
    ],
    "question": [
      "How many continued fractions for N≤10000 have an odd period?"
    ],
    "guide": [],
    "solution": "const squares = [...Array(100)].reduce((acc, _, i) => {\n  acc[i ** 2] = true;\n  return acc;\n}, {});\nlet answer = 0;\nfor (let N = 2; N < 10000; N++) {\n  if (squares[N]) {\n    continue;\n  }\n  // we generate the sequence of isolated integers (ie. leading numbers in the continued fraction sequence) by\n  // 1. Normalizing our irrational fraction (ie. numerator/(root-offset)) by multiplying by (root+offset)/(root+offset)\n  // 2. Isolating the next leading integer by finding the integral part of our normalized fraction\n  // 3. flip the fractional part to use for the next iteration\n  const root = Math.sqrt(N);\n  const floor = Math.floor(root);\n  let repetitionFound = false; // if a repetition has been found, we can exit the loop (explained below)\n  // the following variables are updated on every iteration\n  let period = 0; // period count\n  let isolatedInteger = floor; // leading digit of our current iteration\n  let normalizedDenominator; // the denominator as a result of normalization\n  // the normalized and reduced denominator (by the initial numerator) of the previous iteration\n  let initialNumerator = 1;\n  // the offset found in the denominator as a result of isolating the leading integer from the previous iteration\n  let denominatorOffset = floor;\n  while (!repetitionFound) {\n    // normalize\n    normalizedDenominator = N - (denominatorOffset ** 2);\n    // isolate\n    isolatedInteger = Math.floor(initialNumerator * (floor + denominatorOffset) / normalizedDenominator);\n    period++;\n    if (normalizedDenominator === initialNumerator) {\n      // the initialNumerator always starts with 1\n      // if the above two variables are equal, then the next initialNumerator will be 1,\n      // which will cause the cycle to repeat\n      repetitionFound = true;\n      if (period & 1) {\n        answer++;\n      }\n      break;\n    }\n    // update for next iteration\n    initialNumerator = normalizedDenominator / initialNumerator;\n    denominatorOffset = Math.abs(denominatorOffset - initialNumerator * isolatedInteger);\n  }\n}\nreturn answer;",
    "utils": []
  },
  {
    "id": "65",
    "title": "Convergents of e",
    "description": [
      null,
      "The square root of 2 can be written as an infinite continued fraction.",
      null,
      "@math \\sqrt{2} = 1 + \\dfrac{1}{2 + \\dfrac{1}{2 + \\dfrac{1}{2 + \\dfrac{1}{2 + ...}}}}",
      null,
      "The infinite continued fraction can be written, √2=[1;(2)], (2) indicates that 2 repeats ad infinitum. In a similar way, √23=[4;(1,3,1,8)].",
      null,
      "It turns out that the sequence of partial values of continued fractions for square roots provide the best rational approximations. Let us consider the convergents for √2.",
      null,
      "@math 1 + \\dfrac{1}{2} = \\dfrac{3}{2}",
      "@math 1 + \\dfrac{1}{2 + \\dfrac{1}{2}} = \\dfrac{7}{5}",
      "@math 1 + \\dfrac{1}{2 + \\dfrac{1}{2 + \\dfrac{1}{2}}} = \\dfrac{17}{12}",
      "@math 1 + \\dfrac{1}{2 + \\dfrac{1}{2 + \\dfrac{1}{2 + \\dfrac{1}{2}}}} = \\dfrac{41}{29}",
      null,
      "Hence the sequence of the first ten convergents for √2 are:",
      null,
      "@math 1, \\dfrac{3}{2}, \\dfrac{7}{5}, \\dfrac{17}{12}, \\dfrac{41}{29}, \\dfrac{99}{70}, \\dfrac{239}{169}, \\dfrac{577}{408}, \\dfrac{1393}{985}, \\dfrac{3363}{2378}, ...",
      null,
      "What is most surprising is that the important mathematical constant,",
      null,
      "@math e = [2; 1, 2, 1, 1, 4, 1, 1, 6, 1, ... , 1, 2k, 1, ...]",
      null,
      "The first ten terms in the sequence of convergents for e are:",
      null,
      "@math 2, 3, \\dfrac{8}{3}, \\dfrac{11}{4}, \\dfrac{19}{7}, \\dfrac{87}{32}, \\dfrac{106}{39}, \\dfrac{193}{71}, \\dfrac{1264}{465}, \\dfrac{1457}{536}, ...",
      null,
      "The sum of digits in the numerator of the 10th convergent is 1+4+5+7=17.",
      null
    ],
    "question": [
      "Find the sum of digits in the numerator of the 100th convergent of the continued fraction e"
    ],
    "guide": [],
    "solution": "function getNthLeadingInteger(n) {\n  if (n < 3) {\n    return n;\n  }\n  if (n % 3 === 2) {\n    return 2 * (Math.floor(n / 3) + 1);\n  }\n  return 1;\n}\nconst target = 100;\nlet numerator = 1n;\nlet denominator = BigInt(getNthLeadingInteger(target - 1));\nfor (let i = target - 1; i >= 1; i--) {\n  const nextLeadingInteger = BigInt(getNthLeadingInteger(i - 1));\n  [numerator, denominator] = [denominator, nextLeadingInteger * denominator + numerator];\n}\nnumerator += (denominator * 2n); // add leading constant\nreturn utils.sumArray(numerator.toString().split(''), n => +n);",
    "utils": [
      "common/sumArray"
    ]
  },
  {
    "id": "66",
    "title": "Diophantine equation",
    "description": [
      null,
      "Consider quadratic Diophantine equations of the form: x² - D * y² = 1",
      null,
      "For example, when D=13, the minimal solution in x is 649² – 13×180² = 1.",
      null,
      "It can be assumed that there are no solutions in positive integers when D is square.",
      null,
      "By finding minimal solutions in x for D = {2, 3, 5, 6, 7}, we obtain the following:",
      null,
      "3² – 2×2 = 1",
      null,
      "2² – 3×1² = 1",
      null,
      "9² – 5×4² = 1",
      null,
      "5² – 6×2² = 1",
      null,
      "8² – 7×3² = 1",
      null,
      "Hence, by considering minimal solutions in x for D ≤ 7, the largest x is obtained when D=5.",
      null
    ],
    "question": [
      "Find the value of D ≤ 1000 in minimal solutions of x for which the largest value of x is obtained."
    ],
    "guide": [],
    "solution": "// to solve for (x,y) for any D, we need to:\n// 1. find the sequence of leading digits for the continued fractions of sqrt(D)\n// 2. from the list above, expand continued fractions until a solution is found\nlet largestSolution = 0n;\nlet ANSWER = 0;\n// we combine the previous 2 solutions to achieve the steps above\nfor (let D = 2; D <= 1000; D++) {\n  // find leading digits\n  const sqrt = Math.sqrt(D);\n  const floor = Math.floor(sqrt);\n  if (sqrt === floor) {\n    continue;\n  }\n  let repetitionFound = false; // if a repetition has been found, we can exit the loop (explained below)\n  // Step 1: Sequence of leading digits\n  const leadingDigits = [];\n  let isolatedInteger = floor; // leading digit of our current iteration\n  let normalizedDenominator; // the denominator as a result of normalization\n  // the normalized and reduced denominator (by the initial numerator) of the previous iteration\n  let initialNumerator = 1;\n  // the offset found in the denominator as a result of isolating the leading integer from the previous iteration\n  let denominatorOffset = floor;\n  while (!repetitionFound) {\n    // normalize\n    normalizedDenominator = D - (denominatorOffset ** 2);\n    // isolate\n    isolatedInteger = Math.floor(initialNumerator * (floor + denominatorOffset) / normalizedDenominator);\n    leadingDigits.push(isolatedInteger);\n    if (normalizedDenominator === initialNumerator) {\n      // the initialNumerator always starts with 1\n      // if the above two variables are equal, then the next initialNumerator will be 1,\n      // which will cause the cycle to repeat\n      repetitionFound = true;\n      break;\n    }\n    // update for next iteration\n    initialNumerator = normalizedDenominator / initialNumerator;\n    denominatorOffset = Math.abs(denominatorOffset - initialNumerator * isolatedInteger);\n  }\n  // Step 2: search for solution\n  // solution verifier\n  const isSolution = (x, y) => (((x ** 2n) - (BigInt(D) * (y ** 2n))) === 1n);\n  // returns nth leading integer in the continued fraction expansion of sqrt(D)\n  const getNthLeadingInteger = n => leadingDigits[(n - 1) % leadingDigits.length];\n  // initial values\n  let target = 1;\n  let numerator = BigInt(1);\n  let denominator = BigInt(getNthLeadingInteger(target));\n  // loop while a solution is not found\n  while (!isSolution(numerator, denominator)) {\n    numerator = BigInt(1);\n    denominator = BigInt(getNthLeadingInteger(target));\n    // find the convergent at the `target` index by using backtracking\n    for (let i = target - 1; i >= 1; i--) {\n      const nextLeadingInteger = BigInt(getNthLeadingInteger(i));\n      [numerator, denominator] = [denominator, nextLeadingInteger * denominator + numerator];\n    }\n    numerator += (denominator * BigInt(floor));\n    target++;\n  }\n  if (numerator > largestSolution) {\n    largestSolution = numerator;\n    ANSWER = D;\n  }\n}\nreturn ANSWER;",
    "utils": []
  },
  {
    "id": "67",
    "title": "Maximum Path Sum II",
    "description": [
      null,
      "By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.",
      null,
      "    3",
      null,
      "   7 4",
      null,
      "  2 4 6",
      null,
      " 8 5 9 3",
      null,
      "That is, 3 + 7 + 4 + 9 = 23.",
      null
    ],
    "question": [
      "Find the maximum total from top to bottom in [triangle.txt @asset p067_triangle.txt], a 15K text file containing a triangle with one-hundred rows."
    ],
    "guide": [],
    "solution": "const rows = fs.readFileSync(path.join(__dirname, './p067_triangle.txt'))\n  .toString()\n  .split('\\n')\n  .map(row => row.split(' ').map(Number));\n// keeps track of the maximum score from the top to each number in the previous row\nlet previousRowScores = [];\nrows.forEach((row, rowIndex) => {\n  const currentRowScores = [];\n  row.forEach((number, position) => {\n    const isFirst = position === 0;\n    const isLast = position === row.length - 1;\n    if (rowIndex === 0) {\n      // first row: score is just the number\n      currentRowScores[0] = number;\n    } else if (isFirst) {\n      // first number of row: score is the score of the first element of previous row + this number\n      currentRowScores[0] = previousRowScores[0] + number;\n    } else if (isLast) {\n      // last number of row: same as above\n      currentRowScores[position] = previousRowScores[position - 1] + number;\n    } else {\n      const leftParent = previousRowScores[position - 1];\n      const rightParent = previousRowScores[position];\n      if (leftParent > rightParent) {\n        // if the number is in the middle of a row (not first nor last), simply check which 'parent' is larger\n        currentRowScores[position] = number + leftParent;\n      } else {\n        currentRowScores[position] = number + rightParent;\n      }\n    }\n  });\n  previousRowScores = currentRowScores;\n});\nreturn Math.max(...previousRowScores);",
    "utils": []
  },
  {
    "id": "68",
    "title": "Magic 5-gon ring",
    "description": [
      null,
      "Consider the following \"magic\" 3-gon ring, filled with the numbers 1 to 6, and each line adding to nine.",
      null,
      "@image p068_1.png",
      null,
      "Working clockwise, and starting from the group of three with the numerically lowest external node (4,3,2 in this example), each solution can be described uniquely. For example, the above solution can be described by the set: 4,3,2; 6,2,1; 5,1,3.",
      null,
      "It is possible to complete the ring with four different totals: 9, 10, 11, and 12. There are eight solutions in total.",
      null,
      " Total      Solution Set",
      null,
      " 9      4,2,3; 5,3,1; 6,1,2",
      null,
      " 9      4,3,2; 6,2,1; 5,1,3",
      null,
      " 10     2,5,3; 6,3,1; 4,1,5",
      null,
      " 11     1,4,6; 3,6,2; 5,2,4",
      null,
      " 11     1,6,4; 5,4,2; 3,2,6",
      null,
      " 12     1,5,6; 2,6,4; 3,4,5",
      null,
      " 12     1,6,5; 3,5,4; 2,4,6",
      null,
      "By concatenating each group it is possible to form 9-digit strings; the maximum string for a 3-gon ring is 432621513.",
      null,
      "@image p068_2.png",
      null
    ],
    "question": [
      "Using the numbers 1 to 10, and depending on arrangements, it is possible to form 16- and 17-digit strings. What is the maximum 16-digit string for a \"magic\" 5-gon ring?"
    ],
    "guide": [],
    "solution": "// The first step consists of generating the list of permutations of digits in the inner and outer ring\nconst DIGITS = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconst innerPermutations = [];\nconst outerPermutations = [];\nfor (let i1 = 1; i1 <= 5; i1++) {\n  for (let i2 = i1 + 1; i2 <= 6; i2++) {\n    for (let i3 = i2 + 1; i3 <= 7; i3++) {\n      for (let i4 = i3 + 1; i4 <= 8; i4++) {\n        for (let i5 = i4 + 1; i5 <= 9; i5++) {\n          const innerRing = [i1, i2, i3, i4, i5];\n          innerPermutations.push(innerRing);\n          outerPermutations.push(DIGITS.filter(x => !innerRing.includes(x)));\n        }\n      }\n    }\n  }\n}\nlet maxSolution = 0;\n// then, for each permutation, we check if it is a legitimate solution with the helper function below\nfor (let i = 0; i < innerPermutations.length; i++) {\n  const leadingDigit = innerPermutations[i][0];\n  const basePermutation = innerPermutations[i].slice(1);\n  const outerDigits = outerPermutations[i];\n  for (let j = 1; j <= 24; j++) {\n    const currentPermutation = utils.getLexicalPermutation(basePermutation, j).map(Number);\n    currentPermutation.unshift(leadingDigit);\n    const commonSum = findSolution(currentPermutation, outerDigits);\n    if (commonSum) {\n      // if a soution is found, find maximal string corresponding to that solution\n      // first, find the index of the inner ring adjacent to the smallest outer digit\n      const innerStartIndex = currentPermutation.findIndex((permDigit, permIndex) => {\n        const currentInnerDigit = permDigit;\n        const nextInnerDigit = currentPermutation[(permIndex + 1) % 5];\n        return currentInnerDigit + nextInnerDigit === commonSum - outerDigits[0];\n      });\n      // then we go around the inner ring (clockwise) and preppend the corresponding outer digit\n      let solutionString = '';\n      for (let k = 0; k <= 4; k++) {\n        const currentInnerRingDigit = currentPermutation[(innerStartIndex + k) % 5];\n        const nextInnerRingDigit = currentPermutation[(innerStartIndex + k + 1) % 5];\n        const currentSum = currentInnerRingDigit + nextInnerRingDigit;\n        const correspondingOuterDigit = commonSum - currentSum;\n        solutionString += `${correspondingOuterDigit}${currentInnerRingDigit}${nextInnerRingDigit}`;\n      }\n      const solution = +solutionString;\n      if (solution > maxSolution) {\n        maxSolution = solution;\n      }\n    }\n  }\n}\nreturn maxSolution;\n// given a sequence of inner ring, return the common sum if a solution exists, false otherwise\nfunction findSolution(inner, outer) {\n  // we go around the inner ring and extract all the sums of adjacent digits\n  const sumsToTest = [...inner].reduce(\n    (acc, curr, idx, arr) => {\n      const nextIndex = idx === 4 ? 0 : idx + 1;\n      const sum = curr + inner[nextIndex];\n      if (acc[sum]) {\n        // if there are duplicate sums in the inner ring,\n        // a solution cannot exist as the outer ring numbers are all disinct\n        arr.splice(1);\n        return null;\n      }\n      acc[sum] = true;\n      return acc;\n    },\n    {},\n  );\n  if (!sumsToTest) { // duplicate sums detected\n    return false;\n  }\n  // the digits of the outer ring are sorted from smallest to largest by design\n  // therefore we sort the sums of the inner ring from largest to smallest\n  const partialSums = Object.keys(sumsToTest).map(Number).sort((a, b) => b - a);\n  const SOLUTION_SUM = partialSums[4] + 10; // smallest inner sum + 10\n  // we check if adding the corresponding index of the outer ring will result in the solution sum\n  for (let i = 0; i <= 3; i++) {\n    if (partialSums[i] + outer[i] !== SOLUTION_SUM) {\n      return false;\n    }\n  }\n  return SOLUTION_SUM;\n}",
    "utils": [
      "combinatorics/getLexicalPermutation"
    ]
  },
  {
    "id": "69",
    "title": "Totient Maximum",
    "description": [
      null,
      "Euler's Totient function, φ(n) [sometimes called the phi function], is used to determine the number of numbers less than n which are relatively prime to n.",
      null,
      "For example, as 1, 2, 4, 5, 7, and 8, are all less than nine and relatively prime to nine, φ(9)=6.",
      null,
      "For n ≤ 10, n = 6 produces a maximum n/φ(n).",
      null
    ],
    "question": [
      "Find the value of n ≤ 1,000,000 for which n/φ(n) is a maximum."
    ],
    "guide": [],
    "solution": "// we use the Euler's formula for the totient function for all n <= 1 million\n// we start with n, and for each prime p divisible by n, we multiply by ((p - 1) / p)\n// the intuition is as follows:\n// let's take the number 60, which has prime divisors 2, 3, 5\n// 1. we first extract the numbers NOT divisible by 2: p = 2 => 60 * 1/2 = 30;\n// 2. of those numbers, we extract numbers NOT divisible by 3: p = 3 => 30 * 2/3 = 20;\n// 3. finally, we extract from the previous result numbers not divisible by 5: 20 * 4/5 = 16;\n// indeed, the numbers (<60) relatively prime to 60\n// are the numbers which are not divisible by 2, 3, or 5, and there are 16 of them\n// we also use a heuristic to cut down a majority of numbers to test:\n// since we want to maximize n/phi(n), we need to find a number which is highly divisible\n// we do that by MAXIMIZING the number of PRIME divisors, and by MINIMIZING the number itself\n// therefore, we search incrementally with products of prime numbers from smallest to largest,\n// and we stop if the product exceeds 1 million\n// ie. 2, 2*3, 2*3*5, 2*3*5*7, etc.\nconst PRIMES_TABLE = utils.generatePrimesTable(100); // product of primes < 100 is guaranteed to exceed 1 million\nconst PRIMES_ARR = Object.keys(PRIMES_TABLE).map(Number);\nlet maxTotient = 0;\nlet maxTotientNumber = 0;\nfor (let i = 0; i < PRIMES_ARR.length; i++) {\n  const factors = PRIMES_ARR.slice(0, i + 1);\n  const product = factors.reduce((a, c) => a * c, 1);\n  if (product > 1000000) {\n    break;\n  }\n  const reverseTotient = factors.reduce((a, c) => a * c / (c - 1), 1); // shortcut to calculate n/phi(n)\n  if (reverseTotient > maxTotient) {\n    maxTotient = reverseTotient;\n    maxTotientNumber = product;\n  }\n}\nreturn maxTotientNumber;",
    "utils": [
      "primes/generatePrimesTable"
    ]
  },
  {
    "id": "70",
    "title": "Totient permutation",
    "description": [
      "Euler's Totient function, φ(n), is used to determine the number of positive numbers less than or equal to n which are relatively prime to n.",
      null,
      "For example, as 1, 2, 4, 5, 7, and 8, are all less than nine and relatively prime to nine, φ(9)=6.",
      null,
      "The number 1 is considered to be relatively prime to every positive number, so φ(1)=1.",
      null,
      "Interestingly, φ(87109)=79180, and it can be seen that 87109 is a permutation of 79180.",
      null
    ],
    "question": [
      "Find the value of n, 1 < n < 107, for which φ(n) is a permutation of n and the ratio n/φ(n) produces a minimum."
    ],
    "guide": [],
    "solution": "// to minimize n/phi(n), we need to maximize phi(n), ie. we need to find n which is not highly divisible\n// n cannot be prime as phi(n) = n - 1, and n and n - 1 cannot have the same digits\n// NOTE:\n// let p1, p2, ... pm denote the prime factors of n\n// therefore n/phi(n) := p1/(p1-1) * p2/(p2-1) * p3/(p3-1) * ... * pm/(pm-1) (1)\n// in order to minimize the equation above, we need to minimize the number of terms (as each term > 1)\n// and also minimize each term by maximizing the value of the prime factors\nconst PRIMES_TABLE = utils.generatePrimesTable(10000);\n// this number is chosen with the confidence that the minimal ratio < 1.001\nconst PRIMES_ARR = Object.keys(PRIMES_TABLE).reverse().map(Number);\nlet minimalTotientRatio = 1.001; // arbitrarily large number\nlet minimalTotientNumber = 0;\nfor (let i = 0; i < PRIMES_ARR.length - 1; i++) {\n  const p1 = PRIMES_ARR[i];\n  const phi1 = p1 / (p1 - 1);\n  if (phi1 > minimalTotientRatio) {\n    break;\n  }\n  for (let j = PRIMES_ARR.findIndex(x => x < 10000000 / p1); j < PRIMES_ARR.length; j++) {\n    const p2 = PRIMES_ARR[j];\n    const phi2 = p2 / (p2 - 1);\n    if (phi2 > minimalTotientRatio) {\n      break;\n    }\n    const result = p1 * p2;\n    const phi = (p1 - 1) * (p2 - 1);\n    if (utils.haveSameDigits([result, phi])) {\n      const totientRatio = result / phi;\n      if (totientRatio < minimalTotientRatio) {\n        minimalTotientRatio = totientRatio;\n        minimalTotientNumber = result;\n      }\n    }\n  }\n}\nreturn minimalTotientNumber;",
    "utils": [
      "primes/generatePrimesTable",
      "lang/haveSameDigits"
    ]
  },
  {
    "id": "71",
    "title": "Ordered fractions",
    "description": [
      null,
      "Consider the fraction, n/d, where n and d are positive integers.",
      null,
      "If n<d and HCF(n,d)=1, it is called a reduced proper fraction.",
      null,
      "If we list the set of reduced proper fractions for d ≤ 8 in ascending order of size, we get:",
      null,
      "1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8",
      null,
      "It can be seen that 2/5 is the fraction immediately to the left of 3/7.",
      null
    ],
    "question": [
      "By listing the set of reduced proper fractions for d ≤ 1,000,000 in ascending order, find the numerator of the fraction immediately to the left of 3/7."
    ],
    "guide": [],
    "solution": "// for each d <= 1,000,000, we just need to find maximal integer c such that c/d is smaller than 3/7\n// we accomplish this by multiplying d by 3/7, and taking the floor of the result\n// if the result is divisible by the floor of the result, we can skip to the next d\n// if not, the difference between the result and the floor of the result is indicative of how close the result is to 3/7\n// ie we want to minimize (d * 3/7 - floor(d * 3/7))/d\nconst FRACTION = 3 / 7;\nlet smallestDiff = 1;\nconst answer = {};\nfor (let d = 1; d <= 1000000; d++) {\n  if (d % 7 === 0) {\n    continue;\n  }\n  const res = d * FRACTION;\n  const floor = Math.floor(res);\n  const diff = (res - floor) / d;\n  if (diff < smallestDiff) {\n    smallestDiff = diff;\n    answer.numerator = floor;\n    answer.denominator = d;\n  }\n}\nreturn answer.numerator;",
    "utils": []
  },
  {
    "id": "72",
    "title": "Counting fractions",
    "description": [
      null,
      "Consider the fraction, n/d, where n and d are positive integers.",
      null,
      "If n<d and HCF(n,d)=1, it is called a reduced proper fraction.",
      null,
      "If we list the set of reduced proper fractions for d ≤ 8 in ascending order of size, we get:",
      null,
      "1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8",
      null,
      "It can be seen that there are 21 elements in this set.",
      null
    ],
    "question": [
      "How many elements would be contained in the set of reduced proper fractions for d ≤ 1,000,000?"
    ],
    "guide": [],
    "solution": "// we are basically calculating phi(2) + ... + phi(1,000,000)\n// note that phi(n) = (f1 - 1) / f1 * (f2 - 1) / f2 + ... + (fm - 1) / fm\n// where f1, f2, ..., fm are the prime factors of n\n// we start by generating all prime numbers below 1000000\n// for each generated prime p, we sieve all multiples of that prime p * 2, p * 3, etc.\n// by multiplying each number by (p - 1) / p\n// eventually each integer below 1000000 will be sieved once by each of its prime factors\nconst target = 1000000;\nconst PRIME_TABLE = utils.generatePrimesTable(target);\nconst INTEGER_TABLE = { ...PRIME_TABLE };\nlet answer = 0;\nfor (let i = 2; i <= target; i++) {\n  if (PRIME_TABLE[i]) {\n    answer += i - 1;\n    for (let j = i; i * j <= target; j++) {\n      if (INTEGER_TABLE[i * j]) {\n        INTEGER_TABLE[i * j] = INTEGER_TABLE[i * j] * (i - 1) / i;\n      } else {\n        INTEGER_TABLE[i * j] = j * (i - 1);\n      }\n    }\n  } else {\n    answer += INTEGER_TABLE[i];\n  }\n}\nreturn answer;",
    "utils": [
      "primes/generatePrimesTable"
    ]
  },
  {
    "id": "73",
    "title": "Counting fractions in a range",
    "description": [
      null,
      "Consider the fraction, n/d, where n and d are positive integers.",
      null,
      "If n<d and HCF(n,d)=1, it is called a reduced proper fraction.",
      null,
      "If we list the set of reduced proper fractions for d ≤ 8 in ascending order of size, we get:",
      null,
      "1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8",
      null,
      "It can be seen that there are 3 fractions between 1/3 and 1/2.",
      null
    ],
    "question": [
      "How many fractions lie between 1/3 and 1/2 in the sorted set of reduced proper fractions for d ≤ 12,000?"
    ],
    "guide": [],
    "solution": "let answer = 0;\nfor (let d = 4; d <= 12000; d++) {\n  const lower = d / 3;\n  const upper = d / 2;\n  const lbNumerator = Number.isInteger(lower) ? lower + 1 : Math.ceil(lower); // proper lower bound\n  const ubNumerator = Number.isInteger(upper) ? upper - 1 : Math.floor(upper); // proper upper bound\n  if (lbNumerator > ubNumerator) {\n    continue;\n  }\n  for (let n = lbNumerator; n <= ubNumerator; n++) {\n    if (utils.gcd(n, d) === 1) {\n      answer++;\n    }\n  }\n}\nreturn answer;",
    "utils": [
      "arithmetic/gcd"
    ]
  },
  {
    "id": "74",
    "title": "Digit factorial chains",
    "description": [
      null,
      "The number 145 is well known for the property that the sum of the factorial of its digits is equal to 145:",
      null,
      "1! + 4! + 5! = 1 + 24 + 120 = 145",
      null,
      "Perhaps less well known is 169, in that it produces the longest chain of numbers that link back to 169; it turns out that there are only three such loops that exist:",
      null,
      "169 → 363601 → 1454 → 169",
      null,
      "871 → 45361 → 871",
      null,
      "872 → 45362 → 872",
      null,
      "It is not difficult to prove that EVERY starting number will eventually get stuck in a loop. For example,",
      null,
      "69 → 363600 → 1454 → 169 → 363601 (→ 1454)",
      null,
      "78 → 45360 → 871 → 45361 (→ 871)",
      null,
      "540 → 145 (→ 145)",
      null,
      "Starting with 69 produces a chain of five non-repeating terms, but the longest non-repeating chain with a starting number below one million is sixty terms.",
      null
    ],
    "question": [
      "How many chains, with a starting number below one million, contain exactly sixty non-repeating terms?"
    ],
    "guide": [],
    "solution": "const FACTS = {\n  0: 1,\n  1: 1,\n  2: 2,\n  3: 6,\n  4: 24,\n  5: 120,\n  6: 720,\n  7: 5040,\n  8: 40320,\n  9: 362880,\n};\n// giant memoized table of all the numbers and their chain length\nconst MEM = {};\n// NOTE: it is true that different numbers with the same digits will have the same chain length.\n// However, it will not reduce the running time by much, as all the numbers with the same digit\n// will find their memoized entry within one depth of the recurrence.\n// Furthermore, the time saved will be recompensed by the sorting of the digits\n// (tested: on average, the sorting method is slightly slower)\n// However, this is a good method if we want to save space\nconst sumFactDigits = n => n.toString().split('').reduce((a, c) => a + FACTS[c], 0);\nfunction computePathLength(n, accMem = {}, chainLength = 0) {\n  if (MEM[n]) {\n    Object.keys(accMem).forEach((chainElem) => {\n      MEM[chainElem] = MEM[n] + chainLength - accMem[chainElem];\n    });\n    return chainLength + MEM[n];\n  }\n  if (accMem[n]) {\n    const recurrencePeriod = chainLength - accMem[n];\n    Object.keys(accMem).forEach((chainElem) => {\n      if (accMem[chainElem] < accMem[n]) {\n        MEM[chainElem] = chainLength - accMem[chainElem];\n      } else {\n        MEM[chainElem] = recurrencePeriod;\n      }\n    });\n    return chainLength;\n  }\n  const next = sumFactDigits(n);\n  if (next === n) {\n    return 1;\n  }\n  return computePathLength(next, { ...accMem, [n]: chainLength }, chainLength + 1);\n}\nlet res = 0;\nfor (let n = 1; n < 1000000; n++) {\n  const chainLength = computePathLength(n);\n  if (chainLength === 60) {\n    res++;\n  }\n}\nreturn res;",
    "utils": []
  },
  {
    "id": "75",
    "title": "Singular integer right triangles",
    "description": [
      null,
      "It turns out that 12 cm is the smallest length of wire that can be bent to form an integer sided right angle triangle in exactly one way, but there are many more examples.",
      null,
      "12 cm: (3,4,5)",
      null,
      "24 cm: (6,8,10)",
      null,
      "30 cm: (5,12,13)",
      null,
      "36 cm: (9,12,15)",
      null,
      "40 cm: (8,15,17)",
      null,
      "48 cm: (12,16,20)",
      null,
      "In contrast, some lengths of wire, like 20 cm, cannot be bent to form an integer sided right angle triangle, and other lengths allow more than one solution to be found; for example, using 120 cm it is possible to form exactly three different integer sided right angle triangles.",
      null,
      "120 cm: (30,40,50), (20,48,52), (24,45,51)",
      null
    ],
    "question": [
      "Given that L is the length of the wire, for how many values of L ≤ 1,500,000 can exactly one integer sided right angle triangle be formed?"
    ],
    "guide": [],
    "solution": "// keys are the length, value are how many time it has been sieved\nconst TRIANGLE_LENGTH_TABLE = {};\nconst target = 1500000;\n// we first generate the table of primitive pythagorean triplets\nfor (let n = 1; n < 612; n++) {\n  for (let m = n + 1; m <= target; m++) {\n    const perimeter = 2 * m * (n + m);\n    if (perimeter > target) {\n      break;\n    }\n    const isCoprime = utils.gcd(m, n) === 1;\n    const isPrimitive = isCoprime && (utils.isEven(m) || utils.isEven(n));\n    if (isPrimitive) {\n      TRIANGLE_LENGTH_TABLE[perimeter] = 1;\n    }\n  }\n}\n// for each generated triplet, we sieve all the multiples of that perimeter\nconst primitivePerimeters = Object.keys(TRIANGLE_LENGTH_TABLE).map(Number);\nfor (let i = 0; i < primitivePerimeters.length; i++) {\n  const primitive = primitivePerimeters[i];\n  for (let k = 2; primitive * k <= target; k++) {\n    TRIANGLE_LENGTH_TABLE[primitive * k] = TRIANGLE_LENGTH_TABLE[primitive * k]\n      ? TRIANGLE_LENGTH_TABLE[primitive * k] + 1\n      : 1;\n  }\n}\n// at the end, for each perimeter, if it has value 1 (ie. it has been sieved exactly once), then it fits the condition\nreturn Object.keys(TRIANGLE_LENGTH_TABLE).filter(p => TRIANGLE_LENGTH_TABLE[p] === 1).length;",
    "utils": [
      "arithmetic/gcd",
      "arithmetic/isEven"
    ]
  },
  {
    "id": "76",
    "title": "Counting summations",
    "description": [
      null,
      "It is possible to write five as a sum in exactly six different ways:",
      null,
      "4 + 1",
      null,
      "3 + 2",
      null,
      "3 + 1 + 1",
      null,
      "2 + 2 + 1",
      null,
      "2 + 1 + 1 + 1",
      null,
      "1 + 1 + 1 + 1 + 1",
      null
    ],
    "question": [
      "How many different ways can one hundred be written as a sum of at least two positive integers?"
    ],
    "guide": [],
    "solution": "// this is similar to the change making problem\n// we have 100 coins of value 1, 2 ... 100\n// the question is how to make 100 with those coins\nconst MEM = {};\nfor (let i = 1; i <= 100; i++) {\n  // we do not have to consider j < i as there would be no way of making j with a coin i\n  // from this point, MEM[n] denotes the number of ways of making n using coins up to i\n  for (let j = i; j <= 100; j++) {\n    // the number of ways to make amount j is equal to the sum of\n    // 1. the number of ways of making j without using i,\n    // which is the number of ways of making change j using coins 1, ..., i - 1\n    // which is equal to MEM[j] of the previous iteration\n    // 2. the number of ways of making j using i,\n    // which is the number of ways of making j - i using 1, 2, ..., i\n    // if MEM[j - i] is undefined, it means  j = i, and the answer is 1\n    MEM[j] = (MEM[j] || 0) + (MEM[j - i] || 1);\n  }\n}\nreturn MEM[100] - 1;",
    "utils": []
  },
  {
    "id": "77",
    "title": "Prime summations",
    "description": [
      "It is possible to write ten as the sum of primes in exactly five different ways:",
      null,
      "7 + 3",
      null,
      "5 + 5",
      null,
      "5 + 3 + 2",
      null,
      "3 + 3 + 2 + 2",
      null,
      "2 + 2 + 2 + 2 + 2",
      null
    ],
    "question": [
      "What is the first value which can be written as the sum of primes in over five thousand different ways?"
    ],
    "guide": [],
    "solution": "// from problem above, i = 30 was sufficient to generate > 5000 partitions\n// in order to minimize space and time, we will use 46 primes as an upper bound, and increase if necessary\nconst PRIMES = Object.keys(utils.generatePrimesTable(200)).map(Number);\nlet answer = 0;\nlet I = 2;\n// each key is of the form a|b, and the value is the number of partitions of a using primes smaller or equal to b\nconst MEM = { };\nwhile (!answer) {\n  for (let i = 2; i <= I; i++) {\n    for (let j = 0; j < PRIMES.length; j++) {\n      const prime = PRIMES[j];\n      if (prime > i) {\n        MEM[`${i}|${prime}`] = MEM[`${i}|${PRIMES[j - 1]}`];\n        continue;\n      }\n      if (j === 0) {\n        MEM[`${i}|${prime}`] = utils.isEven(i) ? 1 : 0;\n        continue;\n      }\n      const usingPrime = MEM[`${i - prime}|${prime}`] || (i === prime ? 1 : 0);\n      const notUsing = MEM[`${i}|${PRIMES[j - 1]}`] || 0;\n      if (notUsing + usingPrime > 5000) {\n        MEM[`${i}|${prime}`] = notUsing + usingPrime;\n        answer = i;\n        break;\n      }\n      MEM[`${i}|${prime}`] = notUsing + usingPrime;\n    }\n    if (answer) {\n      break;\n    }\n  }\n  I++;\n}\nreturn answer;",
    "utils": [
      "primes/generatePrimesTable",
      "arithmetic/isEven"
    ]
  },
  {
    "id": "78",
    "title": "Coin Partitions",
    "description": [
      null,
      "Let p(n) represent the number of different ways in which n coins can be separated into piles.",
      null,
      "For example, five coins can be separated into piles in exactly seven different ways, so p(5)=7.",
      null
    ],
    "question": [
      "Find the least value of n for which p(n) is divisible by one million."
    ],
    "guide": [],
    "solution": "// using the pentagonal number theorem, we can use the following recurrence relationship\n// let p(n) denote the number of partitions of n\n// p(n) = p(n - 1) + p(n - 2) - p(n - 5) - p(n - 7) + p(n - 12) + p(n - 17) - ...\n// the subtracted indices are defined as the generalized pentagonal numbers starting at index 1\nlet answer = 0;\nlet n = 3;\n// memoized partition list MEM[i] = p(i)\nconst MEM = [1, 1, 2];\nwhile (!answer) {\n  let i = 1;\n  let term = penta(i);\n  let currentPartition = 0;\n  // sum all terms p(n-1), p(n-2), p(n-5), etc.\n  while (term <= n) {\n    const sign = (i - 1) % 4 > 1 ? -1 : 1;\n    currentPartition += sign * MEM[n - term];\n    i++;\n    term = penta(i);\n  }\n  currentPartition %= 1000000;\n  if (currentPartition === 0) {\n    answer = n;\n    break;\n  }\n  MEM[n] = currentPartition;\n  n++;\n}\nreturn answer;\n// generalized pentagonal number generator\nfunction penta(k) {\n  if (k & 1) {\n    const m = (k + 1) / 2;\n    return m * (3 * m - 1) / 2;\n  }\n  const m = k / 2;\n  return m * (3 * m + 1) / 2;\n}",
    "utils": []
  },
  {
    "id": "79",
    "title": "Passcode derivation",
    "description": [
      null,
      "A common security method used for online banking is to ask the user for three random characters from a passcode. For example, if the passcode was 531278, they may ask for the 2nd, 3rd, and 5th characters; the expected reply would be: 317.",
      null,
      "The text file, [keylog.txt @asset p079_keylog.txt], contains fifty successful login attempts.",
      null
    ],
    "question": [
      "Given that the three characters are always asked for in order, analyse the file so as to determine the shortest possible secret passcode of unknown length."
    ],
    "guide": [],
    "solution": "const passcodes = fs.readFileSync(path.join(__dirname, './p079_keylog.txt'))\n  .toString()\n  .split('\\n')\n  .filter(Boolean);\n// we can remove repeated passcodes\nconst uniqAttempts = Array.from(new Set(passcodes));\n// if we spend a minute to look at the attempts, we can see that the passcode contains no repeating digits\n// therefore the solution becomes very straightforward\n// we find the first digit of the passcode by finding the digit that is not preceded by any other digits\n// that digit can always be found, because if not, it means that there must be repeating digits\n// repeat for second, third, etc.\n// since there are no repeats, and our login attempts do not contain a 4 or 5\n// our passcode must have length 8\nconst target = 8;\nlet digitsFound = 0;\nlet answer = '';\n// the list of attempts is updated every time we find a digit, by removing the found digit from it\nlet remainingAttempts = [...uniqAttempts];\n// the list of digits yet to be pushed into our answer is updated every time we find an answer\nlet remainingDigits = [0, 1, 2, 3, 6, 7, 8, 9];\nwhile (digitsFound < target) {\n  let foundDigit;\n  // the list of remaining possible digits for a given step is updated every time we find, in each attempt,\n  // a digit which is not in the first position\n  let currentPossibilities = [...remainingDigits];\n  for (let i = 0; i < remainingAttempts.length; i++) {\n    // split each attempt into first and non-first digits (rem array)\n    const [first, ...nonFirst] = remainingAttempts[i].split('');\n    // for the possible digits remaining, keep the ones that are not included in the list of non-first digits\n    currentPossibilities = currentPossibilities.filter(x => !nonFirst.includes(`${x}`));\n    // if there is only one possible digit left, then it is the answer\n    if (currentPossibilities.length === 1) {\n      foundDigit = currentPossibilities[0];\n      // push digit into answer string\n      answer += foundDigit;\n      break;\n    }\n  }\n  // remove the found digit from the list of remaining digits\n  remainingDigits = remainingDigits.filter(x => x !== foundDigit);\n  // reset the list of remaining possible digits used for traversal through attempts\n  currentPossibilities = [...remainingDigits];\n  // remove every occurrence of the found digit from the list of attempts\n  remainingAttempts = remainingAttempts.map(\n    attempt => attempt.split('').filter(\n      digit => +digit !== foundDigit,\n    ).join(''),\n  ).filter(x => x !== '');\n  digitsFound++;\n}\nreturn answer;",
    "utils": []
  },
  {
    "id": "80",
    "title": "Square root digital expansion",
    "description": [
      null,
      "It is well known that if the square root of a natural number is not an integer, then it is irrational.",
      null,
      "The decimal expansion of such square roots is infinite without any repeating pattern at all.",
      null,
      "The square root of two is 1.41421356237309504880..., and the digital sum of the first one hundred decimal digits is 475.",
      null
    ],
    "question": [
      "For the first one hundred natural numbers, find the total of the digital sums of the first one hundred decimal digits for all the irrational square roots."
    ],
    "guide": [],
    "solution": "let ANSWER = 0;\n// this is very similar to problem 66\n// instead of iterating until we find a solution to an equation\n// we keep iterating until we find a number for which the 100 first decimal is 'stable'\nfor (let D = 2; D <= 100; D++) {\n  // find leading digits\n  const sqrt = Math.sqrt(D);\n  const floor = Math.floor(sqrt);\n  if (sqrt === floor) {\n    continue;\n  }\n  let repetitionFound = false; // if a repetition has been found, we can exit the loop (explained below)\n  // Step 1: Sequence of leading digits\n  const leadingDigits = [];\n  let isolatedInteger = floor; // leading digit of our current iteration\n  let normalizedDenominator; // the denominator as a result of normalization\n  // the normalized and reduced denominator (by the initial numerator) of the previous iteration\n  let initialNumerator = 1;\n  // the offset found in the denominator as a result of isolating the leading integer from the previous iteration\n  let denominatorOffset = floor;\n  while (!repetitionFound) {\n    // normalize\n    normalizedDenominator = D - (denominatorOffset ** 2);\n    // isolate\n    isolatedInteger = Math.floor(initialNumerator * (floor + denominatorOffset) / normalizedDenominator);\n    leadingDigits.push(isolatedInteger);\n    if (normalizedDenominator === initialNumerator) {\n      // the initialNumerator always starts with 1\n      // if the above two variables are equal, then the next initialNumerator will be 1,\n      // which will cause the cycle to repeat\n      repetitionFound = true;\n      break;\n    }\n    // update for next iteration\n    initialNumerator = normalizedDenominator / initialNumerator;\n    denominatorOffset = Math.abs(denominatorOffset - initialNumerator * isolatedInteger);\n  }\n  // Step 2: search for solution\n  // solution verifier\n  // verify if there is a variation in the 101st decimal between the 2 fractions\n  // (ie. if the first 101 decimals are equal)\n  // we accomplish this by multiplying each numerator by 10^101 before dividing by the denominator\n  // this will truncate the 102nd digit (and everything after)\n  // if the 101th digit is the same for both fractions,\n  // we then just need to round the 100th digit to get our answer\n  const getSum100Digits = (num1, denom1, num2, denom2) => {\n    const shift = BigInt(10) ** BigInt(101);\n    const prevDigits = num1 * shift / denom1;\n    const currDigits = num2 * shift / denom2;\n    if (prevDigits === currDigits) { // stabilized, return the sum of the 100 digits\n      const digits = String(currDigits).slice(0, 100).split('');\n      return digits.map(Number).reduce((a, c) => a + c, 0);\n    }\n    return false;\n  };\n  // returns nth leading integer in the continued fraction expansion of sqrt(D)\n  const getNthLeadingInteger = n => leadingDigits[(n - 1) % leadingDigits.length];\n  // initial values\n  let target = 1;\n  let numerator = BigInt(1);\n  let denominator = BigInt(getNthLeadingInteger(target));\n  let previousNumerator;\n  let previousDenominator;\n  let stabilized = false;\n  // loop while a solution is not found\n  while (!stabilized) {\n    numerator = BigInt(1);\n    denominator = BigInt(getNthLeadingInteger(target));\n    // find the convergent at the `target` index by using backtracking\n    for (let i = target - 1; i >= 1; i--) {\n      const nextLeadingInteger = BigInt(getNthLeadingInteger(i));\n      [numerator, denominator] = [denominator, nextLeadingInteger * denominator + numerator]\n    }\n    numerator += (denominator * BigInt(floor));\n    if (target > 1) {\n      const solution = getSum100Digits(previousNumerator, previousDenominator, numerator, denominator);\n      if (solution) {\n        ANSWER += solution;\n        stabilized = true;\n        break;\n      }\n    }\n    previousNumerator = numerator;\n    previousDenominator = denominator;\n    target++;\n  }\n}\nreturn ANSWER;",
    "utils": []
  },
  {
    "id": "81",
    "title": "Path sum: two ways",
    "description": [
      null,
      "In the 5 by 5 matrix below, the minimal path sum from the top left to the bottom right, by only moving to the right and down, is indicated in bold and is equal to 2427.",
      null,
      "@html <b>131</b> <b>673</b> 234 103 018",
      null,
      "@html 201 <b>096</b> <b>342</b> 965 150",
      null,
      "@html 630 803 <b>746</b> <b>422</b> 111",
      null,
      "@html 537 699 497 <b>121</b> 956",
      null,
      "@html 805 732 524 <b>037</b> <b>331</b>",
      null
    ],
    "question": [
      "Find the minimal path sum, in [matrix.txt @asset p081_matrix.txt], a text file containing a 80 by 80 matrix, from the top left to the bottom right by only moving right and down."
    ],
    "guide": [],
    "solution": "// we use a memoized table where the entry [i,j] is the optimal path from 0,0 to i,j\n// MEM[i, j] = min(MEM[i - 1, j], MEM[i, j - 1]);\nconst MEM = utils.initTable(80, 80);\nconst raw = fs.readFileSync(path.join(__dirname, './p081_matrix.txt')).toString();\nconst MATRIX = raw.split('\\n').slice(0, 80).map(row => row.split(',').map(Number));\nMEM[0] = MATRIX[0].map((_, i) => utils.sumArray(MATRIX[0].slice(0, i + 1)));\nfor (let row = 1; row < 80; row++) {\n  MEM[row][0] = MATRIX[0][0] + utils.sumArray(MATRIX.map(r => r[0]).slice(1, row + 1));\n  for (let col = 1; col < 80; col++) {\n    MEM[row][col] = MATRIX[row][col] + Math.min(MEM[row - 1][col], MEM[row][col - 1]);\n  }\n}\nreturn MEM[79][79];",
    "utils": [
      "common/initTable",
      "common/sumArray"
    ]
  },
  {
    "id": "82",
    "title": "Path sum: three ways",
    "description": [
      null,
      "The minimal path sum in the 5 by 5 matrix below, by starting in any cell in the left column and finishing in any cell in the right column, and only moving up, down, and right, is indicated in bold; the sum is equal to 994.",
      null,
      "@html 131 673 <b>234</b> <b>103</b> <b>018</b>",
      null,
      "@html <b>201</b> <b>096</b> <b>342</b> 965 150",
      null,
      "@html 630 803 746 422 111",
      null,
      "@html 537 699 497 121 956",
      null,
      "@html 805 732 524 037 331",
      null
    ],
    "question": [
      "Find the minimal path sum, in [matrix.txt @asset p081_matrix.txt], a 31K text file containing a 80 by 80 matrix, from the left column to the right column."
    ],
    "guide": [],
    "solution": "// we iterate column by column, at each step we memorize the optimal sum from the leftmost column to\n// each element of the current column\nconst raw = fs.readFileSync(path.join(__dirname, './p081_matrix.txt')).toString();\n// parse file into a 2D array\nconst MATRIX = raw.split('\\n').slice(0, 80).map(row => row.split(',').map(Number));\n// initiate MEM to be the first column\nlet MEM = MATRIX.map(x => x[0]);\n// at each iteration, MEM[k] remembers the optimal sum from the leftmost column (any starting row)\n// to the kth element of the current column\nfor (let col = 1; col < MATRIX.length; col++) {\n  // extract current column\n  const column = MATRIX.map(x => x[col]);\n  // keep the data for the next column separate, as we still need the data of current column\n  const nextMEM = [];\n  // find optimal path for each element of column\n  for (let dest = 0; dest < MATRIX.length; dest++) {\n    // keep track of optimal path\n    let optimalSum = Infinity;\n    // calculate all paths from each element of previous column\n    let pathSum = 0;\n    for (let origin = 0; origin < MATRIX.length; origin++) {\n      // calculate all paths from a specific origin row to a specific destination row\n      // paths can only be: 1. go right and up, or 2. go right and down\n      // if the memorized value at `origin` index is already exceeding the optimal sum, we can ignore it\n      if (MEM[origin] > optimalSum) {\n        continue;\n      }\n      if (origin === dest) {\n        // if origin row is the same as destination row, the optimal path is just move right\n        pathSum = MEM[origin] + column[dest];\n      } else if (origin > dest) {\n        // origin is 'lower' (high index == low height) than dest in matrix, move right then up\n        pathSum = MEM[origin] + utils.sumArray(column.slice(dest, origin + 1));\n      } else {\n        // origin is 'higher' than dest in matrix, move right then down\n        pathSum = MEM[origin] + utils.sumArray(column.slice(origin, dest + 1));\n      }\n      if (pathSum < optimalSum) {\n        optimalSum = pathSum;\n      }\n    }\n    // memoize optimal sum\n    nextMEM[dest] = optimalSum;\n  }\n  // prepare for next column\n  MEM = nextMEM;\n}\n// at the last column, MEM contains all the OPTIMAL paths from the first column to each element of the last column\n// the minimal element will then be the optimal path from left to right\nreturn Math.min(...MEM);",
    "utils": [
      "common/sumArray"
    ]
  },
  {
    "id": "83",
    "title": "Path sum: four ways",
    "description": [
      null,
      "In the 5 by 5 matrix below, the minimal path sum from the top left to the bottom right, by moving left, right, up, and down, is indicated in bold and is equal to 2297.",
      null,
      "@html <b>131</b> 673 <b>234</b> <b>103</b> <b>018</b>",
      null,
      "@html <b>201</b> <b>096</b> <b>342</b> 965 <b>150</b>",
      null,
      "@html 630 803 746 <b>422</b> <b>111</b>",
      null,
      "@html 537 699 497 <b>121</b> 956",
      null,
      "@html 805 732 524 <b>037</b> <b>331</b>",
      null
    ],
    "question": [
      "Find the minimal path sum, in [matrix.txt @asset p081_matrix.txt], a 31K text file containing a 80 by 80 matrix, from the top left to the bottom right by moving left, right, up, and down."
    ],
    "guide": [],
    "solution": "const raw = fs.readFileSync(path.join(__dirname, './p083_matrix.txt')).toString();\nconst MATRIX = raw.split('\\n').slice(0, 80).map(row => row.split(',').map(Number));\nconst size = MATRIX.length;\n// we use the dijkstra algorithm to find the shortest path from top left to bottom right\nconst nodes = [];\nlet originalIndex = 0;\nfor (let i = 0; i < size; i++) {\n  for (let j = 0; j < size; j++) {\n    nodes.push({\n      row: i,\n      col: j,\n      dist: Infinity,\n      originalIndex: originalIndex++, // node identifier\n      value: MATRIX[i][j],\n    });\n  }\n}\n// init first node\nnodes[0].dist = nodes[0].value;\n// mark the first node\nlet markedNodes = [nodes[0]];\n// init the list of unvisited nodes\nlet unvisitedNodes = nodes.slice(1);\n// while there are unvisited nodes, find the nearest unvisited node and mark the distances of its neighbors\nwhile (unvisitedNodes.length) {\n  // find next node to visit\n  const currentNode = markedNodes.reduce(\n    (acc, curr) => (curr.dist < acc.dist ? curr : acc),\n    { dist: Infinity },\n  );\n  // remove this node from the list of unvisited nodes\n  unvisitedNodes = unvisitedNodes.filter(unvisited => unvisited.originalIndex !== currentNode.originalIndex);\n  // remove this node from the list of marked notes\n  markedNodes = markedNodes.filter(marked => marked.originalIndex !== currentNode.originalIndex);\n  // mark that node's neighbors\n  // top neighbor\n  if (currentNode.row > 0) {\n    const top = nodes[currentNode.originalIndex - size];\n    markNeighbor(top, currentNode);\n  }\n  // right neighbor\n  if (currentNode.col < size - 1) {\n    const right = nodes[currentNode.originalIndex + 1];\n    markNeighbor(right, currentNode);\n  }\n  // bottom neighbor\n  if (currentNode.row < size - 1) {\n    const bottom = nodes[currentNode.originalIndex + size];\n    markNeighbor(bottom, currentNode);\n  }\n  // left neighbor\n  if (currentNode.col > 0) {\n    const left = nodes[currentNode.originalIndex - 1];\n    markNeighbor(left, currentNode);\n  }\n}\nreturn nodes.pop().dist;\nfunction markNeighbor(neighbor, currentNode) {\n  const alreadyMarked = neighbor.dist < Infinity;\n  if (currentNode.dist + neighbor.value < neighbor.dist) {\n    neighbor.dist = currentNode.dist + neighbor.value;\n  }\n  if (!alreadyMarked) {\n    markedNodes.push(neighbor);\n  }\n}",
    "utils": []
  },
  {
    "id": "84",
    "title": "Monopoly Odds",
    "description": [
      null,
      "In the game, Monopoly, the standard board is set up in the following way:",
      null,
      "@image p084.png",
      null,
      "A player starts on the GO square and adds the scores on two 6-sided dice to determine the number of squares they advance in a clockwise direction.",
      null,
      "Without any further rules we would expect to visit each square with equal probability: 2.5%.",
      null,
      "However, landing on G2J (Go To Jail), CC (community chest), and CH (chance) changes this distribution.",
      null,
      "In addition to G2J, and one card from each of CC and CH, that orders the player to go directly to jail, if a player rolls three consecutive doubles, they do not advance the result of their 3rd roll. Instead they proceed directly to jail.",
      null,
      "At the beginning of the game, the CC and CH cards are shuffled. When a player lands on CC or CH they take a card from the top of the respective pile and, after following the instructions, it is returned to the bottom of the pile. There are sixteen cards in each pile, but for the purpose of this problem we are only concerned with cards that order a movement; any instruction not concerned with movement will be ignored and the player will remain on the CC/CH square.",
      null,
      "> Community Chest (2/16 cards):",
      null,
      "  1. Advance to GO",
      null,
      "  2. Go to Jail",
      null,
      "> Chance (10/16 cards):",
      null,
      "  1. Advance to GO",
      null,
      "  2. Go to JAIL",
      null,
      "  3. Go to C1",
      null,
      "  4. Go to E3",
      null,
      "  5. Go to H2",
      null,
      "  6. Go to R1",
      null,
      "  7. Go to next R (railway company)",
      null,
      "  8. Go to next R",
      null,
      "  9. Go to next U (utility company)",
      null,
      "  10. Go back 3 squares.",
      null,
      "The heart of this problem concerns the likelihood of visiting a particular square. That is, the probability of finishing at that square after a roll. For this reason it should be clear that, with the exception of G2J for which the probability of finishing on it is zero, the CH squares will have the lowest probabilities, as 5/8 request a movement to another square, and it is the final square that the player finishes at on each roll that we are interested in. We shall make no distinction between \"Just Visiting\" and being sent to JAIL, and we shall also ignore the rule about requiring a double to \"get out of jail\", assuming that they pay to get out on their next turn.",
      null,
      "By starting at GO and numbering the squares sequentially from 00 to 39 we can concatenate these two-digit numbers to produce strings that correspond with sets of squares.",
      null,
      "Statistically it can be shown that the three most popular squares, in order, are JAIL (6.24%) = Square 10, E3 (3.18%) = Square 24, and GO (3.09%) = Square 00. So these three most popular squares can be listed with the six-digit modal string: 102400.",
      null
    ],
    "question": [
      "If, instead of using two 6-sided dice, two 4-sided dice are used, find the six-digit modal string."
    ],
    "guide": [],
    "solution": "const BOARD = [\n  'GO', 'A1', 'CC1', 'A2', 'T1', 'R1', 'B1', 'CH1', 'B2', 'B3',\n  'JAIL', 'C1', 'U1', 'C2', 'C3', 'R2', 'D1', 'CC2', 'D2', 'D3',\n  'FP', 'E1', 'CH2', 'E2', 'E3', 'R3', 'F1', 'F2', 'U2', 'F3',\n  'G2J', 'G1', 'G2', 'CC3', 'G3', 'R4', 'CH3', 'H1', 'T2', 'H2',\n];\n// list of special squares\nconst SQUARES = {\n  GO: 0,\n  JAIL: 10,\n  C1: 11,\n  E3: 24,\n  H2: 39,\n  R1: 5,\n  R: [5, 15, 25, 35],\n  U: [12, 28],\n};\n// community chest cards\nconst COMM_CHEST = shuffle([\n  () => SQUARES.GO, // advance to GO\n  () => SQUARES.JAIL, // go to jail\n  ...Array(14),\n]);\n// chance cards\nconst CHANCE = shuffle([\n  () => SQUARES.GO, // advance to GO\n  () => SQUARES.JAIL, // go to jail\n  () => SQUARES.C1, // go to C1\n  () => SQUARES.E3, // go to E3\n  () => SQUARES.H2, // go to H2\n  () => SQUARES.R1, // go to R1\n  (square) => (SQUARES.R.find(r => r > square) || SQUARES.R[0]), // go to next R (railroad)\n  (square) => (SQUARES.R.find(r => r > square) || SQUARES.R[0]), // id.\n  (square) => (SQUARES.U.find(u => u > square) || SQUARES.U[0]), // go to next U (utility)\n  (square) => square - 3, // if square <= 2, return  40 + square - 3\n  ...Array(6),\n]);\n// shuffle an array and return the result\nfunction shuffle(arr = []) {\n  const shuffled = [];\n  let source = [...arr];\n  while (shuffled.length < arr.length) {\n    const randomIndex = Math.floor(Math.random() * source.length);\n    shuffled.push(source[randomIndex]);\n    source = [...source.slice(0, randomIndex), ...source.slice(randomIndex + 1, source.length)];\n  }\n  return shuffled;\n}\n// initialize a result table\n// {\n//   0: 0,\n//   1: 0,\n//   ...,\n//   39: 0\n// }\nconst RESULTS = Object.assign({}, ...[...Array(40)].map((_, i) => ({ [i]: 0 })));\nconst DICE_SIDES = 4;\nconst SIM_COUNT = 1000000;\n// run simulation\nrunSim(SIM_COUNT);\n// format and output result\nconst sortedSquares = Object.keys(RESULTS).sort((a, b) => RESULTS[b] - RESULTS[a]).map(x => x.padStart(2, '0'));\nreturn `${sortedSquares[0]}${sortedSquares[1]}${sortedSquares[2]}`;\n// run simulation for simCount turns, each turn may have multiple rolls due to doubles\nfunction runSim(simCount) {\n  // initial square\n  let currentSquare = 0;\n  for (let rolls = 0; rolls < simCount; rolls++) {\n    let doubles = 0;\n    let isDouble = true;\n    // keep rolling if we get a double\n    while (isDouble) {\n      // roll the dices!\n      const [r1, r2] = roll(DICE_SIDES);\n      // if we rolled a double, incr the count\n      if (r1 === r2) {\n        doubles++;\n        // if it's the third double, exit immediately\n        if (doubles === 3) {\n          currentSquare = 10;\n          RESULTS[10]++;\n          break;\n        }\n      } else {\n        // if we didnt roll a double, the loop will not execute again, go to next sim after resolving\n        isDouble = false;\n      }\n      // advance!\n      currentSquare = (currentSquare + r1 + r2) % 40;\n      // resolve any chance/comm_chest/go_to_jail events\n      const [resolvedSquare, stop] = resolveSquare(currentSquare);\n      currentSquare = resolvedSquare;\n      RESULTS[currentSquare]++;\n      if (stop) {\n        break;\n      }\n    }\n  }\n}\n// roll 2 dices, return [dice_1_result, dice_2_result]\nfunction roll(side) {\n  return [Math.ceil(Math.random() * side), Math.ceil(Math.random() * side)];\n}\n// resolve any chance/comm_chest/go_to_jail events\n// returns [resolved_square_index, stop?]\nfunction resolveSquare(square) {\n  const squareContent = BOARD[square];\n  // go to jail\n  if (squareContent === 'G2J' || squareContent === 'JAIL') {\n    return [10, true];\n  }\n  // chance\n  if (squareContent.slice(0, 2) === 'CH') {\n    // draw a card and move to that square\n    const movedTo = resolveCard(square, 'CH');\n    // recursively resolve that square\n    if (movedTo !== square) {\n      return resolveSquare(movedTo);\n    }\n  }\n  // community chest\n  if (squareContent.slice(0, 2) === 'CC') {\n    // draw a card and move to that square\n    const movedTo = resolveCard(square, 'CC');\n    // recursively resolve that square\n    if (movedTo !== square) {\n      return resolveSquare(movedTo);\n    }\n  }\n  // no G2J nor cards, just return the square\n  return [square, false];\n}\n// resolve card and return result square\nfunction resolveCard(square, type) {\n  if (type === 'CH') {\n    const card = CHANCE.shift();\n    CHANCE.push(card);\n    if (card) {\n      return card(square);\n    }\n  }\n  if (type === 'CC') {\n    const card = COMM_CHEST.shift();\n    COMM_CHEST.push(card);\n    if (card) {\n      return card(square);\n    }\n  }\n  return square;\n}",
    "utils": []
  },
  {
    "id": "85",
    "title": "Counting rectangles",
    "description": [
      null,
      "By counting carefully it can be seen that a rectangular grid measuring 3 by 2 contains eighteen rectangles:",
      null,
      "@image p085.png",
      null
    ],
    "question": [
      "Although there exists no rectangular grid that contains exactly two million rectangles, find the area of the grid with the nearest solution."
    ],
    "guide": [],
    "solution": "// to calculate the number of rectangles in an m x n area\n// we use the formula m(m+1)/2 * n(n+1)/2\n// this formula is derived by looking at the total number of combinations of selecting, amongst the lattices of the area,\n// a top-left corner C1 and a bottom-left corner C2 that is not on the same row or column as C1\n// we iterate over n = 1, 2, ...\n// at each step we solve for m, where m(m+1)/2 * n(n+1)/2 = 2,000,000\n// at stated by the problem statement, m cannot be integral, since n is integral\n// therefore we set M = round(m), and calculate the distance between M(M+1)/2 * n(n+1)/2 and 2,000,000\n// the pair (n, M) producing the smallest distance above is the winner\nlet smallestDist = Infinity;\nlet valuesForSmallestDist = [];\nfor (let n = 1; n <= 2000; n++) {\n  const nTriangle = (n * (n + 1)) / 2;\n  // solve nTriangle * m(m+1)/2 = 2,000,000 using quadratic formula\n  const m = (Math.sqrt(1 + (16000000 / nTriangle)) - 1) / 2;\n  const M = Math.round(m);\n  const roundedRectangles = (nTriangle * (M * (M + 1))) / 2;\n  const dist = Math.abs(2000000 - roundedRectangles);\n  if (dist < smallestDist) {\n    smallestDist = dist;\n    valuesForSmallestDist = [n, M];\n  }\n}\nreturn valuesForSmallestDist[0] * valuesForSmallestDist[1];",
    "utils": []
  },
  {
    "id": "86",
    "title": "Cuboid Route",
    "description": [
      null,
      "A spider, S, sits in one corner of a cuboid room, measuring 6 by 5 by 3, and a fly, F, sits in the opposite corner.",
      null,
      "@image p086.png",
      null,
      "By travelling on the surfaces of the room the shortest \"straight line\" distance from S to F is 10 and the path is shown on the diagram.",
      null,
      "However, there are up to three \"shortest\" path candidates for any given cuboid and the shortest route doesn't always have integer length.",
      null,
      "It can be shown that there are exactly 2060 distinct cuboids, ignoring rotations, with integer dimensions, up to a maximum size of M by M by M, for which the shortest route has integer length when M = 100.",
      null,
      "This is the least value of M for which the number of solutions first exceeds two thousand; the number of solutions when M = 99 is 1975.",
      null
    ],
    "question": [
      "Find the least value of M such that the number of solutions first exceeds one million."
    ],
    "guide": [],
    "solution": "// We will break down the solution of this problem into different parts:\n// PART 1: FINDING THE MINIMAL DISTANCE BETWEEN TWO POINTS IN A CUBOID\n// For any cuboid with given lengths (X,Y,Z)\n// (!) The three candidates for the shortest paths are: √(X²+(Y+Z)²), √(Y²+(X+Z)²), √(Z²+(X+Y)²)\n// This can be seen by unfolding the cuboid, and traversing the 3 adjacent surfaces from the starting point.\n// (!) The shortest path among the 3 is the one where the largest side is the 'isolated' square in the root\n// eg. if we have side lengths (6, 5, 3)\n// the winning candidate will be √(6² + (5 + 3)²), since 6 is the largest side, and is also the 'isolated' number\n// otoh, consider the candidate √(5² + (6 + 3)²): here 5 is the isolated number, and thus cannot be the shortest path\n// this is because we want to minimize the difference between the base of the 2 squares inside the root\n// in our case, dist(6, 8) < dist (5, 9), therefore 6² + 8² < 5² + 9²\n// PART 2: FINDING/GENERATING CUBOIDS WITH INTEGRAL SOLUTIONS\n// WLOG, assume that the minimal path for a cuboid is √(X²+(Y+Z)²)\n// (!) The minimal path is integral if and only if X and Y+Z are the 2 smallest numbers in a Pythagorean triplet\n// Using this, we can generate cuboid with integral shortest path from Pythagorean triplets\n// (!) Given a triplet A,B,C; we take A and B, and break B down into the sum of 2 integers\n// eg. Given 6,8,10; we have (6,8) => (6,6,2), (6,5,3), (6,4,4)\n// we skip (6,7,1) since 6 is not the largest side because (7,6,1) will have a shorter path\n// PART 3: INCREMENTAL GENERATION OF CUBOID SOLUTIONS\n// Given any M, we need to find the list of solutions which make a Pythagorean triple with M as one of the 2 legs\n// eg. M = 6, we have 6, 8, 10 as a triplet, the number of cuboids possible with 6 as the longest side is 3\n// eg. M = 8, we have 8, 6, 10 as a triplet, the number of cuboids with 8 as the longest side is 6 / 2 = 3\n// Obs: Let a, b be the legs of a right triangle, and a < b, then we have the following:\n// (!) 1. If M = a, then # solutions = a - ceil(b / 2) + 1\n// (!) 2. If M = b, then # solutions = floor(a / 2)\n// For each M, we need to search from 2 to 2*M, since the smallest cuboid is (M, 1, 1) and the largest is (M, M, M)\nlet answer = 0;\nlet solutions = 0;\nlet M = 1;\nwhile (!answer) {\n  // M > n\n  for (let n = 2; n < M; n++) {\n    if (Number.isInteger(Math.sqrt((M ** 2) + (n ** 2)))) {\n      solutions += Math.floor(n / 2);\n    }\n  }\n  // M < n\n  for (let n = M; n < 2 * M; n++) {\n    if (Number.isInteger(Math.sqrt((M ** 2) + (n ** 2)))) {\n      solutions += (M - Math.ceil(n / 2)) + 1;\n    }\n  }\n  if (solutions > 1000000) {\n    answer = M;\n    return answer;\n  }\n  M++;\n}",
    "utils": []
  }
]